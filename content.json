{"meta":{"title":"GaoHui","subtitle":"Note","description":"Note","author":"GaoHui","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-05-07T22:37:51.180Z","updated":"2018-05-07T22:37:51.180Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-07T22:37:51.204Z","updated":"2018-05-07T22:37:51.204Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-05-07T22:37:51.189Z","updated":"2018-05-07T22:37:51.189Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"基本开发环境","slug":"react/555-开发环境搭建/555-1-react基本开发环境搭建","date":"2018-05-08T00:22:58.136Z","updated":"2018-05-08T00:49:49.165Z","comments":true,"path":"2018/05/08/react/555-开发环境搭建/555-1-react基本开发环境搭建/","link":"","permalink":"http://yoursite.com/2018/05/08/react/555-开发环境搭建/555-1-react基本开发环境搭建/","excerpt":"","text":"基本开发环境基本使用 在页面中使用引入 123456&lt;!--react的核心库--&gt;&lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;!--react的与dom相关的一些功能--&gt;&lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;!--将浏览器不支持的jsx语法转化为js语法--&gt;&lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; 开发环境搭建 使用 create-react-app 快速构建 React 开发环境 安装项目模板 基于webpack快速搭建开发环境 1.全局安装开发环境 1npm install -g create-react-app 2.创建react项目 1create-react-app my-app 3.切换目录 12345678cd my-app辅助cmd命令: mkdir del rmdir tree 4.启动应用程序 12npm start 目录结构解析 使用 tree /f &gt; tree.txt 命令生成项目目录结构 1234567891011121314151617├─ .gitignore│ package.json│ README.md│ ├─public│ favicon.ico│ index.html│ manifest.json│ └─src App.css App.js App.test.js index.css index.js logo.svg registerServiceWorker.js","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"555-开发环境搭建","slug":"react/555-开发环境搭建","permalink":"http://yoursite.com/categories/react/555-开发环境搭建/"}],"tags":[]},{"title":"react编程思想","slug":"react/23-react编程思想/23-react编程思想","date":"2018-05-08T00:22:58.120Z","updated":"2018-05-08T00:49:55.454Z","comments":true,"path":"2018/05/08/react/23-react编程思想/23-react编程思想/","link":"","permalink":"http://yoursite.com/2018/05/08/react/23-react编程思想/23-react编程思想/","excerpt":"","text":"react编程思想","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"23-react编程思想","slug":"react/23-react编程思想","permalink":"http://yoursite.com/categories/react/23-react编程思想/"}],"tags":[]},{"title":"组合和继承","slug":"react/22-组合和继承/22-组合和继承","date":"2018-05-08T00:22:58.120Z","updated":"2018-05-08T00:50:15.950Z","comments":true,"path":"2018/05/08/react/22-组合和继承/22-组合和继承/","link":"","permalink":"http://yoursite.com/2018/05/08/react/22-组合和继承/22-组合和继承/","excerpt":"","text":"组合和继承","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"22-组合和继承","slug":"react/22-组合和继承","permalink":"http://yoursite.com/categories/react/22-组合和继承/"}],"tags":[]},{"title":"redux","slug":"react/16-redux/16-redux","date":"2018-05-08T00:22:58.105Z","updated":"2018-05-08T00:41:14.464Z","comments":true,"path":"2018/05/08/react/16-redux/16-redux/","link":"","permalink":"http://yoursite.com/2018/05/08/react/16-redux/16-redux/","excerpt":"","text":"redux 状态管理 redux是将整个应用程序的状态存储到一个地方, 称为store","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"16-redux","slug":"react/16-redux","permalink":"http://yoursite.com/categories/react/16-redux/"}],"tags":[]},{"title":"状态提升","slug":"react/21-状态提升/21-状态提升","date":"2018-05-08T00:22:58.105Z","updated":"2018-05-08T00:41:29.337Z","comments":true,"path":"2018/05/08/react/21-状态提升/21-状态提升/","link":"","permalink":"http://yoursite.com/2018/05/08/react/21-状态提升/21-状态提升/","excerpt":"","text":"状态提升","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"21-状态提升","slug":"react/21-状态提升","permalink":"http://yoursite.com/categories/react/21-状态提升/"}],"tags":[]},{"title":"react-router","slug":"react/12-router/12-router","date":"2018-05-08T00:22:58.089Z","updated":"2018-05-08T00:41:02.421Z","comments":true,"path":"2018/05/08/react/12-router/12-router/","link":"","permalink":"http://yoursite.com/2018/05/08/react/12-router/12-router/","excerpt":"","text":"react-router路由的基本实现注意事项 Router或者说是 BrowserRouter 的内部 只能有一个根元素 1.引入相关的包 12345import &#123; BrowserRouter as Router, Route, Link&#125; from &apos;react-router-dom&apos; 2.创建组件并导入 123456789101112131415161718192021222324252627282930313233343536373839404142// 创建home组件import React , &#123;Component&#125; from &quot;react&quot;export class Home extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;// 创建About组件import React , &#123;Component&#125; from &quot;react&quot;export class About extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;关于&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;// 创建topic组件import React , &#123;Component&#125; from &quot;react&quot;export class Topic extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;主题&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;import &#123;Home&#125; from &apos;./home/home&apos;import &#123;About&#125; from &apos;./about/about&apos;import &#123;Topic&#125; from &apos;./topic/topic&apos; 3-4.完善路由跳转链接和路由信息配置 123456789101112131415161718192021222324&lt;Router&gt; &lt;div&gt; &#123;/*3. 定义路由跳转的链接*/&#125; &lt;ul&gt; &lt;li&gt; &lt;Link to=&apos;/&apos;&gt;首页&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&apos;/about&apos;&gt;关于&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&apos;/topic&apos;&gt;主题&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr/&gt; &#123;/*4. 配置路由信息*/&#125; &#123;/*exact : 确切的 精确的*/&#125; &lt;Route exact path=&apos;/&apos; component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path=&apos;/about&apos; component=&#123;About&#125;&gt;&lt;/Route&gt; &lt;Route path=&apos;/topic&apos; component=&#123;Topic&#125;&gt;&lt;/Route&gt; &lt;/div&gt;&lt;/Router&gt; 二级路由 在上述代码的基础上修改 Topic 组件 ,可以实现二级路由 注意事项 获取一级路由信息, 类组件使用 this.props , 函数式组件使用 props 参数 在路由跳转的时候进行拼接url &lt;Link to={${props.url}/topic2}&gt;topic2&lt;/Link&gt; &lt;Route path={${props.url}/topic1} component={Topic1}&gt;&lt;/Route&gt; 路由参数的获取 使用 console.log(props.match.params.id) 具体内容参考以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import React , &#123;Component&#125; from &quot;react&quot;import &#123;BrowserRouter as Router,Route, Link&#125; from &quot;react-router-dom&quot;// 主题组件1function Topic1 () &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )&#125;// 主题组件2function Topic2 () &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )&#125;// 主题组件3function Topic3 (props) &#123; // 获取传递的id参数 console.log(props.match.params.id) return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )&#125;// 函数式组件 ---- 路由创建2function BasicExample2 (props) &#123; console.log(props.url) return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;props.url&#125;/topic1`&#125;&gt;topic1&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;props.url&#125;/topic2`&#125;&gt;topic2&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;props.url&#125;/topic3`&#125;&gt;topic3&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=&#123;`$&#123;props.url&#125;/topic1`&#125; component=&#123;Topic1&#125;&gt;&lt;/Route&gt; &lt;Route path=&#123;`$&#123;props.url&#125;/topic2`&#125; component=&#123;Topic2&#125;&gt;&lt;/Route&gt; &lt;Route path=&#123;`$&#123;props.url&#125;/topic3`&#125; component=&#123;Topic3&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/Router&gt; )&#125;export class Topic extends Component&#123; render()&#123; console.log(this.props.match.path) return ( &lt;div&gt; &lt;h2&gt;主题&lt;/h2&gt; &lt;BasicExample2 url=&#123;this.props.match.path&#125;&gt;&lt;/BasicExample2&gt; &lt;/div&gt; ) &#125;&#125; api文档BrowserRouter","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"12-router","slug":"react/12-router","permalink":"http://yoursite.com/categories/react/12-router/"}],"tags":[]},{"title":"forms","slug":"react/10-form/10-forms","date":"2018-05-08T00:22:58.073Z","updated":"2018-05-08T00:40:47.420Z","comments":true,"path":"2018/05/08/react/10-form/10-forms/","link":"","permalink":"http://yoursite.com/2018/05/08/react/10-form/10-forms/","excerpt":"","text":"forms表单概述 HTML 表单元素与 React 中的其他 DOM 元素有所不同，因为表单元素自然地保留了一些内部状态。例如，这个纯 HTML 表单接受一个单独的 name： 1234567&lt;form&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 该表单和 HTML 表单的默认行为一致，当用户提交此表单时浏览器会打开一个新页面。如果你希望 React 中保持这个行为，也可以工作。但是多数情况下，用一个处理表单提交并访问用户输入到表单中的数据的 JavaScript 函数也很方便。实现这一点的标准方法是使用一种称为“受控组件(controlled components)”的技术。 受控组件Controll 在 HTML 中，表单元素如 &lt;input&gt;，&lt;textarea&gt; 和 &lt;select&gt;表单元素通常保持自己的状态，并根据用户输入进行更新。而在 React 中，可变状态一般保存在组件的 state(状态) 属性中，并且只能通过 setState()更新。 我们可以通过使 React 的 state 成为 “单一数据源原则”来结合这两个形式。然后渲染表单的 React 组件也可以控制在用户输入之后的行为。这种形式，其值由 React 控制的输入表单元素称为“受控组件”。 数据/状态的定义: 使用 this.state = {} 状态的修改: this.state.setState({}) 12345678910111213141516171819202122232425262728293031323334 // 定义类组件class NameForms extends React.Component&#123; constructor(props)&#123; super(props) // 定义状态 this.state = &#123;value:&apos;&apos;&#125; // 函数可以产生独立作用域 ,在这里修改函数内部的指针指向 当前组件(类) this.handleChange = this.handleChange.bind(this) this.handleSubmit = this.handleSubmit.bind(this) &#125; handleChange(e)&#123; this.setState(&#123;value:e.target.value&#125;) &#125; handleSubmit(e)&#123; alert(&quot;A name was submitted : &quot; + this.state.value) e.preventDefault() &#125; render()&#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label for=&quot;&quot;&gt; name : &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ) &#125;&#125;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"10-form","slug":"react/10-form","permalink":"http://yoursite.com/categories/react/10-form/"}],"tags":[]},{"title":"react数据请求","slug":"react/08-数据请求/08-fetchApi-数据请求","date":"2018-05-08T00:22:58.042Z","updated":"2018-05-08T00:40:36.587Z","comments":true,"path":"2018/05/08/react/08-数据请求/08-fetchApi-数据请求/","link":"","permalink":"http://yoursite.com/2018/05/08/react/08-数据请求/08-fetchApi-数据请求/","excerpt":"","text":"react数据请求参考文档 https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch 基本使用cdn链接1&lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; get请求静态数据 最初的时候, 渲染页面 , 数据都是写在本页面 这样操作的问题是修改页面内容不方便, 只能通过操作本页面完成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[ &#123;&quot;id&quot;:&quot;123001&quot;,&quot;name&quot;:&quot;xiaoming&quot;&#125;, &#123;&quot;id&quot;:&quot;123002&quot;,&quot;name&quot;:&quot;xiaobing&quot;&#125;, &#123;&quot;id&quot;:&quot;123003&quot;,&quot;name&quot;:&quot;xiaona&quot;&#125; ] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; json文件 实现页面结构和数据的分离, 修改页面内容的时候, 操作文件即可 以json文件为例, 修改json文件之后, 我们页面的内容也会发生变化 json文件定义—-数据定义 12345[ &#123;&quot;id&quot;:&quot;123001&quot;,&quot;name&quot;:&quot;xiaoming&quot;&#125;, &#123;&quot;id&quot;:&quot;123002&quot;,&quot;name&quot;:&quot;xiaobing&quot;&#125;, &#123;&quot;id&quot;:&quot;123003&quot;,&quot;name&quot;:&quot;xiaona&quot;&#125;] 请求json文件,完成页面的渲染 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &quot;data.json&quot; var option = &#123; methods:&quot;get&quot; &#125; fetch(url,option).then((res)=&gt;&#123; return res.json() &#125;).then((res)=&gt;&#123; // 请求到的数据 console.log(res) // 修改state this.setState(&#123; arr:res &#125;) // 打印输出 console.log(this.state.arr) &#125;) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 数据库 为了便于数据的操作, 我们平时看到的页面上的数据一般都是存在数据库的, 通过后台管理系统, 能够很方便的实现数据的修改 – 此例 不多做演示 在线接口 书写数据接口, 通过后台操作, 读取数据库数据, 并做成接口的形式, 我们需要对数据进行操作的时候,直接操作接口即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; [&#123;&quot;id&quot;:&quot;123001&quot;,&quot;name&quot;:&quot;xiaoming&quot;&#125;,&#123;&quot;id&quot;:&quot;123002&quot;,&quot;name&quot;:&quot;xiaobing&quot;&#125;,&#123;&quot;id&quot;:&quot;123003&quot;,&quot;name&quot;:&quot;xiaona&quot;&#125;] class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &quot;http://www.taoquan.store/robot/getUsers.php&quot; var option = &#123; methods:&quot;get&quot; &#125; fetch(url,option).then((res)=&gt;&#123; return res.json() &#125;).then((res)=&gt;&#123; // 请求到的数据 console.log(res.users) // 修改state this.setState(&#123; arr:res.users &#125;) // 打印输出 console.log(this.state.arr) &#125;) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; post请求 将数据提交到数据库 基本示例 在真正操作的时候只需要将要提交的数据换成表单数据即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; num:1 &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &apos;http://127.0.0.1:8899/api/insertData&apos; var options = &#123; method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125;, body: &apos;name=1&amp;sex=2&amp;email=3&amp;phone=4&amp;address=5&apos; &#125; fetch(url,options) .then((res)=&gt;&#123; return res.json() &#125;) .then((res)=&gt;&#123; console.log(res) &#125;) &#125; &#125; ReactDOM.render( &lt;Com&gt;&lt;/Com&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 核心代码1234567891011121314151617var url = &apos;http://127.0.0.1:8899/api/insertData&apos;var options = &#123; method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125;, body: &apos;name=1&amp;sex=2&amp;email=3&amp;phone=4&amp;address=5&apos;&#125;fetch(url,options).then((res)=&gt;&#123; return res.json()&#125;).then((res)=&gt;&#123; console.log(res)&#125;) 第二种方式12345678910111213141516171819202122componentDidMount()&#123; var data = &#123; name:&quot;1&quot;, sex:&quot;2&quot;, email:&quot;3&quot;, phone:&quot;4&quot;, address:&quot;5&quot; &#125; fetch(&apos;http://127.0.0.1:8899/api/insertData&apos;,&#123; method: &apos;POST&apos;, body: `data=$&#123;JSON.stringify(data)&#125;`, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125; &#125;) .then((res)=&gt;&#123; console.log(res.json()) &#125;)&#125; 文件上传 Content-Type：上传文件的时候，一定要设置为application/x-www-form-urlencoded 跨域fetch跨域概述 在fetch的配置中有 mode选项 , 提供了跨域的能力 mode: ‘cors’, // no-cors, cors, *same-origin mode:’cors’ 这个选项提供了跨域的能力, 但是服务端必须支持 cors ,也就是设置 res.header(“Access-Control-Allow-Origin”, “*”); mode:’no-cors’ 可以跨域进行数据请求 , 不需要设置跨域 header 在该模式下 得到的返回数据中 type为opaque。, 能够在控制台看到返回的数据, 但是没有权限使用这些数据 mode:”same-origin” 同源, 不允许跨域 并不能成功跨域进行数据的访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &quot;https://api.douban.com/v2/movie/top250&quot; // var url = &apos;http://127.0.0.1:8899/api/selectData&apos; var option = &#123; methods:&quot;get&quot;, mode:&apos;no-cors&apos; &#125; fetch(url,option).then((res)=&gt;&#123; console.log(res) &#125;) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 使用jsonp调取数据 在原生js中, 利用script标签的支持跨域的特性进行 第一种方式 利用script标签的跨域访问特性 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSONP实现跨域2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--代码的先后顺序 不能变--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn(response)&#123; console.log(response); &#125;&lt;/script&gt;&lt;script src=&quot;https://api.douban.com/v2/movie/top250?callback=fn&quot;&gt;&lt;/script&gt; 第二种方式 动态创建script标签 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSONP实现跨域2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--代码的先后顺序 不能变--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn(response)&#123; console.log(response); &#125; var script = document.createElement(&apos;script&apos;) script.src = &apos;https://api.douban.com/v2/movie/top250?callback=fn&apos; document.body.insertBefore(script, document.body.firstChild); &lt;/script&gt; 第三种方式 使用jquery 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; type:&apos;get&apos;, url:&quot;https://api.douban.com/v2/movie/top250?callback=?&quot;, success(res)&#123; console.log(res) &#125;, dataType:&quot;jsonp&quot; &#125;) &lt;/script&gt; 项目中使用 create-react-app fetchApi的使用 npm 地址 https://www.npmjs.com/package/whatwg-fetch 详细的使用说明可以参考这个文档 12345671. 安装 npm install whatwg-fetch --save2. 配置 在使用webpack的时候,需要完成这一步的配置 entry: [&apos;whatwg-fetch&apos;, ...]3. 使用 直接导入这个包即可 import &apos;whatwg-fetch&apos; 请求html文件12345678HTMLfetch(&apos;/users.html&apos;) .then(function(response) &#123; return response.text() &#125;).then(function(body) &#123; document.body.innerHTML = body &#125;) get 请求获取数据 在componentDidMount(){}生命周期钩子中进行数据的初始化操作 1.在构造函数中初始化状态(数据) 1234567constructor(props)&#123; super(props) this.state = &#123; arr:[], name:&quot;test&quot; &#125;&#125; 2.在 componentDidMount 中发送请求,获取数据 12345678910111213141516componentDidMount() &#123; console.log(1) fetch(&apos;http://gaohuimusic.nat123.cc:11444/personalized&apos;) .then((response) =&gt; &#123; return response.json() &#125;).then((json) =&gt; &#123; console.log(&apos;parsed json&apos;, json) this.setState(&#123; arr:json.result &#125;) console.log(this.state.arr) &#125;).catch(function(ex) &#123; console.log(&apos;parsing failed&apos;, ex) &#125;)&#125; 3.在render()函数中完成页面渲染—-将请求到的数据渲染到页面 1234567891011121314render() &#123; return ( &lt;div&gt; &lt;p&gt;这是tab1&lt;/p&gt; &lt;div&gt; &lt;ul&gt; &#123;this.state.arr.map(function(ele,index,arr)&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; )&#125; post 请求","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"08-数据请求","slug":"react/08-数据请求","permalink":"http://yoursite.com/categories/react/08-数据请求/"}],"tags":[]},{"title":"组件补充","slug":"react/07-组件补充/07-组件补充","date":"2018-05-08T00:22:57.995Z","updated":"2018-05-08T00:40:22.704Z","comments":true,"path":"2018/05/08/react/07-组件补充/07-组件补充/","link":"","permalink":"http://yoursite.com/2018/05/08/react/07-组件补充/07-组件补充/","excerpt":"","text":"组件补充组件的嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1.1 创建一个基本的组件 function Welcome(props)&#123; return ( &lt;div&gt; &lt;p&gt;&#123;props.name&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; // 1.2 创建一个app组件,并使用Welcome组件 function App(props)&#123; return ( &lt;div&gt; &lt;Welcome name=&quot;1&quot;&gt;&lt;/Welcome&gt; &lt;Welcome name=&quot;2&quot;&gt;&lt;/Welcome&gt; &lt;Welcome name=&quot;3&quot;&gt;&lt;/Welcome&gt; &lt;/div&gt; ) &#125; var element = &lt;App&gt;&lt;/App&gt; // 2. 组件的使用 ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 公共组件的提取12 props总结props是只读的 所有 React 组件都必须是纯函数，并禁止修改其自身 props 。 知识点扩充纯函数 不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。 123function sum(a, b) &#123; return a + b;&#125; 非纯函数 改变了自身的输入值 123function withdraw(account, amount) &#123; account.total -= amount;&#125;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"07-组件补充","slug":"react/07-组件补充","permalink":"http://yoursite.com/categories/react/07-组件补充/"}],"tags":[]},{"title":"组件传值","slug":"react/06-组件传值/06-组件传值","date":"2018-05-08T00:22:57.964Z","updated":"2018-05-08T00:52:18.304Z","comments":true,"path":"2018/05/08/react/06-组件传值/06-组件传值/","link":"","permalink":"http://yoursite.com/2018/05/08/react/06-组件传值/06-组件传值/","excerpt":"","text":"组件传值 每个组件 的作用域都是独立的, 有时候需要在组件之间完成数据的传递,需要通过组件传值的方式来实现 组件传值可以分为以下三类 父组件向子组件传递数据 子组件向父组件传递数据 非父子组件之间的数据传递 父传子 – 简化版函数式组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot; class=&quot;parent&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个函数组件 ---- 使用props完成值得接收 function Child(props)&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; ReactDOM.render( // 渲染组件 并通过name属性完成传值 &lt;Child name=&quot;3&quot;&gt;&lt;/Child&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个类组件 class Child extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Child name=&quot;1&quot;&gt;&lt;/Child&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 组件传值详解1234567我们调用了 ReactDOM.render() 方法并向其中传入了 &lt;Child name=&quot;1&quot; /&gt; 元素。React 调用 Child 组件，并向其中传入了 &#123;name: &apos;1&apos;&#125; 作为 props 对象。Child 组件返回 &lt;li&gt;1&lt;/li&gt;。React DOM 迅速更新 DOM ，使其显示为 &lt;li&gt;1&lt;/li&gt;。 父传子 – 完整版函数式组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个父组件 function Parent()&#123; return ( &lt;div&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &#123;/*在父组件中嵌套子组件*/&#125; &lt;Child name=&quot;1&quot;&gt;&lt;/Child&gt; &lt;/div&gt; ) &#125; // 创建一个子组件 列表 function Child(props)&#123; return ( &lt;div&gt; &lt;h3&gt;这是子组件&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&#123;props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; // 2. 组件的使用 ReactDOM.render( &lt;Parent&gt;&lt;/Parent&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个类组件 -- 父 class Parent extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &#123;/*在父组件中嵌套子组件*/&#125; &lt;Child name=&quot;1&quot;&gt;&lt;/Child&gt; &lt;/div&gt; ) &#125; &#125; // 创建一个类组件 -- 子 class Child extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;h3&gt;这是子组件&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Parent&gt;&lt;/Parent&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 子传父函数式组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; //子组件 function Child(props)&#123; return ( &lt;div&gt; &#123;/*当文本框内容发生变化的时候.会执行父组件里面的事件*/&#125; 子组件：&lt;input onChange=&#123;props.handleEmail&#125;/&gt; &lt;/div&gt; ) &#125; //父组件 function Parent() &#123; return ( &lt;div&gt; &lt;div id=&apos;div&apos;&gt;父组件：&#123;1&#125;&lt;/div&gt; &lt;Child name=&quot;email&quot; handleEmail=&#123; function (event)&#123; /*获取子组件的数据*/ console.log(event.target.value) document.getElementById(&apos;div&apos;) = event.target.value &#125; &#125;/&gt; &lt;/div&gt; ) &#125; ReactDOM.render( &lt;Parent /&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; //子组件 class Child extends React.Component&#123; render()&#123; return ( &lt;div&gt; &#123;/*当文本框内容发生变化的时候.会执行父组件里面的事件*/&#125; 子组件：&lt;input onChange=&#123;this.props.handleEmail&#125;/&gt; &lt;/div&gt; ) &#125; &#125; //父组件 class Parent extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; email:&apos;&apos; &#125; &#125; handleEmail(event)&#123; this.setState(&#123;email: event.target.value&#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;div&gt;父组件：&#123;this.state.email&#125;&lt;/div&gt; &lt;Child name=&quot;email&quot; handleEmail=&#123;this.handleEmail.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Parent /&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 非父子非父子组件传值之兄弟组件传值 使用中间人模式 , 定义一个公共的父组件来实现兄弟组件之间的数据传递 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Brother1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.props.refresh&#125;&gt; 更新兄弟组件 &lt;/button&gt; &lt;/div&gt; ) &#125; &#125; class Brother2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.text || &quot;兄弟组件未更新&quot;&#125; &lt;/div&gt; ) &#125; &#125; class Parent extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; refresh()&#123; return (e)=&gt;&#123; this.setState(&#123; text: &quot;兄弟组件沟通成功&quot;, &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;兄弟组件沟通&lt;/h2&gt; &lt;Brother1 refresh=&#123;this.refresh()&#125;/&gt; &lt;Brother2 text=&#123;this.state.text&#125;/&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;Parent /&gt;, document.getElementById(&apos;root&apos;));&lt;/script&gt; 使用jquery自定义事件完成传值 根据上面理解的思路, 使用jquery的事件机制作为中间人, 实现数据的传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Com1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; $(&apos;#root&apos;).on(&apos;bus&apos;,function(e,a,b)&#123; console.log(a,b) &#125;) &#125; &#125; class Com2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; $(&apos;#root&apos;).trigger(&apos;bus&apos;,[11,22]) &#125; &#125; ReactDOM.render( &lt;div&gt; &lt;Com1&gt;&lt;/Com1&gt; &lt;Com2&gt;&lt;/Com2&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;));&lt;/script&gt; 使用原生js的方式实现组件之间的数据的传递 上述使用jquery能够实现数据的传递,但是这样操作的话, 并不是最佳的方式 如果我们只是为了实现组件之间的数据传递而引入jquery框架, 会使项目变得臃肿 为了更好的体验, 我们可以使用原生js的自定义事件的方式完成组件之间的数据的传递 注意事项: 在这里,只是关注与功能的实现, 不考虑兼容性的问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 给dom元素绑定事件 ---- 作为中间人 var elem = document.getElementById(&apos;root&apos;) var events = new Event(&apos;build&apos;); class Com1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; // 给dom元素添加事件监听, 通过函数参数完成数据的接收 elem.addEventListener(&apos;build&apos;, function (event) &#123; console.log(event.name) &#125;, false); &#125; &#125; class Com2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; name:&apos;我是小高&apos; &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; events.name = this.state.name elem.dispatchEvent(events) &#125; &#125; ReactDOM.render( &lt;div&gt; &lt;Com1&gt;&lt;/Com1&gt; &lt;Com2&gt;&lt;/Com2&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;));&lt;/script&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"06-组件传值","slug":"react/06-组件传值","permalink":"http://yoursite.com/categories/react/06-组件传值/"}],"tags":[]},{"title":"state和生命周期","slug":"react/05-state和生命周期/05-state和生命周期","date":"2018-05-08T00:22:57.933Z","updated":"2018-05-08T00:40:00.388Z","comments":true,"path":"2018/05/08/react/05-state和生命周期/05-state和生命周期/","link":"","permalink":"http://yoursite.com/2018/05/08/react/05-state和生命周期/05-state和生命周期/","excerpt":"","text":"state和生命周期state state 允许 React 组件在不违反props规则的情况下, 根据用户操作, 网络响应, 或者其他随便什么东西, 来动态地改变其输出。类似于vue中的data state的定义 在类组件的constructor中定义state 12345678constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;; &#125; 状态的修改不能直接修改state 需要调用this.setState() 12345678910// 错误 这样将不会重新渲染一个组件：this.state.comment = &apos;Hello&apos;;// 正确 用 setState() 代替：this.setState(&#123;comment: &apos;Hello&apos;&#125;);唯一可以分配 this.state 的地方是构造函数。 state(状态) 更新可能是异步的使用回调函数的形式实现异步操作 需要将对象参数转变为回调函数的形式 1234567891011121314// 错误this.setState(&#123; counter: this.state.counter + this.props.increment,&#125;);// 正确this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;));使用另一种 setState() 的形式，它接受一个函数而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数： state(状态)更新会被合并你的状态可能包含几个独立的变量： 12345678constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125; 调用this.setState()修改单个的状态不会影响其他的状态,只会合并当前修改的这一个状态 react-hook函数hook函数的基本概念hook函数参考链接 https://baike.baidu.com/item/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0?fr=aladdin 钩子函数是window消息处理机制的一部分,通过设置”钩子”,应用程序可以在系统级对所有消息,事件进行过滤,访问在正常情况下无法访问的消息 钩子函数的本质是一段用以处理系统消息的程序,通过系统调用,把它挂入系统 react组件的三个状态1.mount123react Components被render解析生成对应的dom节点被插入浏览器的dom结构的一个过程在浏览器上看到组件元素从无到有的过程 2.update 1234一个mounte的react Component被重新render的过程,但是在这个过程中,dom结构并不一定会发生改变在react中,状态的改变会触发update的hook函数 3.unmount 1一个mount的react Component对应的dom节点被从dm中移除的一个过程 react针对以上三种状态都封装了hook函数 生命周期钩子详解mounting 如下这些方法在组件实例被创建和被插入到dom中时被调用。 1.constructor() constructor初始化state的好地方。如果我们不需要初始化state，也不需要bind任何方法，那么在我们的组件中不需要实现constructor函constructor在组件被mounted之前调用，我们的组件继承自React.Component,constructor函数中我们在其他操作前应该先调用super(props)，否则this.props将会是undefined。 constructor初始化state的好地方。如果我们不需要初始化state，也不需要bind任何方法，那么在我们的组件中不需要实现constructor函数。 注意下面这种情况，很容易产生bug，我们通常的做法是提升state到父组件，而不是使劲的同步state和props。 123456constructor(props) &#123; super(props); this.state = &#123; color: props.initialColor &#125;;&#125; componentWillMount() 此方法在mounting之前被立即调用，它在render()之前调用，因此在此方法中setState不会触发重新渲染。此方法是服务器渲染中调用的唯一的生命周期钩子，通常我们建议使用constructor()。 render() render()方法是react组件必须的，它检查this.props和this.state并且返回一个React元素，我们也可以返回null或false，代表我们不想有任何的渲染。 render()方法应该是一个纯方法，即它不会修改组件的state，在每一次调用时返回同样的结果。它不直接和浏览器交互，如果我们想要交互，应该在componentDidMount()或者其他的生命周期函数里面。 componentDidMount() 此方法在组件被mounted之后立即被调用，初始化dom节点应该在此方法中，如果需要从远端健在数据，这里是实例化网络请求的好地方，此方法中setState会触发组件重新渲染。 Updating props和state的改变产生更新。在重新渲染组建时，如下的方法被调用 componentWillReceiveProps() 一个已经mounted的组件接收一个新的props之前componentWillReceiveProps()被调用，如果我们需要更新state来响应prop的更改，我们可以在此方法中比较this.props和nextProps并使用this.setState来更改state。 注意，即使props没有改变，React也可以调用这个方法，因此如果你只想处理改变，请确保比较当前值和下一个值。当父组件导致你的组件重新渲染时，可能会发生这种情况。 React在组件mounting期间不会调用此方法，只有在一些组件的props可能被更新的时候才会调用。调用this.setState通常不会触发componentWillReceiveProps。 shouldComponentUpdate() 使用此方法让React知道组件的输出是否不受当前state或props更改的影响。默认行为是在每次state更改时重新渲染组件，在大多数情况下，我们应该默认改行为。 当接收到新的props或state时，shouldComponentUpdate()在渲染之前被调用。默认返回true，对于初始渲染或使用forceUpdate()时，不调用此方法。返回false不会阻止子组件的state更改时，该子组件重新渲染。 如果shouldComponentUpdate()返回false，那么componentWillUpdate()，render()和componentDidUpdate()将不会被调用。在将来，React可能将shouldComponentUpdate()作为提示而不是strict指令，返回仍然可能导致组件重新渲染。 componentWillUpdate() 当接收新的props或state时，componentWillUpdate()在组件渲染之前被立即调用。使用此函数作为在更新发生之前执行准备的机会。初始渲染不会调用此方法。 注意：这里不能调用this.setState()(如果调用会怎么样？好奇心很重呀，试了一下，会产生死循环，一直更新。 如果我们需要更新state以响应props的更改，我们应该使用componentWillReceiveProps() render() render()方法是react组件必须的，它检查this.props和this.state并且返回一个React元素，我们也可以返回null或false，代表我们不想有任何的渲染。 render()方法应该是一个纯方法，即它不会修改组件的state，在每一次调用时返回同样的结果。它不直接和浏览器交互，如果我们想要交互，应该在componentDidMount()或者其他的生命周期函数里面。 componentDidUpdate() 此函数在更新后立即被调用。初始渲染不调用此方法。 当组件已经更新时，使用此操作作为DOM操作的机会。这也是一个好的地方做网络请求，只要你比较当前的props和以前的props(例如：如果props没有改变，可能不需要网络请求)。 Unmounting 当从dom中移除组件时，这个方法会被调用 componentWillUnmount() 此函数在组件被卸载和销毁之前被立即调用。在此方法中执行一些必要的清理。例如清除计时器，取消网络请求或者清理在componentDidMount中创建的任何DOM元素。 实例演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/babel\"&gt; // 创建一个类组件 class LifeCycle extends React.Component &#123; // 1. mount阶段 constructor(props) &#123; super(props); this.state = &#123;name: 'wlt'&#125;; this.changeState = this.changeState.bind(this); console.log('constructor'); &#125; componentWillMount() &#123; console.log('componentWillMount'); &#125; render() &#123; console.log('render'); return ( &lt;div className=\"life-cycle-bg\"&gt; &lt;p&gt;Hello &#123;this.props.value&#125;&lt;/p&gt; &lt;p&gt;Hello &#123;this.state.name&#125;&lt;/p&gt; &lt;button onClick=&#123;this.changeState&#125;&gt;改变lifeCycle的state&lt;/button&gt; &lt;/div&gt; ); &#125; componentDidMount() &#123; console.log('componentDidMount'); &#125; // 2. update阶段 componentWillReceiveProps(nextProps) &#123; // 只作用于属性的变化,不作用于状态的变化 console.log('componentWillReceiveProps'); &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log('shouldComponentUpdate'); return true; &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('componentWillUpdate'); &#125; // ---- render会重新执行 componentDidUpdate(prevProps, prevState) &#123; console.log('componentDidUpdate'); &#125; // 3. Unmount阶段 componentWillUnmount(prevProps, prevState) &#123; console.log('componentWillUnmount'); &#125; // 修改状态 changeState() &#123; this.setState(&#123;name: 'sxm'&#125;); &#125; &#125; class ParentLifeCycle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: 'World', destroyed: false, rerender: false &#125;; this.handleChange = this.handleChange.bind(this); this.destroyComponent = this.destroyComponent.bind(this); this.handleRerender = this.handleRerender.bind(this); &#125; handleChange() &#123; this.setState((prevState, props) =&gt; (&#123; value: prevState.value + ' wlt' &#125;)); &#125; handleRerender() &#123; this.setState(&#123;rerender: true&#125;); &#125; destroyComponent() &#123; this.setState(&#123;destroyed: true&#125;); &#125; render() &#123; if(this.state.destroyed) return null; return ( &lt;div className=\"parent-life-cycle-bg\"&gt; &lt;p&gt; &lt;button onClick=&#123;this.handleChange&#125;&gt;改变LifeCyle的props&lt;/button&gt; &lt;button onClick=&#123;this.handleRerender&#125;&gt;父组件重新渲染，子组件re-render&lt;/button&gt; &lt;button onClick=&#123;this.destroyComponent&#125;&gt;删除组件&lt;/button&gt; &lt;/p&gt; &lt;LifeCycle value=&#123;this.state.value&#125;/&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;ParentLifeCycle /&gt;, document.getElementById('root') );&lt;/script&gt; state 和 生命周期一个简单的例子 实现一个基本的定时器功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个组件 -- 使用函数式组件 function Clock()&#123; // 创建元素 const element = ( &lt;div&gt; &lt;h1&gt;hello world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) // 使用render函数渲染已经创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &#125; setInterval(Clock,1000)&lt;/script&gt; 存在的问题 完成定时器的功能,使用组件化的形式进行封装的时候,在进行组件调用的时候应该能够直接通过 就能完成一个定时器,而不用再配合外部的js操作 这样做的话能够实现相关的功能,但是不利于复用 改写 使用组件的形式封装一个计时器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 在组件挂载和卸载的时候,会执行对应的生命周期钩子函数 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 使用类的形式对组件进行改写之后,我们可以向类中添加一些内容 class Clock extends React.Component&#123; constructor(props)&#123; // 类组件应始终使用 props 调用基础构造函数。 super(props) // 使用状态进行改写 this.state = &#123; date:new Date() &#125; &#125; // 组件挂载的生命周期钩子函数 componentDidMount()&#123; console.log(&quot;组件挂载了&quot;) this.timer = setInterval(()=&gt;&#123; // 使用this.setState() 更新本地的状态 this.setState(&#123; date:new Date() &#125;) &#125;,1000) &#125; // 组件卸载时会执行的生命周期钩子函数 componentWillUnmount()&#123; console.log(&quot;组件卸载了&quot;) clearInterval(this.timer) &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;hello world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125; &#125; // 使用render函数渲染已经创建的组件 ----- 三个组件互补影响 ReactDOM.render( &lt;div&gt; &lt;Clock&gt;&lt;/Clock&gt; &lt;Clock&gt;&lt;/Clock&gt; &lt;Clock&gt;&lt;/Clock&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"05-state和生命周期","slug":"react/05-state和生命周期","permalink":"http://yoursite.com/categories/react/05-state和生命周期/"}],"tags":[]},{"title":"组件","slug":"react/04-组件基本使用/04-组件基本使用","date":"2018-05-08T00:22:57.901Z","updated":"2018-05-08T00:39:42.075Z","comments":true,"path":"2018/05/08/react/04-组件基本使用/04-组件基本使用/","link":"","permalink":"http://yoursite.com/2018/05/08/react/04-组件基本使用/04-组件基本使用/","excerpt":"","text":"组件什么是组件 组成的部件 组件使你可以将 UI 划分为一个一个独立，可复用的小部件，并可以对每个部件进行单独的设计。 从定义上来说， 组件就像JavaScript的函数。封装内容, 达到重用的目的. 组件可以接收任意输入(称为”props”)， 并返回 React 元素，用以描述屏幕显示内容 为什么使用组件 封装 重用 如何使用组件 在使用组件的时候, 推荐使用类组件的形式 注意事项 组件的名称 首字母必须大写 一个组件只能有一个根元素 两种组件创建的方式函数式组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1. 创建一个基本的组件 function Welcome()&#123; return ( &lt;div&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;/div&gt; ) &#125; // 2. 组件的使用 ReactDOM.render( &lt;Welcome&gt;&lt;/Welcome&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt; &lt;script type=&quot;text/babel&quot;&gt; // 1. 创建一个基本的组件 class Welcome extends React.Component&#123; render ()&#123; return ( &lt;div&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;/div&gt; ) &#125; &#125; // 2. 组件的使用 ReactDOM.render( &lt;Welcome&gt;&lt;/Welcome&gt;, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 补充类组件的事件绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Toggle extends React.Component &#123; constructor(props) &#123; super(props); // 设置状态 this.state = &#123;isToggleOn: true&#125;; // 这个绑定是必要的，使`this`在回调中起作用 this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; ); &#125; &#125; ReactDOM.render( &lt;Toggle /&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"04-组件基本使用","slug":"react/04-组件基本使用","permalink":"http://yoursite.com/categories/react/04-组件基本使用/"}],"tags":[]},{"title":"jsx语法","slug":"react/02-jsx语法/02-jsx语法","date":"2018-05-08T00:22:57.870Z","updated":"2018-05-08T00:39:25.715Z","comments":true,"path":"2018/05/08/react/02-jsx语法/02-jsx语法/","link":"","permalink":"http://yoursite.com/2018/05/08/react/02-jsx语法/02-jsx语法/","excerpt":"","text":"jsx语法什么是jsx语法语法特点 react使用jsx代替常规的javascript 1234567891011 1. 一个很像是XML的js语法扩展 2. 编写模板更加快速-简单 3. 它是类型安全的,在编译的过程中就能发现错误``` ### 使用规则&gt; react jsx的使用 1. 可以创建一个独立的js文件来使用,通过script标签来引入 2. 使用多个标签,使用div包裹 3. 支持表达式, js表达式可以直接被解析 4. 不支持if else 可以使用三元表达式代替 相当于是vue中 的 v-if 5. 直接解析数组 相当于是vue中的v-for 6. 标签中注释使用花括号包裹,区别于原先的js注释 , 否则的话 , 注释会 直接解析成文本 7. 推荐使用内联样式 直接进行样式的绑定 相当于是vue中的 v-bind 123456789101112131415161718## 为什么使用jsx语法&gt; jsx语法允许html和js的混写, 使页面数据和样式的操作变得钢架简单**核心**- 遇到 `HTML` 标签（以 `&lt;` 开头），就用 `HTML` 规则解析；- 遇到 以 `&#123;` 开头的结构，就用 `js` 规则解析；## 如何使用jsx语法### 标签渲染**遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；** &lt;!DOCTYPE html&gt; Hello World // ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( Hello, world!, document.getElementById(‘root’) ); // 如果{} 渲染的变量是一个数组,jsx语法会解析里面的所有成员并添加到模板 var arr = [ Hello world!, React is awesome ]; ReactDOM.render( {arr}, document.getElementById(‘example’) ) 1234### 代码注释&gt; 在jsx语法中, 标签中写代码注释需要放到&#123;&#125; 中&lt;!DOCTYPE html&gt; Hello World // ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( /注释/ Hello, world! {/注释要加上{} 要不然直接解析成文本/} , document.getElementById(‘root’) ); var i=1; ReactDOM.render( {/*如果是多个标签,推荐使用div包裹*/} react jsx的使用 {/*支持使用js表达式*/} {1+1} {/*不能使用if else 语句,可以使用三元表达式代替*/} {i == 1 ? 'True!' : 'False'} , document.getElementById('example') ); 12### 属性值的绑定 v-bind : &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; var obj = { id:1 } // 属性值的绑定 ReactDOM.render( test, document.getElementById(\"root\") ) 1234### 注意事项**模板部分不能有多个根节点** Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; var obj = { id:1, img:\"./img/01.jpg\" } // 属性值的绑定 ReactDOM.render( , document.getElementById(\"root\") ) 12345678### 事件处理 v-on @&gt; 在react中的事件处理和dom操作类似,但是有一点细微的区别**注意事项:** 1. React 事件使用驼峰命名，而不是全部小写 2. 通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串 12#### dom事件绑定 click me function fn(){ alert(1) } 12#### react事件绑定 Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建元素 var element = ( &lt;button onClick={fn}&gt;click me&lt;/button&gt; ) function fn(){ alert(1) } // 使用render渲染已创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 123#### react的html和js混写 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建元素 var element = ( &lt;button onClick={fn}&gt;click me&lt;/button&gt; ) function fn(){ alert(1) } // 使用render渲染已创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 12#### 事件参数传递 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建元素 绑定事件, 添加事件处理函数 var element = ( &lt;button onClick={ function(e){ console.log(e.target) } }&gt;click me&lt;/button&gt; ) // 使用render渲染已创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 12345### 条件渲染 v-if&gt; 在jsx语法中,使用三元表达式可以实现这一项功能 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; ReactDOM.render( { Math.random()*10>5?这是内容1:这是内容2 } , document.getElementById('root') ); 1234### 列表渲染 v-for&gt; 在jsx语法中, 使用map函数完成这一项功能 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--提供react的dom操作的相关功能--&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;!--jsx语法 支持标签和js的混写--&gt; &lt;script type=&quot;text/babel&quot;&gt; var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; ReactDOM.render( &lt;div&gt; { names.map(function(ele,index,arr){ /*Each child in an array or iterator should have a unique &quot;key&quot; prop.*/ return &lt;h1&gt;{ele}&lt;/h1&gt; }) } &lt;/div&gt;, document.getElementById(&apos;example&apos;) ) &lt;/script&gt; &lt;/body&gt; 123456## jsx深入理解### jsx语法的基本实现 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; //内联样式 var myStyle = { color:\"red\" } // 使用jsx语法创建模板 const element1 = ( Hello, world! ); ReactDOM.render( element1, document.getElementById('root') ); 1234### React.createElement()**从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖** Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; // 使用对象表示 法 // 从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖 const element2 = React.createElement( 'div', {className:\"greeting\"}, '哈哈' ) // 类似于这样一种简化的结构 const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, world' } }; ReactDOM.render( element2, document.getElementById('root') ); 12345678## react数据变化检测--元素渲染&gt; 元素(Elements)是 React 应用中最小的构建部件（或者说构建块，building blocks）。&gt; &gt; &gt; &gt; 元素用于描述你在页面上看到的内容### 页面的基本渲染 Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; // 创建元素 var element = Hello, world! //使用render 渲染函数渲染已创建的元素到指定的位置 ReactDOM.render( element, document.getElementById('root') ); 123456### 元素的更新**在React中,元素是不能发生突变的,要进行元素的,一旦创建了元素,就不能修改其子元素或者是相关的属性****元素更新的措施是: 创建一个新的元素并使用render函数重新渲染** Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; function tick() { // 创建元素 const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); //使用render函数进行页面的渲染 ReactDOM.render( element, document.getElementById('root') ); } setInterval(tick, 1000); 12345678910111213### 页面变化检测与更新的实现原理- react维护两个状态——现在的页面DOM、即将要渲染的页面DOM（数据) 两部分进行对比：自动渲染不同部分。- 每次发生事件、动画，都会和之前的状态进行对比。 - 相同：不再次进行渲染。 - 不同：进行渲染界面。 - 适合大量数据操作的框架——react。参考链接 https://zhuanlan.zhihu.com/purerender/2034637 在react中,当元素发生变化的时候,并不会进行所有的元素的更新, 在react内部,执行了一个diff 算法,只对当前变化的节点进行检测更新,而不是更新所有的节点 在react中,使用diff + virtual dom 结合的方式,实现元素的变化检测与更新 `","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"02-jsx语法","slug":"react/02-jsx语法","permalink":"http://yoursite.com/categories/react/02-jsx语法/"}],"tags":[]},{"title":"react入门","slug":"react/01-react入门/01-react入门","date":"2018-05-08T00:22:57.839Z","updated":"2018-05-08T00:42:47.547Z","comments":true,"path":"2018/05/08/react/01-react入门/01-react入门/","link":"","permalink":"http://yoursite.com/2018/05/08/react/01-react入门/01-react入门/","excerpt":"","text":"react入门– 案例驱动—示例 react是什么 React 是一个用于构建用户界面的 JAVASCRIPT 库。 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 起源 React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站 描述12345678由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单这个项目本身也越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案。衍生的 React Native 项目，目标更是宏伟，希望用写 Web App 的方式去写 Native App。如果能够实现，整个互联网行业都会被颠覆，因为同一组人只需要写一次 UI ，就能同时运行在服务器、浏览器和手机 为什么使用reactreact的特点12345671.声明式设计 −React采用声明范式，可以轻松描述应用。2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3.灵活 −React可以与已知的库或框架很好地配合。4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 以下描述仅仅是个人理解 单向数据流12在React中，数据的流向是单向的——从父节点传递到子节点，因为组件是简单而且易于把握的，他们只需从父节点获取props渲染即可，如果顶层组件的某个prop改变饿了，React会递归的向下便利整棵组件树，重新渲染所有使用这个属性的组件。 声明式设计12345678910111213141516171819202122232425262728// 声明式const element1 = React.createElement( &apos;div&apos;, &#123;className:&quot;greeting&quot;&#125;, &apos;哈哈&apos;)// 过程式element2 = document.createElement &apos;div&apos;element2.className = &apos;greeting&apos;element2.innerHTML = &apos;哈哈&apos;// 类似于这样一种简化的结构const element = &#123; type: &apos;h1&apos;, props: &#123; className: &apos;greeting&apos;, children: &apos;Hello, world&apos; &#125;&#125;;ReactDOM.render( element1, document.getElementById(&apos;root&apos;) ); 组件 两大特性 封装 重用 优势虚拟dom 虚拟dom 用于性能的提升 组件化 组件化 , 实现代码的重用 如何使用react hello world 示例 hello world示例js核心库 react的使用离不开三个核心的库 1234567891011// 新版本 &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt;// 久版本 &lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react-dom.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js&quot;&gt;&lt;/script&gt; hello world示例 最小化的 HTML 模板 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;!-- &lt;script&gt; 标签的 type 属性为 text/babel 。 这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。 凡是使用 JSX 的地方，都要加上 type=&quot;text/babel&quot; 。 --&gt; &lt;script type=&quot;text/babel&quot;&gt; // ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- -&gt; CDNReact 和 ReactDOM 的UMD版本可通过 CDN 获得。 开发环境12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 生产环境 相比开发环境进行了压缩和优化 12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.production.min.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; crossorigin如果你从 CDN 引用 React，我们建议保留 crossorigin 属性设置：","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"01-react入门","slug":"react/01-react入门","permalink":"http://yoursite.com/categories/react/01-react入门/"}],"tags":[]},{"title":"react优质学习资源","slug":"react/00-学习资料参考/00-学习资料参考","date":"2018-05-08T00:22:57.823Z","updated":"2018-05-08T00:38:56.423Z","comments":true,"path":"2018/05/08/react/00-学习资料参考/00-学习资料参考/","link":"","permalink":"http://yoursite.com/2018/05/08/react/00-学习资料参考/00-学习资料参考/","excerpt":"","text":"react优质学习资源官方文档fetchfetch CDN https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetchfetch CDN https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API react基本知识点react中文文档 http://www.css88.com/react/docs/portals.html react英文文档 https://reactjs.org/docs/react-api.html react中文网 http://www.reactchina.cn/ react生命周期 https://facebook.github.io/react/docs/react-component.html reduxredux中文文档 http://www.redux.org.cn/docs/react-redux/api.html react路由react路由的官方文档 https://react-guide.github.io/react-router-cn/docs/API.html react web http://reacttraining.cn react v4 中文文档 http://reacttraining.cn/web/guides/quick-start react-router http://reacttraining.cn/web/example/basic 文档博客书籍类阮一峰 也许dom不是答案 http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html react入门实例教程 http://www.ruanyifeng.com/blog/2015/03/react 开源项目类基于webpack、react、react-router 4.0、antd-m的App项目 https://github.com/liwudi/online-educationApp react-native https://github.com/liwudi/qingqi-auto-owner-app.git react https://github.com/liwudi/online-educationApp.git 视频类大众点评项目实战 https://coding.imooc.com/class/package/99.html#Anchor","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"00-学习资料参考","slug":"react/00-学习资料参考","permalink":"http://yoursite.com/categories/react/00-学习资料参考/"}],"tags":[]},{"title":"介绍","slug":"hello-world","date":"2018-05-07T22:30:03.040Z","updated":"2018-05-08T00:58:03.617Z","comments":true,"path":"2018/05/08/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/08/hello-world/","excerpt":"","text":"独白 我只是一小白","categories":[],"tags":[]}]}