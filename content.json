{"meta":{"title":"GaoHui","subtitle":"Note","description":"Note","author":"GaoHui","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2018-05-07T22:37:51.189Z","updated":"2018-05-07T22:37:51.189Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-05-07T22:37:51.180Z","updated":"2018-05-07T22:37:51.180Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-07T22:37:51.204Z","updated":"2018-05-07T22:37:51.204Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"03-vue指令","slug":"vue/03-directive","date":"2018-05-10T01:32:34.951Z","updated":"2018-05-10T01:33:22.032Z","comments":true,"path":"2018/05/10/vue/03-directive/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/03-directive/","excerpt":"","text":"第三部分 指令内置指令总结v-bind 可以绑定属性,包括class style,而已省略,使用:替代 在1vue.0中有三种修饰符,.sync,.once,.camel,在2.0中能够废弃了前面两个 .camel将绑定的特性的名称转化为驼峰法则命名 v-model 随着表单控件的不同而有所不同 可以添加修饰符 1.lazy .number .trim v-if v-else-if v-else v-show 可以配合模板使用 v-if和v-show两者都可以实现元素的状态切换,但是两者存在一些区别 v-if根据判断条件决定是否渲染,如果条件为假,不进行任何操作 v-show无论如何都会进行模块的渲染,只是简单的基于css 的切换 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 v-for 可以配合模板使用,也可以单独进行列表和表格的渲染 v-on 进行事件的绑定,可以省略,使用@替代 1234567类似于原生js的事件绑定的方式1. 获取dom元素2. 进行事件的添加3. 添加事件处理函数 v-text 绑定文本 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!--上下两种书写形式的 效果是一样的--&gt; &lt;p v-text=&quot;message&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var viewModel = &#123; //模型数据的初始化 message: &apos;hello world!&apos; &#125; // viewModel 连接模型和数据库 var vm= new Vue(&#123; el:&apos;#app&apos;, data:viewModel &#125;)&lt;/script&gt; v-html 绑定html标签 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!--上下两种书写形式的 效果是一样的--&gt; &lt;p v-text=&quot;message&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var viewModel = &#123; //模型数据的初始化 message: &apos;hello world!&apos; &#125; // viewModel 连接模型和数据库 var vm= new Vue(&#123; el:&apos;#app&apos;, data:viewModel &#125;)&lt;/script&gt; v-once 不需要表达式 只绑定一次,数据修改时,模型上面的数据不会再动态渲染到页面上 2.0版本新增 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;message&quot; id=&quot;&quot; value=&quot;&quot; /&gt; &lt;h2 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; v-pre 不需要表达式 跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 v-cloak 这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; [v-cloak] &#123; display: none; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;div v-cloak&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 这段 CSS 的含义是，包含 v-cloak (cloak n. 披风，斗篷；vt. 遮盖，掩盖) 属性的 html 标签在页面初始化时会被隐藏。在 vuejs instance ready 之后，v-cloak 属性会被自动去除，也就是对应的标签会变为可见 --&gt;&lt;script&gt; var dataModel = &#123; //模型数据的初始化 message: &apos;hello world!&apos;, &#125; // viewModel 连接模型和数据库 var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; 自定义指令 除了内置指令，Vue.js 也允许注册自定义指令。自定义指令提供一种机制将数据的变化映射为 DOM 行为。可以用 Vue.directive(id, definition) 方法注册一个全局自定义指令，它接收两个参数指令 ID 与定义对象。 也可以用组件的 directives 选项注册一个局部自定义指令。 全局自定义指令1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //注册一个全局自动以的指令 v-focus Vue.directive(&apos;focus&apos;, &#123; //绑定的元素插入到父节点时调用 inserted: function(el) &#123; //聚焦元素 el.focus() &#125; &#125;) //创建vue的实例 var vm = new Vue(&#123; el: &quot;#app&quot; &#125;)&lt;/script&gt; 局部自定义指令123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; // 创建根实例 new Vue(&#123; el: &apos;#app&apos;, directives: &#123; // 注册一个局部的自定义指令 v-focus focus: &#123; // 指令的定义,当指定的元素绑定到父元素时调用 inserted: function(el) &#123; // 聚焦元素 el.focus() &#125; &#125; &#125; &#125;)&lt;/script&gt; 钩子函数及其参数指令定义函数提供了几个钩子函数（可选）： 1234567891.0版本中的钩子函数 bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新 unbind: 只调用一次， 指令与元素解绑时调用。2.0新增的钩子函数 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 接下来我们来看一下钩子函数的参数 :(包括 el，binding，vnode，oldVnode) el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=&quot;1 + 1&quot;, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=&quot;1 + 1&quot; ， expression 的值是 &quot;1 + 1&quot;。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 &quot;foo&quot;。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 钩子函数 五个钩子函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--视图--&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&apos;message&apos;&gt; &lt;input type=&quot;text&quot; v-my-directive=&quot;message&quot; v-model=&apos;message&apos; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //指令名称 有了指令 能干什么 Vue.directive(&apos;my-directive&apos;, &#123; //第一次绑定的时候调用 只调用一次 bind: function(el, binding, vnode, oldnode) &#123; console.log(&apos;bind &apos;, arguments) &#125;, //被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） inserted: function(el) &#123; console.log(&quot;inserted&quot;) &#125;, //更新的时候调用 update: function() &#123; console.log(&apos;updata&apos;) &#125;, //解绑定的时候调用 unbind: function() &#123; console.log(&apos;unbind &apos;, arguments) &#125;, //组件完成一个周期调用 componentUpdated: function() &#123; console.log(&quot;componentUpdated&quot;) &#125; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &quot;hello&quot; &#125; &#125;) vm.$data.message = 1000;&lt;/script&gt; 钩子函数的参数和binding参数的属性 钩子函数的四个参数和binding参数的六个个属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--视图--&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&apos;message&apos;&gt; &lt;input type=&quot;text&quot; v-my-directive=&quot;message&quot; v-model=&apos;message&apos; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //指令名称 有了指令 能干什么 五个钩子函数 Vue.directive(&apos;my-directive&apos;, &#123; //第一次绑定的时候调用 只调用一次 bind: function(el, binding, vnode, oldnode) &#123; console.log(&apos;bind &apos;, arguments) &#125;, //被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） inserted: function(el) &#123; console.log(&quot;inserted&quot;) &#125;, //更新的时候调用 update: function() &#123; console.log(&apos;updata&apos;) &#125;, //解绑定的时候调用 unbind: function() &#123; console.log(&apos;unbind &apos;, arguments) &#125;, //组件完成一个周期调用 componentUpdated: function() &#123; console.log(&quot;componentUpdated&quot;) &#125; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &quot;hello&quot; &#125; &#125;) vm.message = 1000;&lt;/script&gt; 补充自定义指令子简写 大多数情况下，我们可能想在 bind 和 update 钩子上做重复动作，并且不想关心其它的钩子函数 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-color-swatch=&quot;&#123; color: &apos;green&apos;, text: &apos;菜鸟教程!&apos; &#125;&quot;&gt; test &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //大多数情况下，我们可能想在 bind 和 update 钩子上做重复动作，并且不想关心其它的钩子函数。可以这样写: Vue.directive(&apos;color-swatch&apos;, function(el, binding) &#123; //el: 可以直接通过el操作dom el.style.backgroundColor = binding.value.color; &#125;) new Vue(&#123; el: &apos;#app&apos; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 自定义指令之对象字面量 如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法类型的 JavaScript 表达式。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!--自定义指令--&gt; &lt;div v-runoob=&quot;&#123; color: &apos;green&apos;, text: &apos;菜鸟教程!&apos; &#125;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; Vue.directive(&apos;runoob&apos;, function(el, binding) &#123; //el: 可以直接通过el操作dom el.innerHTML = binding.value.text; el.style.backgroundColor = binding.value.color; &#125;) var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; 指令的高级选项(了解) 该部分在2.0中已经不做详细的讲解 vue2.0中的变化变化主要体现在以下两个方面 钩子函数123451.0中 bind：只调用一次，在指令第一次绑定到元素上时调用。 update： 在 bind 之后立即以初始值为参数第一次调用，之后每当绑定值变化时调用，参数为新值与旧值。 unbind：只调用一次，在指令从元素上解绑时调用。 函数的参数/实例属性123456789101.0中 所有的钩子函数将被复制到实际的指令对象中，钩子内 this 指向这个指令对象。这个对象暴露了一些有用的属性： el: 指令绑定的元素。 vm: 拥有该指令的上下文 ViewModel。 expression: 指令的表达式，不包括参数和过滤器。 arg: 指令的参数。 name: 指令的名字，不包含前缀。 modifiers: 一个对象，包含指令的修饰符。 descriptor: 一个对象，包含指令的解析结果。","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]},{"title":"02-vue基础","slug":"vue/02-base1","date":"2018-05-10T01:32:34.949Z","updated":"2018-05-10T01:33:12.903Z","comments":true,"path":"2018/05/10/vue/02-base1/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/02-base1/","excerpt":"","text":"第二部分 vue的基础特性(上) 在这一章我们主要是讲解一些vue实例的属性和一些基础的指令 vue实例属性:其实和我们之前所学的对象的属性是相似的东西 vue的基础指令: 对于指令,大家可能之前么有接触过相关的概念,其实大家可以这样理解 指令:可以看做是命令,在vue中我们可以通过指令来完成相关的操作 指令: 在vue中以v-开头,后面紧跟具体的操作命令 一些基本的指令,具体的用法下面会进行介绍 12345678910v-once: 只绑定一次v-bind: 绑定数据v-model: 绑定模型v-on: 绑定事件v-if v-show: 条件渲染 实例和选项 也就是vue实例化后的对象的一些属性相关的内容 123el data methods$el $data $mount 代理/数据 我们之前提到过,vue是mvvm模型,其中的m指的是数据模型,在这里我们对数据模型这一块做一个简单的讲解 vue的代理/数据 每个vue的实例都会代理其data对象中的所有的属性 通过vue的实例,可以直接访问data对象中属性 通过vue的实例,可以设置data对象里面的内容,设置属性也会影响到原始的数据 在代理中存在的问题 在实例创建之后添加新的属性到实例上,不会触发视图的更新 关于这一部分的内容在响应系统中再做详细的讲解 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;) //直接访问 console.log(vm.message)//hello world //设置属性也会影响到数据 vm.message = 10; console.log(dataModel.message)//10 //在vue实例创建之后,再添加新的属性到实例上,不会触发视图的更新 vm.a = 100; console.log(dataModel.a)//undefined&lt;/script&gt; vue 的 $ Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的数据属性区分 了解 : $set 的使用存在一些问题,在vue2.0中作了简单修改 对于 Vue 实例，可以使用 $set(key, value) 实例方法：这样使用会报错,以下两种方式是可以使用的(存在疑问) Vue.set(object, key, value) this.$set(this.someObject,’b’,2) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;ul&gt; &lt;li v-for=&apos;item in arr&apos;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; arr : [1,2,3] &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;) //读取值 console.log(vm.arr) console.log(vm.$data.arr) //设置值----存在的问题,当数组里面的值使用下标的形式修改的时候,视图和模型数据不会动态更新 vm.arr[0]=4; //使用set方法设置的值,可以动态更新到模型数据和视图上 Vue.set(vm.arr,0,100) //使用vue的实例暴露出来的属性和方法进行操作 vm.$set(vm.arr,1,200)&lt;/script&gt; 方法 使用methods来定义方法,使用v-on监听事件,绑定事件处理函数 1234567关于事件处理这一块,在这里做一点补充1. 在vue1中,支持自定义事件,vue2中废弃了2. vue2中推荐使用全局的$on和$emit来进行全局的方法的定义和触发3. vue2中,也可以使用插件vuex来处理 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里使用v-on来绑定事件处理的方法(函数)--&gt; &lt;button v-on:click=&apos;fn&apos;&gt;click&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel, //在这里使用methods对象来定义方法(点击事件处理函数) methods:&#123; fn: function()&#123; console.log(&quot;这个方法被调用了&quot;) &#125; &#125; &#125;)&lt;/script&gt; 生命周期简介 vue在创建的时候会有一系列初始化的步骤 实例需要配置数据监测(data observe),模板编译,挂载到dom,然后在变化时更新dom 实例也会调用一些生命周期钩子,为我们提供了自定义逻辑的机会 所有的生命周期钩子自动绑定this上下文到实例中,箭头函数绑定 生命周期钩子函数 其实指的也就是生命周期方法,只不过是挂载到执行的各个阶段,所以叫钩子函数 演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue入门之生命周期&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; name=&quot;btnSetNumber&quot; v-model=&quot;number&quot;&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; number: 1 &#125;, //在创建对象之前,监控数据变化和初始化事件之前调用 beforeCreate: function() &#123; console.log(&apos;beforeCreate 钩子执行...&apos;); console.log(this.number) //数据监测还没有开始 &#125;, //实例创建完成之后调用,挂载阶段还没有开始 created: function() &#123; console.log(&apos;cteated 钩子执行...&apos;); console.log(this.number) &#125;, //开始挂载的时候执行,这时html还没有渲染到页面上 beforeMount: function() &#123; console.log(&apos;beforeMount 钩子执行...&apos;); console.log(this.number) &#125;, //挂载完成,也就是模板中的heml渲染到了页面中,此时可以做一些ajax的操作,这个钩子函数只会执行一次 mounted: function() &#123; console.log(&apos;mounted 钩子执行...&apos;); console.log(this.number) &#125;, //数据更新之前调用 beforeUpdate: function() &#123; console.log(&apos;beforeUpdate 钩子执行...&apos;); console.log(this.number) &#125;, //数据更新之后调用 updated: function() &#123; console.log(&apos;updated 钩子执行...&apos;); console.log(this.number) &#125;, //数据销毁之前 beforeDestroy: function() &#123; console.log(&apos;beforeDestroy 钩子执行...&apos;); console.log(this.number) &#125;, //数据销毁之后 destroyed: function() &#123; console.log(&apos;destroyed 钩子执行...&apos;); console.log(this.number) &#125;, &#125;); //实现数据的更新 // vm.$set(dataModel, &apos;number&apos;, 123) //销毁钩子的执行 // vm.$destroy(true) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 补充 在vue2.0之后 , 也就是后续的版本中, 生命周期钩子已经发生的变化 , 在原先的基础上新增了两个生命周期钩子函数 1.activated keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。 2.deactivated keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。 数据绑定 vue的核心特性之一是双向的数据绑定,关于如何进行数据的绑定,下面我们结合具体的例子来作讲解 数据绑定的语法文本插值 直接填坑,进行数据的绑定 v-once:只绑定一次,首次赋值后更改vm实例的属性值不会引起dom元素绑定的值的变化 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;message&quot; id=&quot;&quot; value=&quot;&quot; /&gt; &lt;h2 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; html属性的绑定 v-bind: 为html标签绑定属性值 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;div v-bind:id=&quot;mainID&quot; v-html=&quot;main&quot;&gt; &lt;/div&gt; &lt;img v-bind:src=&quot;imgUrl&quot;/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 绑定属性 v-bind:prop_name=&quot;prop_value&quot; 输出html v-html=&quot;content&quot; 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。 --&gt;&lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data:&#123; message:&quot;hello world&quot;, mainID:&quot;dv&quot;, main:&quot;&lt;p&gt;这是v-html绑定的内容&lt;/p&gt;&quot;, imgUrl:&apos;http://img2.imgtn.bdimg.com/it/u=2204211808,2775991232&amp;fm=23&amp;gp=0.jpg&apos; &#125; &#125;)&lt;/script&gt; 绑定表达式 一段绑定表达式可以由一个简单的js表达式和可选的一个或多个过滤器组成 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--字符串拼接--&gt; &lt;p&gt;&#123;&#123; message + &quot;----&quot; + name &#125;&#125;&lt;/p&gt; &lt;!--三元运算符--&gt; &lt;p&gt;&#123;&#123; bool ? 1 : 0 &#125;&#125;&lt;/p&gt; &lt;!--四则运算--&gt; &lt;p&gt;&#123;&#123; num * 2 &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 使用的限制是只能包含单个表达式--&gt;&lt;script&gt; //创建Vue对象 var app =new Vue (&#123; el:&apos;#app&apos;,//将Vue对象绑定到指定的选择器 data:&#123; message: &apos;hello world &apos;, name:&apos;高辉&apos;, bool: true, num:10 &#125; &#125;)&lt;/script&gt; 表单控件 vue中使用v-model指令对表单元素进行双向的数据绑定 text 绑定的值就是value值 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&apos;message&apos; /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; textarea 绑定的值也是value值 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;p&gt;multiline message is&lt;/p&gt; &lt;p style=&quot;white-space: pre&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;textarea v-model=&quot;message&quot; placeholder=&quot;mulpiline message&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; radio 绑定的值就是选中单选框的value值 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; value=&quot;male&quot; v-model=&apos;gender&apos; /&gt;男 &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; value=&quot;female&quot; v-model=&apos;gender&apos; /&gt;女 &lt;/label&gt; &lt;p&gt;&#123;&#123;gender&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos;, gender:&quot;male&quot; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; checkbox - 1 单选: 绑定的值是bool值,决定是否选中 多选: 绑定的值是一个数组类型,value值为数组里面的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;h2&gt;&#123;&#123; message1 &#125;&#125;&lt;/h2&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked1&quot; /&gt; &lt;h2&gt;&#123;&#123;message2&#125;&#125;&lt;/h2&gt; &lt;br /&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked2&quot; value=&quot;1&quot; /&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;hr /&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked2&quot; value=&quot;2&quot; /&gt; &lt;label for=&quot;jack&quot;&gt;rose&lt;/label&gt; &lt;hr /&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked2&quot; value=&quot;3&quot; /&gt; &lt;label for=&quot;jack&quot;&gt;mack&lt;/label&gt; &lt;hr /&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked2&quot; value=&quot;4&quot; /&gt; &lt;label for=&quot;jack&quot;&gt;july&lt;/label&gt; &lt;hr /&gt; &lt;label for=&quot;checkbox&quot;&gt;&#123;&#123;checked&#125;&#125;&lt;/label&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message1: &apos;单选&apos;, message2: &apos;多选&apos;, checked1: false, checked2:[1,2] &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; checkedbox - 212345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt; &lt;p&gt;&#123;&#123; picked &#125;&#125;&lt;/p&gt; &lt;hr/&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt; &lt;p&gt;&#123;&#123; toggle &#125;&#125;&lt;/p&gt; &lt;hr/&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt; &lt;/select&gt; &lt;hr/&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; picked: &apos;&apos;, toggle: true, selected: &apos;abc&apos;, a: &apos;1&apos;, b: &apos;2&apos; &#125; var em = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; select 单选: 根据option的value值设置选中 多选: 根据value值的数组设置选中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;单选&lt;/h2&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;/select&gt; &lt;p&gt;单选选中项是: &#123;&#123;selected&#125;&#125;&lt;/p&gt; &lt;h2&gt;多选&lt;/h2&gt; &lt;select v-model=&quot;selecteds&quot; multiple&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;/select&gt; &lt;p&gt;多选选中项是: &#123;&#123;selecteds&#125;&#125;&lt;/p&gt; &lt;h2&gt;动态的select--循环渲染-设置单选&lt;/h2&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123;option.text&#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;p&gt;多选选中项是: &#123;&#123;selecteds&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message1: &apos;单选&apos;, message2: &apos;多选&apos;, selected: &apos;B&apos;, selecteds: [&apos;A&apos;, &apos;B&apos;], options: [&#123; text: &apos;One&apos;, value: &apos;A&apos; &#125;, &#123; text: &apos;Two&apos;, value: &apos;B&apos; &#125;, &#123; text: &apos;Three&apos;, value: &apos;C&apos; &#125;] &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; 绑定value 对于单选按钮，勾选框及选择列表选项， v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值） 复选框 选择列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--对于单选按钮，勾选框及选择列表选项， v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：--&gt; &lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt; &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt; &lt;!-- `toggle` 为 true 或 false --&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt; &lt;!-- 当选中时，`selected` 为字符串 &quot;abc&quot; --&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt; &lt;/select&gt; &lt;!--复选框--&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt; &lt;!--选择列表--&gt; &lt;select v-model=&quot;selected1&quot;&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; picked: &apos;a&apos;, toggle: true, selected: &apos;abc&apos;, a: true, b: false, selected1: &#123; number: 123 &#125; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;) // 选中 console.log(vm.toggle === vm.a) //true // 取消选中 console.log(vm.toggle === vm.b) //false // 选择列表的设置 console.log(vm.selected1) console.log(vm.selected1.number)&lt;/script&gt; 修饰符.lazy 在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分) 但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&apos;message&apos; /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 禁用数据的双向绑定 --&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; .number 如果想自动将用户的输入值转为 Number 类型 如果原值的转换结果为 NaN 则返回原值 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model.number=&apos;message&apos; /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 用户输入的数据可以转化W为number类型 进行输入的转化 不能转化问number类型(NaN),会保持当前的输入 --&gt;&lt;script&gt; var dataModel = &#123; message: &apos;11&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; .trim 过滤用户输入的首尾空格 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model.trim=&apos;message&apos; /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--过滤用户输入的首尾空格--&gt;&lt;script&gt; var dataModel = &#123; message: &apos;&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; class 与 styleclass的绑定 对象语法 数组语法 style的绑定 对象语法 使用对象的形式绑定样式 数组语法 绑定多个对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .active &#123; background: pink; width: 200px; height: 200px; float: left; margin-left: 30px; &#125; .bd &#123; border: 1px solid red; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--绑定单个类样式--&gt; &lt;div v-bind:class=&quot;&#123;active:isActive&#125;&quot;&gt;&lt;/div&gt; &lt;!--绑定多个类样式--&gt; &lt;div v-bind:class=&quot;&#123;active:isActive,bd:hasBorder&#125;&quot;&gt;&lt;/div&gt; &lt;!--使用对象的方式绑定类样式--&gt; &lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; &lt;!--使用数组绑定--&gt; &lt;div v-bind:class=&quot;[classA,classB]&quot;&gt;&lt;/div&gt; &lt;!--三元表达式--&gt; &lt;div v-bind:class=&quot;[classA, isB ? classB : &apos;&apos;]&quot;&gt;&lt;/div&gt; &lt;!--内联样式的绑定--&gt; &lt;div v-bind:style=&quot;&#123;fontSize: size + &apos;px&apos;, backgroundColor: bgcolor, width: width&#125;&quot;&gt; vue 内联样式的绑定 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 样式的绑定 1. v-bind:class=&quot;&#123;active:isActive&#125; 当绑定的数据isActive的值为true时,就会为该元素添加类样式 2. v-bind:class=&quot;&#123;active:isActive,bd:hasBorder&#125;&quot; 支持混合类样式绑定,即同时绑定多个类样式 3. v-bind:class=&quot;classObject&quot; 支持使用对象绑定类样式 4. v-bind:class=&quot;[classA,classB]&quot; 5. &lt;div v-bind:class=&quot;[classA, isB ? classB : &apos;&apos;]&quot;&gt; 当 v-bind:style 使用需要厂商前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 --&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isActive: true, hasBorder: true, classObject: &#123; active: true, bd: true &#125;, //内联样式 size: 19, width: 200, bgcolor: &apos;red&apos;, //数组形式 classA: &quot;a&quot;, classB: &apos;b&apos;, isB: true &#125; &#125;)&lt;/script&gt; 模板渲染条件渲染 v-if v-else-if v-else v-show 支持模板语法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!--这里 v-if 指令将根据表达式 greeting 值的真假删除/插入 &lt;p&gt; 元素。--&gt; &lt;p v-if=&quot;greeting&quot;&gt;Hello!&lt;/p&gt; &lt;!--bool值可以使条件表达式--&gt; &lt;p v-if=&quot;Math.random()&gt;0.5&quot;&gt;根据随机值判断是否显示&lt;/p&gt; &lt;!--使用v-if配合template可以实现模板渲染--&gt; &lt;template v-if=&apos;bool&apos;&gt; &lt;h1&gt;&#123;&#123;header&#125;&#125;&lt;/h1&gt; &lt;p&gt;&#123;&#123;paragraph&#125;&#125; 1&lt;/p&gt; &lt;p&gt;&#123;&#123;paragraph&#125;&#125; 2&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;data in array&quot;&gt;&#123;&#123;data&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var viewModel = &#123; //模型数据的初始化 message: &apos;hello world!&apos;, greeting:true, bool:true, header:&quot;这是一个标题&quot;, paragraph:&quot;这是一个段落&quot;, array:[1,2,3,4] &#125; // viewModel 连接模型和数据库 var vm = new Vue(&#123; el: &apos;#app&apos;, data: viewModel, &#125;)&lt;/script&gt; 列表渲染 v-for 支持模板语法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--view--&gt; &lt;ul&gt; &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt; &lt;/ul&gt; &lt;ul&gt; &lt;!--简单的列表渲染--&gt; &lt;li v-for=&apos;data in liData1&apos;&gt; &#123;&#123;data&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;!--复杂的列表渲染--&gt; &lt;li v-for=&apos;data in liData2&apos;&gt; &#123;&#123;data.text&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;!--添加index--&gt; &lt;li v-for=&quot;(data,index) in liData2&quot;&gt; &#123;&#123;data.text&#125;&#125;=======index====&#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!--模板语法--&gt; &lt;ul&gt; &lt;h2&gt;模板渲染&lt;/h2&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&#123;&#123;item.age&#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; // model var dataModel = &#123; num: 10, liData1: [1, 2, 3], liData2: [&#123; text: &quot;这是一段文本&quot; &#125;, &#123; text: &quot;这是一段文本&quot; &#125;, &#123; text: &quot;这是一段文本&quot; &#125;, &#123; text: &quot;这是一段文本&quot; &#125;], items: [&#123; name: 1, age: 1 &#125;, &#123; name: 2, age: 2 &#125;] &#125; // viewModel var app = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; template模板用法(简单了解) template标签用法 vue实例的 el 和 template 选项 配合使用,完成页面的渲染 组件/模板内部的元素一定要有一个根元素包裹 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--视图的入口--&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;script id=&quot;tp1&quot; type=&quot;x-template&quot;&gt; &lt;div class=&quot;tp1&quot;&gt; &lt;p&gt;this is a tp1 from script tag&lt;/p&gt; &lt;/div&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //在这里,将template对应的script内部的元素挂载到对应的el所指定的位置 var vm= new Vue(&#123; el:&apos;#app&apos;, template:&quot;#tp1&quot; &#125;)&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]},{"title":"01-vue入门","slug":"vue/01-vueStart","date":"2018-05-10T01:32:34.667Z","updated":"2018-05-10T01:33:01.100Z","comments":true,"path":"2018/05/10/vue/01-vueStart/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/01-vueStart/","excerpt":"","text":"第一部分: vue入门/简介嘻嘻嘻 vue的引入 先看下面这样一个简单的例子,实现了这样一个功能 数据的双向绑定:也就是数据的同步修改 12345逻辑分析: 1. 我们需要一个UI元素和属性相互绑定的方法 2. 我们需要监视属性和UI元素的变化 3. 我们需要让所有绑定的对象和元素都能感知到变化 vue与js的对比js的实现(了解)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h4&gt;数据的双向绑定----js的实现&lt;/h4&gt; &lt;input type=&quot;text&quot; data-bind-1=&quot;name&quot; /&gt; &lt;input type=&quot;text&quot; data-bind-1=&quot;name&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; function DataBinder(object_id) &#123; // Create a simple PubSub object var pubSub = &#123; callbacks: &#123;&#125;, on: function(msg, callback) &#123; this.callbacks[msg] = this.callbacks[msg] || []; this.callbacks[msg].push(callback); &#125;, publish: function(msg) &#123; this.callbacks[msg] = this.callbacks[msg] || []; for(var i = 0, len = this.callbacks[msg].length; i &lt; len; i++) &#123; this.callbacks[msg][i].apply(this, arguments); &#125; &#125; &#125;, data_attr = &quot;data-bind-&quot; + object_id, message = object_id + &quot;:input&quot;, timeIn; changeHandler = function(evt) &#123; var target = evt.target || evt.srcElement, // IE8 compatibility prop_name = target.getAttribute(data_attr); if(prop_name &amp;&amp; prop_name !== &quot;&quot;) &#123; clearTimeout(timeIn); timeIn = setTimeout(function() &#123; pubSub.publish(message, prop_name, target.value); &#125;, 50); &#125; &#125;; // Listen to change events and proxy to PubSub if(document.addEventListener) &#123; document.addEventListener(&quot;input&quot;, changeHandler, false); &#125; else &#123; // IE8 uses attachEvent instead of addEventListener document.attachEvent(&quot;oninput&quot;, changeHandler); &#125; // PubSub propagates changes to all bound elements pubSub.on(message, function(evt, prop_name, new_val) &#123; var elements = document.querySelectorAll(&quot;[&quot; + data_attr + &quot;=&quot; + prop_name + &quot;]&quot;), tag_name; for(var i = 0, len = elements.length; i &lt; len; i++) &#123; tag_name = elements[i].tagName.toLowerCase(); if(tag_name === &quot;input&quot; || tag_name === &quot;textarea&quot; || tag_name === &quot;select&quot;) &#123; elements[i].value = new_val; &#125; else &#123; elements[i].innerHTML = new_val; &#125; &#125; &#125;); return pubSub; &#125; function DBind(uid) &#123; var binder = new DataBinder(uid), user = &#123; // ... attributes: &#123;&#125;, set: function(attr_name, val) &#123; this.attributes[attr_name] = val; // Use the `publish` method binder.publish(uid + &quot;:input&quot;, attr_name, val, this); &#125;, get: function(attr_name) &#123; return this.attributes[attr_name]; &#125;, _binder: binder &#125;; // Subscribe to the PubSub binder.on(uid + &quot;:input&quot;, function(evt, attr_name, new_val, initiator) &#123; if(initiator !== user) &#123; user.set(attr_name, new_val); &#125; &#125;); return user; &#125; var DBind = new DBind(1); DBind.set(&quot;name&quot;, &quot;黄奇&quot;);&lt;/script&gt; vue的实现1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--1. 引入js文件--&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--2. 视图 view--&gt; &lt;div id=&quot;app&quot;&gt; &lt;h4&gt;数据双向绑定----vue&lt;/h4&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;message&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;message&quot; /&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;//数据模型var dataModel = &#123; message: &quot;hello&quot;&#125;//viewModel ----连接视图和数据模型var app = new Vue(&#123; el: &quot;#app&quot;, data: dataModel&#125;)&lt;/script&gt; Vue是什么描述(vue的发展史) 概念123456vue是一个构建用户界面的框架(库),它的目标是通过尽可能简单的api实现响应的数据绑定和组合的视图集合vue自身不是一个全能框架的核心是只关注视图层,因此它非常容易学习，非常容易与其它库或已有项目整合vue在与相关工具和支持库一起使用时, 也能完美地驱动复杂的单页应用,在之后的课程中,我们会配合webpack来使用 特点响应的数据绑定/响应式编程 保持状态和数据的同步 1234567891011Vue.js 的核心是一个响应的数据绑定系统，它让数据与 DOM 保持同步非常简单。在使用 jQuery 手工操作 DOM时，我们的代码常常是命令式的、重复的与易错的。Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM“绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM更新搅在一起。这让我们的代码更容易撰写、理解与维护。 组件化123组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 为什么要用Vue.js优点轻量级的框架1只关注视图层,是一个构建数据驱动的视图集合,大小只有几十kb 简单易学1国人开发,中文文档,不存在语言障碍,易于理解与学习 双向数据绑定12保留了angular的优点在数据操作方面变得更为简单,极大的解放了dom操作(通过属性绑定的形式来实现) 组件化12保留了 react框架的优点实现html的封装,重用,在构建单页面应用方面有独特的优势 视图,数据,结构分离1使得数据的更改变得非常简单,不需要进行逻辑代码的修改,只需要操作数据就能够完成相关的操作 虚拟DOM12dom操作是非常耗费性能的不再使用原生的dom操作节点,极大解放dom操作,但具体操作的还是dom,只不过是换了另外一种方式 运行速度更快1相比较react而言,同样都是操作虚拟dom,就性能而言,vue存在很大的优势(了解) 缺点/了解支持特性 作为一个新兴的前端框架,在支持特性方面存在一些问题 123浏览器端: 抛弃了对IE9以下版本的支持android: 4.2 + ios: ios 7+ 前后端混合受限 在使用后端的 模板引擎渲染的项目中,vue会受到一定的限制 vue只能和后端的模板文件混合在一起,获取的后端数据也依赖于后端的渲染,在处理json对象和数组的时候会很麻烦 MVVM模式简介概述123456789大致可以分为三个部分:1. M: model,模型,在这里指的是数据模型2. V: view,视图,在这里指的就是我们写的页面3. VM ViewModel,是数据模型和视图连接的纽带(桥梁) 我们要把数据模型上面的数据绑定到视图上,要通过这个纽带(桥梁)来实现 图解 第一个vue案例vue的安装兼容1兼容性提示： Vue.js 不支持 IE8 及其以下版本。 版本12341. 开发版本: 包含完整的警告和调试2. 生产版本: 删除了警告 使用 使用本地的vue.js 存在的缺点 需要提前进行下载使用的时候受本地路径的限制,如果路径引入错误,会报错 也可以使用cdn加速服务,在有网络的情况下,直接引入12&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&gt; 存在的缺点 没有网络的时候没法使用 还有另外一种使用的方式,就是在项目模板中使用,关于这一部分内容,稍后进行讲解 实例12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue入门之Helloworld&lt;/title&gt; &lt;!--第1步：引入Vue库--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--第2步: 通过id属性设置视图的入口--&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--Vue的模板的绑定数据的方法， 类似于很多其他前端的模板，可以用两对花括号进行绑定Vue中的数据对象的属性 --&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;script&gt; //第3步：创建模型数据 var modelData = &#123; message: &apos;Hello Vue!&apos; &#125; //第4步: 创建vue对象 var app = new Vue(&#123; // 创建Vue对象。Vue的核心对象。 el: &apos;#app&apos;, // el属性：把当前Vue对象挂载到 div标签上，#app是id选择器 data: modelData// data: 是Vue对象中绑定的数据模型 &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]},{"title":"WebSocket","slug":"杂项/99-2-websocket","date":"2018-05-10T00:36:28.979Z","updated":"2018-05-10T01:06:30.397Z","comments":true,"path":"2018/05/10/杂项/99-2-websocket/","link":"","permalink":"http://yoursite.com/2018/05/10/杂项/99-2-websocket/","excerpt":"","text":"WebSocket详情查看链接","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[]},{"title":"跨域问题解决方案","slug":"杂项/99-1-cros-proxy-jsonp","date":"2018-05-10T00:36:28.970Z","updated":"2018-05-10T01:06:08.914Z","comments":true,"path":"2018/05/10/杂项/99-1-cros-proxy-jsonp/","link":"","permalink":"http://yoursite.com/2018/05/10/杂项/99-1-cros-proxy-jsonp/","excerpt":"","text":"跨域问题解决方案反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 基本使用1.在项目的根目录下创建一个proxy.config.json文件 内容如下: 12345&#123; &quot;**&quot;:&#123; &quot;target&quot;:&quot;http://127.0.0.1:8800&quot; &#125;&#125; 2.修改package.json文件 更改启动项 1ng serve --proxy-config proxy.config.json 3.配置根模块 12345import &#123;HttpModule&#125; from &quot;@angular/http&quot;imports: [ HttpModule] 4.使用http 三步操作 12345678910111213141. 导入http import &#123;Http&#125; from &quot;@angular/http&quot;2. 注入到构造函数 constructor(public http:Http) &#123;&#125;3. 调用方法 ngOnInit()&#123; var url = &quot;/test&quot; this.http.get(url) .subscribe((res)=&gt;&#123; console.log(res.json()) &#125;) &#125; 5.使用express框架,配置node服务,提供接口 123456789101112131415161718const express = require(&quot;express&quot;);const app = express();let dataSet = [ &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;pengsuo&quot;,&quot;age&quot;:20&#125;, &#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;chenqian&quot;,&quot;age&quot;:34&#125;, &#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;mahao&quot;,&quot;age&quot;:30&#125;, &#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;chenbo&quot;,&quot;age&quot;:50&#125;];app.get(&quot;/test&quot;,(req,res)=&gt;&#123; res.json(dataSet);&#125;);app.listen(8800)console.log(&quot;http://127.0.0.1:8800&quot;) jsonpangular的jsonp模块1.配置根模块 123456import &#123;JsonpModule&#125; from &quot;@angular/http&quot;imports: [ JsonpModule] 2.使用jsonp 三步操作 12345678910111213141. 导入jsonp import &#123;Jsonp&#125; from &quot;@angular/http&quot;2. 注入到构造函数 constructor(public jsonp:Jsonp) &#123;&#125;3. 调用方法 ngOnInit()&#123; var url = &quot;http://127.0.0.1:8800/test?callback=JSONP_CALLBACK&quot; this.jsonp.get(url) .subscribe((res)=&gt;&#123; console.log(res.json()) &#125;) &#125; 3.服务器端代码书写 基于nodejs的express框架 12345678910111213141516171819const express = require(&quot;express&quot;);const app = express();let dataSet = [ &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;pengsuo&quot;,&quot;age&quot;:20&#125;, &#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;chenqian&quot;,&quot;age&quot;:34&#125;, &#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;mahao&quot;,&quot;age&quot;:30&#125;, &#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;chenbo&quot;,&quot;age&quot;:50&#125;];app.get(&quot;/test&quot;,(req,res)=&gt;&#123; res.jsonp(dataSet);&#125;);app.listen(8800)console.log(&quot;http://127.0.0.1:8800&quot;) jquery的ajax跨域12345678910111213$.ajax(&#123; type: &quot;get&quot;, url: &quot;http://127.0.0.1:8800/test?callback=?&quot;, async: true, success(data) &#123; console.log(data) &#125;, error(error)&#123; console.log(error) &#125;, //jsonpCallback: &quot;fn&quot;, dataType: &quot;jsonp&quot;&#125;); cros 服务器端设置跨域资源共享 详情参考此链接 nodejs 基于express框架 123456789101112app.all(&apos;*&apos;, (req, res, next) =&gt; &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;); res.setHeader(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;); next()&#125;); php12header(&quot;Access-Control-Allow-Origin: *&quot;); WebSocket","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[]},{"title":"移动端布局","slug":"杂项/88-1-flex+rem","date":"2018-05-10T00:36:28.962Z","updated":"2018-05-10T01:06:05.052Z","comments":true,"path":"2018/05/10/杂项/88-1-flex+rem/","link":"","permalink":"http://yoursite.com/2018/05/10/杂项/88-1-flex+rem/","excerpt":"","text":"移动端布局 使用淘宝团队开发的适配方案 flexible 也就是手淘的H5多终端适配方案 flexible参考链接 使用的方式1.开启移动端布局1234// 设置meta&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; 2.引用多终端适配方案1234// 多终端适配&lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt; 3.设置像素转化 将设计稿上的px 像素单位转化为 css 的 rem 布局方案 也就是px和rem的转化比例 123456789设计稿: 750 -----&gt; 转化比例 75设计稿: 640 -----&gt; 转化比例 64 在hbuild中内置px转rem工具,如果找不到以下选项,建议更新hbuild版本 菜单栏----&gt; 工具 ----&gt; 选项 ----&gt; Hbuild ----&gt; 代码助手设置 ----&gt; 启动px转rem自动提示","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[]},{"title":"04-微信小程序组件","slug":"weChat/04-组件","date":"2018-05-10T00:36:28.951Z","updated":"2018-05-10T01:07:58.863Z","comments":true,"path":"2018/05/10/weChat/04-组件/","link":"","permalink":"http://yoursite.com/2018/05/10/weChat/04-组件/","excerpt":"","text":"微信小程序组件 框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。","categories":[{"name":"weChat","slug":"weChat","permalink":"http://yoursite.com/categories/weChat/"}],"tags":[]},{"title":"03-小程序开发实战","slug":"weChat/03-豆瓣电影的基本实现","date":"2018-05-10T00:36:28.942Z","updated":"2018-05-10T01:08:13.288Z","comments":true,"path":"2018/05/10/weChat/03-豆瓣电影的基本实现/","link":"","permalink":"http://yoursite.com/2018/05/10/weChat/03-豆瓣电影的基本实现/","excerpt":"","text":"小程序开发实战–豆瓣电影项目配置 在项目的app.json文件中完成配置 12 微信小程序访问豆瓣电影api400错误解决方法","categories":[{"name":"weChat","slug":"weChat","permalink":"http://yoursite.com/categories/weChat/"}],"tags":[]},{"title":"02-基础知识点","slug":"weChat/02-基本知识点","date":"2018-05-10T00:36:28.932Z","updated":"2018-05-10T01:08:08.643Z","comments":true,"path":"2018/05/10/weChat/02-基本知识点/","link":"","permalink":"http://yoursite.com/2018/05/10/weChat/02-基本知识点/","excerpt":"","text":"基础知识点数据展示语法1&#123;&#123;msg&#125;&#125; 列表渲染123&lt;view wx:for=&quot;&#123;&#123;arr&#125;&#125;&quot;&gt; &lt;text&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt;&lt;/view&gt; 解析 arr: 渲染的数据 item: 当前循环的内容 索引值添加 123&lt;view wx:for=&quot;&#123;&#123;items&#125;&#125;&quot; wx:for-index=&quot;index&quot; wx:for-item=&quot;item&quot;&gt;&#123;&#123;index+1&#125;&#125;、&#123;&#123;item.title&#125;&#125;&lt;/view&gt; 数据的添加和修改数据的添加 和vue的数据模型没有太大差别 1234data: &#123; message: &quot;hello world&quot;, arr:[]&#125; 数据的修改123456//在生命周期钩子中修改数据onLoad() &#123; //在这里修改页面数据 ---- 不能使用this.data.message,小程序捕获不到 this.setData(&#123; message: Date.now()&#125;) 接口的调用123456789101112131415161718 //不能使用ajax的方式调取数据(BOM),应该使用微信官方提供的api wx.request(&#123; url: &apos;https://api.douban.com/v2/movie/in_theaters&apos;, data: &#123; &apos;count&apos;:5 &#125;, header: &#123; // &apos;content-type&apos;: &apos;application/json&apos; // 默认值 &quot;Content-Type&quot;: &quot;json&quot; &#125;, success: (res) =&gt; &#123; console.log(res) // this.setData(&#123; // arr : res.data.playlist.tracks // &#125;) &#125; &#125;)&#125; 事件绑定12&lt;view&gt;&#123;&#123; msg &#125;&#125;&lt;/view&gt;&lt;button bindtap=&quot;clickMe&quot;&gt;点击我&lt;/button&gt;","categories":[{"name":"weChat","slug":"weChat","permalink":"http://yoursite.com/categories/weChat/"}],"tags":[]},{"title":"01-微信小程序入门","slug":"weChat/01-入门","date":"2018-05-10T00:36:28.924Z","updated":"2018-05-10T01:08:03.992Z","comments":true,"path":"2018/05/10/weChat/01-入门/","link":"","permalink":"http://yoursite.com/2018/05/10/weChat/01-入门/","excerpt":"","text":"微信小程序入门萨芬给谁发的规范和 必备知识121. 需要会html--css--js,但不是必备2. 更好的话react vue 项目目录结构解析 详解 1.app.js: 定义应用程序的主逻辑 定义全部逻辑 12345678910111213//使用App构造方法创建应用程序App(&#123; //小程序启动之后.onLaunch方法会执行 onLaunch()&#123; &#125;, //定义全局的fn方法----这个方法可以看成是共享的 fn()&#123; console.log(1) &#125;&#125;) 2.app.json : 应用程序全局配置 包含页面配置项和系统配置项等内容 123456789101112&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &#125;&#125; 3.app.wxss 配置全局的样式 12345678910/**app.wxss**/.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box;&#125; 4.project.config.json 项目配置,可以设置一些个性化的内容,可以快速进行项目的个性化设置 文件/页面 页面结构解析 为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。 1.index.js : 定义页面的逻辑 123456789101112//获取应用程序的实例var app = getApp()//Page就是一个页面构造器,用于创建页面Page(&#123; data: &#123; // 参与页面渲染的数据 logs: [] &#125;, onLoad: function () &#123; // 页面渲染后 执行 &#125;&#125;) 2.index.json 文件配置项 3.index.wxml 页面内容,相当于html部分 4.index.wxss 页面样式,相当于css 小程序特色 小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。 框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。 1.响应的数据绑定,类似于angular和vue 2.组件化-提供丰富的组件 3.丰富的api,简化操作","categories":[{"name":"weChat","slug":"weChat","permalink":"http://yoursite.com/categories/weChat/"}],"tags":[]},{"title":"22-核心知识点","slug":"angular2/999-核心知识点","date":"2018-05-10T00:36:05.077Z","updated":"2018-05-10T01:31:39.299Z","comments":true,"path":"2018/05/10/angular2/999-核心知识点/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/999-核心知识点/","excerpt":"","text":"核心知识点 组件 路由 数据请求 服务 模块 难点 组件通信 服务的使用 路由守卫,异步模块加载…… 依赖注入 rxjs 具体内容详见图谱","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"21-angular优质学习资源","slug":"angular2/300-3-优质学习资源收集","date":"2018-05-10T00:36:05.073Z","updated":"2018-05-10T01:31:31.420Z","comments":true,"path":"2018/05/10/angular2/300-3-优质学习资源收集/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/300-3-优质学习资源收集/","excerpt":"","text":"angular优质学习资源文档博客书籍类官方网站： https://angular.io angular官方源码库 https://github.com/angular/angular 中文站点： https://angular.cn Victor的blog（Victor是Angular路由模块的作者）： https://vsavkin.com/@vsavkin Todd Motto的Blog： https://toddmotto.com/ ThoughtRAM上的Blog频道： https://blog.thoughtram.io/categories/angular-2/ Angular University： http://blog.angular-university.io/ Deborah’s Developer MindScape： http://blogs.msmvps.com/deborahk/ Jason Watmore’s Blog： http://jasonwatmore.com/ RxJS官方网站： http://reactivex.io/ RxJS中文版文档（这是我看过的最好的关于RxJS的中文文档，注意，没有之一！向译者致敬！）： https://www.gitbook.com/book/buctwbzs/rxjs/details 一本开源的Angular2书籍：https://zhangchen915.gitbooks.io/angular2-training/ 开源项目类Angular Angury项目： https://augury.angular.io/ Angular Team在github上的地址： https://github.com/angular ng2-bootstrap： https://ng-bootstrap.github.io/#/home NGPrime： http://www.primefaces.org/primeng/#/ Angular-Material2： https://github.com/angular/material2 KendoUI：http://www.telerik.com/blogs/what-to-expect-in-2016-for-kendo-ui-with-angular-2-and-more ionic： https://ionic.io/ 一个非常好的管理后台项目（那些拿Angular来做管理系统的朋友，请务必看这个项目，它是非常好的后台管理界面模板，而且是开源免费的）： https://github.com/akveo/ng2-admin 一个很好的Blog项目： https://github.com/WittBulter/sails-blog-frontend RxJS聊天室： https://github.com/ng-book/angular2-rxjs-chat 教学用的项目NiceFish： http://git.oschina.net/mumu-osc/NiceFish GitHub上搜索Angular相关资源的更好方法：https://github.com/search?utf8=%E2%9C%93&amp;q=topic%3Aangular&amp;type=Repositories&amp;ref=searchresults 一组Angular2应用收集：http://angularexpo.com/ 一组UI库：https://teradata.github.io/covalent/#/ 一个非常好的入门项目： https://github.com/AngularClass/angular2-webpack-starter 基于Angular 1.x+Bootstrap的后台管理模板项目：https://github.com/akveo/blur-admin NiceFish（美人鱼）是一个系列教学项目 https://gitee.com/mumu-osc/NiceFishNiceFish-openChina http://git.oschina.net/mumu-osc/NiceFish webpack-angular-aot https://github.com/kunl/Angular-webpack-AOT codebe/钟钟,一个整合各种插件的项目 https://gitee.com/zt_zhong/CodeBe 视频类一个非常好的RxJS教学视频（想快速学会RxJS的朋友请务必仔细看完这个视频）： https://coryrylan.com/blog/introduction-to-rxjs-observables-and-angular 关于RxJS的更多视频（RxJS官方出的）： https://egghead.io/lessons/rxjs-rxjs-observables-vs-promises 油管上的AngularConnect频道： https://www.youtube.com/channel/UCzrskTiT_ObAk3xBkVxMz5g 油管上的ng-conf频道： https://www.youtube.com/user/ngconfvideos angular1大漠视频教程 http://www.imooc.com/learn/156 优酷频道 http://i.youku.com/i/UMzI1MjQ0MDgw/videos?spm=a2hzp.8253876.0.0","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"20-ui库","slug":"angular2/300-2-angular-ui库","date":"2018-05-10T00:36:05.070Z","updated":"2018-05-10T01:31:23.613Z","comments":true,"path":"2018/05/10/angular2/300-2-angular-ui库/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/300-2-angular-ui库/","excerpt":"","text":"angular ui库12Angular-Material,Prime-NG,ng2-bootstrap,ionic ng2-bootstrap官方文档链接地址 PrimeNG官方文档链接地址 Angular-Material2官方文档链接地址 Ionic官方文档链接地址","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"19-angular核心","slug":"angular2/300-1-核心概念","date":"2018-05-10T00:36:05.067Z","updated":"2018-05-10T01:31:16.296Z","comments":true,"path":"2018/05/10/angular2/300-1-核心概念/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/300-1-核心概念/","excerpt":"","text":"angular核心三大核心概念 Component,Module,Route 组件化组件树与视图变更检测机制 组件树 数据变更检测机制 在angular1中使用的是数据双向绑定,利用脏值检测机制,每次当有内容发生变化的时候,都会检测整个应用程序,造成很大的性能上的浪费 在angular2以及以上版本中,抛弃了脏值检测的方式,而改用单项数据流,当内容发生变化的时候,不会检测整个组件树,只会检测当前分支 参考链接 github官网-angular数据流 模块化 类似于组件化,可以实现项目的按功能模块进行划分 123451. 应用程序的功能(业务)模块划分,使用根模块进行统一管理2. 模块内部可以包含组件,指令,管道,路由,服务......3. 配合路由操作可以实现按需加载 ----- 类似于vue的组件懒加载 在angular应用程序中,只有ngModule模块装饰器来定义一个模块,这样做的意义在哪? 在开发过程中,我们需要根据业务模块在应用程序开发的过程中,进行模块化的划分,但是在在项目打包的时候,我们需要在文件的体积和请求的次数之间进行一个权衡 模块划分 模块划分当然是越详细越好,有利于项目的二次开发和代码的维护 请求次数 每个模块(打包后的js文件)都会发送一次http请求 我们可以在控制台的network查看具体的请求 模块划分和请求次数的权衡 需要根据实际需求在两者之间找到一个平衡点 路由 我们可以使用路由操作配合模块化实现异步模块加载 1.静态路由 2.异步路由 Angular核心架构思想依赖注入DI123451.每一个HTML标签上面都会有一个注射器实例2.注射是通过constructor进行的3.@Injectable是@Component的子类 依赖注入的具体实现可以参考一下链接 依赖注入的实现机制1依赖注入的实现机制1 数据绑定数据绑定的具体实现可以参考一下链接 数据绑定的实现1数据绑定的实现2","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"18-自动化测试","slug":"angular2/18-自动化测试","date":"2018-05-10T00:36:05.061Z","updated":"2018-05-10T01:31:04.420Z","comments":true,"path":"2018/05/10/angular2/18-自动化测试/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/18-自动化测试/","excerpt":"","text":"自动化测试单元测试mooc网视频教程 http://www.imooc.com/video/2638 karma 和 jasmine Karma+Jasmine可以用于任意前端框架 集成测试中文视频和详细的语法解释：http://www.imooc.com/video/4361 Protractor是专门针对Angular设计的 http://www.protractortest.org/#/ 前端测试神器F2etest是一个面向前端、测试、产品等岗位的多浏览器兼容性测试整体解决方案https://github.com/alibaba/f2etest http://f2etest.com/","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"17-i18n","slug":"angular2/17-i18n-国际化","date":"2018-05-10T00:36:05.058Z","updated":"2018-05-10T01:30:55.453Z","comments":true,"path":"2018/05/10/angular2/17-i18n-国际化/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/17-i18n-国际化/","excerpt":"","text":"i18n 国际化,让我们的应用支持多种语言","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"16-自定义指令","slug":"angular2/16-指令","date":"2018-05-10T00:36:05.055Z","updated":"2018-05-10T01:30:46.204Z","comments":true,"path":"2018/05/10/angular2/16-指令/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/16-指令/","excerpt":"","text":"自定义指令 —- 陌陌详情参考此链接 在angular中指令有两种： 123属性型指令：比如 ngClass ngStyle 等 修改宿主元素的样式或行为等结构型指令，比如 *ngIf，*ngFor 修改DOM结构。 自定义指令的实现创建指令 我们创建一个test指令： 1ng g directive directive/test 对于指令，会生成两个文件： 12test.directive.ts test.directive.spec.ts 文件模板 12345678910import &#123; Directive &#125; from &apos;@angular/core&apos;;@Directive(&#123; selector: &apos;[appTest]&apos;&#125;)export class TestDirective &#123; constructor() &#123; &#125;&#125; 自定义属性型指令 自定义属性型指令,完成类样式的添加 12345678910111213import &#123; Directive, ElementRef, AfterViewInit, Renderer2 &#125; from &apos;@angular/core&apos;; @Directive(&#123; selector: &apos;[appButton]&apos; &#125;) export class ButtonDirective implements AfterViewInit&#123; constructor(private er: ElementRef, private renderer2: Renderer2) &#123; &#125; ngAfterViewInit() &#123; this.renderer2.addClass(this.er.nativeElement, &apos;btn&apos;); &#125; &#125; 具体使用 12&lt;button appButton&gt;指令按钮/button&gt; 自定义结构型指令 自定义一个实现*ngIf功能的指令 123456789101112131415161718import &#123; Directive, Input, ViewContainerRef, TemplateRef &#125; from &apos;@angular/core&apos;; @Directive(&#123; selector: &apos;[appMyIf]&apos; &#125;) export class MyIfDirective &#123; constructor(private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef) &#123; &#125; @Input() set appMyIf(condition: boolean) &#123; if (condition) &#123; this.viewContainer.createEmbeddedView(this.templateRef); &#125; else &#123; this.viewContainer.clear(); &#125; &#125; &#125; 具体使用 1&lt;div *appMyIf=&quot;isMyShow&quot;&gt;自定义结构型指令appMyIf&lt;/div&gt;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"15-动画","slug":"angular2/15-动画","date":"2018-05-10T00:36:05.052Z","updated":"2018-05-10T01:30:39.204Z","comments":true,"path":"2018/05/10/angular2/15-动画/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/15-动画/","excerpt":"","text":"动画动画模块安装 Angular4后动画模块分离出来了 12npm install @angular/animations --save","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"14-表单处理","slug":"angular2/14-表单","date":"2018-05-10T00:36:05.037Z","updated":"2018-05-10T01:30:31.358Z","comments":true,"path":"2018/05/10/angular2/14-表单/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/14-表单/","excerpt":"","text":"表单处理以前学过的表单1.基本的html表单 123456&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;div&gt;用户名: &lt;input type=&quot;text&quot;/&gt;&lt;/div&gt; &lt;div&gt;密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;div&gt;确认密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 2.html5表单 在原先表单的基础上,添加了一些简单的验证,并添加了一些新的输入类型和表单元素 新增的表单输入类型 12345678910111213colordatedatetimedatetime-localemailmonthnumberrangesearchteltimeurlweek 新增的表单元素 123&lt;datalist&gt;&lt;keygen&gt;&lt;output&gt; 新增的输入类型的属性 12345678910111213141516autocompleteautofocusactionenctypemethodnovalidatetargetheight and width height 和 width 属性只适用于 image 类型的&lt;input&gt; 标签。listmin and maxmultiplepattern (regexp)placeholderrequiredstep 123456&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;div&gt;用户名: &lt;input type=&quot;text&quot; required=&quot;required&quot;/&gt;&lt;/div&gt; &lt;div&gt;密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;div&gt;确认密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 在ng2Pro中的表单模板式表单 在ng2Pro中在原先表单的继承上,添加了一些新的功能,通过指令的形式实现 模板驱动表单中,所有的验证逻辑都写在表单里面 1.使用angular表单,需要先导入FormsModule 123451.导入表单模块 import &#123; FormsModule &#125; from &apos;@angular/forms&apos;;2. 放到模块装饰器的imports中 imports:[FormsModule] 2.取消了submit的默认提交事件 只有在添加ngNoForm的时候才会还原表单默认的提交事件 123456&lt;form action=&quot;/login&quot; method=&quot;post&quot; ngNoForm&gt; &lt;div&gt;用户名: &lt;input type=&quot;text&quot; required=&quot;required&quot;/&gt;&lt;/div&gt; &lt;div&gt;密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;div&gt;确认密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 3.表单的使用比原先学习的方式更加便捷 在这里使用到了一些知识点 12345678910111. #myForm表示一个本地变量,你可以理解为就像vue中虚拟dom那样,能够直接获取到当前的标签,但是只能在当前页面使用2. ngForm指令你可以理解为表示的整个表单,其value属性值表示的是表单里面标识有name属性的所有的value值 但是ngForm不能够直接去使用(隐式创建了一个FormGroup类的实例,包含了表单内部的value值)3. #myForm=&apos;ngForm&apos;就是一个简单的赋值操作,使用本地变量的形式得到--angular--表单内部的Value值4. 在表单内部,可以直接使用ngModel来获取到表单内部的value值来添加到设置的name属性上(后面会有效果的演示) 注意: 在这里不能使用[(ngModel)]5. ngSubmit事件 其实就是--angular--表单的提交事件,可以理解为重命名了一下 实现的效果如下 3.ngModelGroup的使用 可以用于处理复杂的表单 结构层次上更加清晰 响应式表单 响应式表单的类名和指令如下图所示 将功能代码书写到代码中进行实现,简化页面的html结构 123456FormControl 用于跟踪一个单独的表单控件的值和有效性状态。它对应于一个HTML表单控件，比如输入框和下拉框。FormGroup 用于 跟踪一组AbstractControl的实例的值和有效性状态。 该组的属性中包含了它的子控件。 组件中的顶级表单就是一个FormGroup。FormArray 用于跟踪AbstractControl实例组成的有序数组的值和有效性状态。 1.FormControl 2.FormGroup和FormArray 如果有多个FormControl，我们会希望把它们注册进一个父FormGroup中 同样,如果有多个FormController,我们可以把它放到一个FormArray中 最终FormArray是要放到FormGroup中的 动态表单 根据数据去动态的生成表单 表单几乎都是使用代码创建的 表单验证 Angular使用ngModel和name属性构建了一个FormControl，这也是我们可以通过NgForm.controls获取里面所有具有name属性的表单，它是一个数组。 而对于每一个FormControl，它都有以下验证属性： 内置的一些校验规则 12345678requiredrequiredTrueminLengthmaxLengthpatternnullValidatorcomposecomposeAsync 基本验证123456789101112&lt;div&gt; &lt;label&gt; 性别： &lt;select [(ngModel)]=&quot;sex&quot; name=&quot;sex&quot; required #sexInput=&quot;ngModel&quot;&gt; &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;p *ngIf=&quot;sexInput.invalid&quot; class=&quot;error&quot;&gt;不合法&lt;/p&gt; &lt;p *ngIf=&quot;sexInput.errors?.required&quot;&gt;失败显示的内容&lt;/p&gt;&lt;/div&gt; 能力提升1234567891011121314151617181920212223242526&lt;div class=&quot;box&quot;&gt; &lt;form #userForm=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(userForm.form.valid)&quot; novalidate&gt; &lt;div&gt; &lt;label&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;name&quot; [(ngModel)]=&quot;name&quot; required&gt; &lt;/label&gt; &lt;p *ngIf=&quot;userForm.controls[&apos;name&apos;]?.invalid&quot; class=&quot;error&quot;&gt;用户名必填&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt; 电话：&lt;input type=&quot;text&quot; name=&quot;tel&quot; [(ngModel)]=&quot;tel&quot; pattern=&quot;1[3|5|8]\\d&#123;9&#125;&quot; required&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt; 性别： &lt;select [(ngModel)]=&quot;sex&quot; name=&quot;sex&quot; required&gt; &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;p *ngIf=&quot;userForm.controls[&apos;sex&apos;]?.errors?.required&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; [disabled]=&quot;!userForm.form.valid&quot;&gt;发布&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"13-服务","slug":"angular2/13-服务","date":"2018-05-10T00:36:05.033Z","updated":"2018-05-10T01:30:17.894Z","comments":true,"path":"2018/05/10/angular2/13-服务/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/13-服务/","excerpt":"","text":"服务 封装了一项功能,并且可以通过注入的方式供其他使用的独立模块 服务可以分为很多种—-包括值,函数以及其他特性 如果在项目中有一段代码是很多组件都要使用的，那么最好的方式就是把它做成服务。 服务是一种在组件中共享功能的机制，当我们使用标签将多个组件组合在一起时我们需要操作一些数据或是需要做一些运算时，我们需要做一个服务；服务能帮我们引入外部的数据 old服务的种类 服务分为很多种，包括：值、函数，以及应用所需的特性。 以下是几种常见的服务： 12345日志服务数据服务消息总线税款计算器应用程序配置 服务的生成(基本使用)1.创建服务 1ng g service serviceName/file 2.提供服务 提供的服务需要在app.module.ts中显式声明 123451.先导入 import &#123; HeroService &#125; from &apos;./hero.service&apos;;2.再声明 providers: [HeroService], 3.服务实现的功能 也就是说这个服务是做什么的 以一个提供数据的服务为例 4.使用服务 服务的应用12345日志服务数据服务消息总线税款计算器应用程序配置 数据服务 将项目中使用到的相关数据获取的操作都分离出来,做成一个可复用的可注入的服务 1.定义服务Appservice 首先使用命令行生成一个服务 ng g service service/app 123456789101112131415161718192021import &#123;Injectable&#125; from &quot;@angular/core&quot;;import &#123;Http, Jsonp&#125; from &quot;@angular/http&quot;;import &quot;rxjs/add/operator/map&quot;;@Injectable()export class AppService &#123; constructor(public http:Http, public jsonp:Jsonp) &#123; &#125; // http.get httpGet(url, params) &#123; return this.http.get(url, &#123;search: params&#125;).map(result=&gt;result.json()); &#125; // http.post httpPost(url, params) &#123; return this.http.post(url, params).map(result=&gt;result.json()); &#125; // jsonp jsonpGet(url, params) &#123; return this.jsonp.get(url, &#123;search: params&#125;).map(result=&gt;result.json()); &#125;&#125; 2.定义组件,加载服务 1234567891011121314151617181920212223242526272829303132import &#123;Component, OnInit&#125; from &quot;@angular/core&quot;;// 获取路由传递传递过来的params(id) 增加模块激活的路由(ActivatedRoute)import &#123;ActivatedRoute&#125; from &quot;@angular/router&quot;;import &#123;AppService&#125; from &quot;./app.service&quot;;import &#123;URLSearchParams&#125; from &quot;@angular/http&quot;;@Component(&#123; selector: &quot;my-info&quot;, templateUrl: &quot;../templates/about-info.html&quot;, providers: [AppService]&#125;)export class AboutInfoComponent implements OnInit &#123; // 定义一个变量, 获取服务方法取得的数据 info:Number; data:Array&lt;Object&gt;; // 初始化变量, 这里必须加修饰词 public private, 初始化服务, 然后使用服务方法,调取数据 constructor(public infos:AppServer) &#123; &#125; // 方法中操作id, 通过id查询信息等等 ngOnInit()&#123; var url = &quot;http://localhost:3000/login&quot;; var params = new URLSearchParams(); params.set(&quot;id&quot;, &quot;1&quot;); // 传递过来的不是promise 所以要subscribe执行 this.infos.getHttp(url, params).subscribe(res=&gt; &#123; console.log(res); &#125; ); &#125;&#125; 3.服务的全局加载 上面组件中局部加载了这个服务， 如果需要全局导入服务 app.module.ts文件中 1providers: [AppService] 日志服务 以下实例是一个简单的日志服务，用于把日志记录到浏览器的控制台： 12345export class Logger &#123; log(msg: any) &#123; console.log(msg); &#125; error(msg: any) &#123; console.error(msg); &#125; warn(msg: any) &#123; console.warn(msg); &#125;&#125; new基本使用1.生成服务 12ng g service service/data 2.基本模板 建议每一个服务都加上@Injectable()装饰器。 注意： 当 TypeScript 看到@Injectable()装饰器时，就会记下本服务的元数据。 如果 Angular 需要往这个服务中注入其它依赖，就会使用这些元数据。 12345678import &#123; Injectable &#125; from &apos;@angular/core&apos;;@Injectable()export class DataService &#123; constructor() &#123; &#125;&#125; 示例1 定义一个提供数据的服务 1. 定义本地json—-数据模拟 data.json 12345678910111213&#123; &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;HTML&quot; &#125;, &#123; &quot;name&quot;: &quot;Javascript&quot; &#125;, &#123; &quot;name&quot;: &quot;Angular&quot; &#125; ] &#125; 2.定义服务功能 123456789101112131415161718192021222324252627282930import &#123; Injectable &#125; from &apos;@angular/core&apos;;import &#123; Http &#125; from &apos;@angular/http&apos;;import &apos;rxjs/add/operator/toPromise&apos;; @Injectable()export class DataService &#123; constructor( public $http: Http ) &#123;&#125; getData() &#123; console.log(1) const url = &apos;./assets/data.json&apos;; return this.$http.get(url) .toPromise() .then(res =&gt; res.json()) .catch(this.handleError); &#125; private handleError(error: any): Promise&lt;any&gt; &#123; console.error(&apos;An error occurred&apos;, error); // for demo purposes only return Promise.reject(error.message || error); &#125;&#125; 3.使用服务 在这里是在当前组件使用 在这里必须使用异步的方式获取数据 12345678910111213141516171819202122232425262728import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123;DataService&#125; from &apos;../../service/data.service&apos;; @Component(&#123; selector: &apos;app-service-test&apos;, templateUrl: &apos;./service-test.component.html&apos;, styleUrls: [&apos;./service-test.component.css&apos;], providers: [DataService]&#125;)export class ServiceTestComponent implements OnInit &#123; constructor( public dataService:DataService ) &#123; &#125; ngOnInit() &#123; this.dataService.getData().then((res)=&gt;&#123; console.log(res) &#125;) &#125;&#125; 常用服务1.get 1234567891011get() &#123; return this.http.get(url) .toPromise() .then(response =&gt; response.json() ) .catch(this.handleError); &#125; private handleError(error: any): Promise&lt;any&gt; &#123; console.error(&apos;An error occurred&apos;, error); // for demo purposes only return Promise.reject(error.message || error); &#125; 2.post 123456789private headers = new Headers(&#123;&apos;Content-type&apos;: &apos;application/json&apos;&#125;); create() &#123; return this.http .post(url, JSON.stringify(hero), &#123;headers: this.headers&#125;) .toPromise() .then(response =&gt; response.json()) .catch(this.handleError); &#125; 3.update 12345678910private headers = new Headers(&#123;&apos;Content-type&apos;: &apos;application/json&apos;&#125;); update() &#123; return this.http .put(url, JSON.stringify(hero), &#123;headers: this.headers&#125;) .toPromise() .then(response =&gt; response.json()) .catch(this.handleError); &#125; 4.delete 123456789private headers = new Headers(&#123;&apos;Content-type&apos;: &apos;application/json&apos;&#125;); delete() &#123; return this.http .delete(url, &#123;headers: this.headers&#125;) .toPromise() .then(() =&gt; null) .catch(this.handleError); &#125;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"12-数据请求","slug":"angular2/12-数据请求","date":"2018-05-10T00:36:05.029Z","updated":"2018-05-10T01:30:06.999Z","comments":true,"path":"2018/05/10/angular2/12-数据请求/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/12-数据请求/","excerpt":"","text":"数据请求 在vue中进行数据请求使用的是vue-resource和axios这两个插件在angular中,对数据请求以模块化的方式进行了封装,封装到@angular/http模块中 我们在使用的时候,首先要导入这个模块,就像是vue中导入axios.js和vue-resource.js一样 数据请求的简单实现发送get请求大致过程可以分为以下几步 123456789101112131415161718192021222324252627282930311.导入请求模块,在angular中,使用什么东西首先要在app.module中导入 import &#123; HttpModule &#125; from &apos;@angular/http&apos;; 并将导入的模块添加到 @NgModule 的 imports中2.在需要的地方导入http模块,也就是说要在哪里发送请求,就在哪里导入http模块(类)即可 import &#123; Http &#125; from &apos;@angular/http&apos;; 3.将到如的模块注入到构造函数中 constructor(private $http: Http) &#123; &#125;4.发送请求,获取数据 ngOnInit() &#123; const url = &quot;http://127.0.0.1/00-exam/1508A/week1/select.php&quot; this.$http.get(url) //Angular 的http.get返回一个 RxJS 的Observable对象,在这里我们不需要关注这个对象是一个什么东西 //有一种提供好的方式也就是 toPromise()可以将这个Observable对象转化为我们所熟知的内容 .toPromise() .then((res)=&gt;&#123; //调用 HTTP 的Reponse对象的json方法，以提取出其中的数据 console.log(res.json()) //将我们读取到的数据赋值给数据并进行渲染就可以了 &#125;) //捕获错误 .catch((error)=&gt;&#123; console.log(error) &#125;) &#125; 图解 发送post请求大致过程可以分为以下几步 1234567891011121314151617181920212223242526272829301.导入请求模块,在angular中,使用什么东西首先要在app.module中导入 import &#123; HttpModule &#125; from &apos;@angular/http&apos;; 并将导入的模块添加到 @NgModule 的 imports中2. 在需要的地方导入http模块,也就是说要在哪里发送请求,就在哪里导入http模块(类)即可,此外,还需要URLSearchParams import &#123; Http , URLSearchParams &#125; from &apos;@angular/http&apos;;3. 注入到构造函数 constructor(public $http: Http) &#123;&#125;4. 发送请求 var url = &quot;http://127.0.0.1:8899/api/insertData&quot; let params = new URLSearchParams(); params.set(&apos;name&apos;, &apos;huge&apos;); params.set(&apos;sex&apos;, &apos;huge&apos;); params.set(&apos;email&apos;, &apos;huge&apos;); params.set(&apos;phone&apos;, &apos;huge&apos;); params.set(&apos;address&apos;, &apos;huge&apos;); this.$http.post(url, params) .toPromise() .then(res =&gt; &#123; console.log(res); &#125;) jquery 像vue那样,除了本身的数据请求方式之外,还可以使用其他的方式,比如我们的jquery jquery的使用可以参考配置教程* get请求 使用的时候代码按需修改 123456789var url = &quot;http://127.0.0.1:8899/api/getData&quot;$.ajax(&#123; type: &quot;get&quot;, url:url, success(data)&#123; console.log(data) &#125;&#125;) post请求 使用的时候代码部分按需修改 1234567891011121314151617var url = &quot;http://127.0.0.1:8899/api/insertData&quot;var body = &#123; name: &apos;this.name&apos;, sex: &apos;this.sex&apos;, email: &apos;this.email&apos;, phone: &apos;this.phone&apos;, address: &apos;this.address&apos;&#125;$.ajax(&#123; type: &quot;post&quot;, url:url, data:body, success(data)&#123; console.log(data) &#125;&#125;) jsonp-跨域 有的时候,一些接口是在默认情况下只能进行同源访问 在不同源进行访问的时候收到限制,需要使用跨域的方式 1234567891011//jquery-ajax的jsonp请求$.ajax(&#123; type: &quot;get&quot;, url: &quot;https://api.douban.com/v2/movie/top250&quot;, async: true, success(data) &#123; console.log(data) &#125;, jsonpCallback: &quot;fn&quot;, dataType: &quot;jsonp&quot;&#125;); 综合练习基本练习 微信1.案例效果图 题目描述 1234567891.路由模块引入2.路由正确传参3.正确引入http模块和服务4.首页页脚固定5.列表页面的数据请求和渲染6.点击不同用户进入不同的用户聊天窗口7.给点击发送注册正确的事件8.正确的使用双向数据绑定，并且引入正确的模块9.点击发送后正确的发送和接受数据 跨域问题解决方案反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 基本使用1.在项目的根目录下创建一个proxy.config.json文件 内容如下: 12345&#123; &quot;**&quot;:&#123; &quot;target&quot;:&quot;http://127.0.0.1:8800&quot; &#125;&#125; 2.修改package.json文件 更改启动项 1ng serve --proxy-config proxy.config.json 3.配置根模块 12345import &#123;HttpModule&#125; from &quot;@angular/http&quot;imports: [ HttpModule] 4.使用http 三步操作 12345678910111213141. 导入http import &#123;Http&#125; from &quot;@angular/http&quot;2. 注入到构造函数 constructor(public http:Http) &#123;&#125;3. 调用方法 ngOnInit()&#123; var url = &quot;/test&quot; this.http.get(url) .subscribe((res)=&gt;&#123; console.log(res.json()) &#125;) &#125; 5.使用express框架,配置node服务,提供接口 123456789101112131415161718const express = require(&quot;express&quot;);const app = express();let dataSet = [ &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;pengsuo&quot;,&quot;age&quot;:20&#125;, &#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;chenqian&quot;,&quot;age&quot;:34&#125;, &#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;mahao&quot;,&quot;age&quot;:30&#125;, &#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;chenbo&quot;,&quot;age&quot;:50&#125;];app.get(&quot;/test&quot;,(req,res)=&gt;&#123; res.json(dataSet);&#125;);app.listen(8800)console.log(&quot;http://127.0.0.1:8800&quot;) jsonpangular的jsonp模块1.配置根模块 123456import &#123;JsonpModule&#125; from &quot;@angular/http&quot;imports: [ JsonpModule] 2.使用jsonp 三步操作 12345678910111213141. 导入jsonp import &#123;Jsonp&#125; from &quot;@angular/http&quot;2. 注入到构造函数 constructor(public jsonp:Jsonp) &#123;&#125;3. 调用方法 ngOnInit()&#123; var url = &quot;http://127.0.0.1:8800/test?callback=JSONP_CALLBACK&quot; this.jsonp.get(url) .subscribe((res)=&gt;&#123; console.log(res.json()) &#125;) &#125; 3.服务器端代码书写 基于nodejs的express框架 12345678910111213141516171819const express = require(&quot;express&quot;);const app = express();let dataSet = [ &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;pengsuo&quot;,&quot;age&quot;:20&#125;, &#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;chenqian&quot;,&quot;age&quot;:34&#125;, &#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;mahao&quot;,&quot;age&quot;:30&#125;, &#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;chenbo&quot;,&quot;age&quot;:50&#125;];app.get(&quot;/test&quot;,(req,res)=&gt;&#123; res.jsonp(dataSet);&#125;);app.listen(8800)console.log(&quot;http://127.0.0.1:8800&quot;) jquery的ajax跨域12345678910111213$.ajax(&#123; type: &quot;get&quot;, url: &quot;http://127.0.0.1:8800/test?callback=?&quot;, async: true, success(data) &#123; console.log(data) &#125;, error(error)&#123; console.log(error) &#125;, //jsonpCallback: &quot;fn&quot;, dataType: &quot;jsonp&quot;&#125;); cros 服务器端设置跨域资源共享 详情参考此链接 nodejs 基于express框架 123456789101112app.all(&apos;*&apos;, (req, res, next) =&gt; &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;); res.setHeader(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;); next()&#125;); php12header(&quot;Access-Control-Allow-Origin: *&quot;); WebSocket","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"11-路由","slug":"angular2/11-路由操作","date":"2018-05-10T00:36:05.012Z","updated":"2018-05-10T01:29:59.417Z","comments":true,"path":"2018/05/10/angular2/11-路由操作/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/11-路由操作/","excerpt":"","text":"路由 和vue一样,在ng2Pro中也有路由操作 在vue中需要引入vue-router 在ng2Pro中的路由是将相关的操作一模块化的方式封装到一个类中,在使用的时候只需要导入对应的类即可 知识点概述 路由的基本实现 创建一个新的项目模板 1ng new router --routing 和vue一样,流程化操作即可 1234567891011121314151617181920212223242526272829303132331. 引入js / 导入js -----自动完成2. 组件的定义 创建组件----使用命令行的形式 ng g component tab1 ng g component tab2 导入组件 import &#123; Tab1Component &#125; from &apos;./tab1/tab1.component&apos;; import &#123; Tab2Component &#125; from &apos;./tab2/tab2.component&apos;;3. 路由的配置 const routes: Routes = [ &#123;path:&apos;tab1&apos;,component:Tab1Component&#125;, &#123;path:&apos;tab2&apos;,component:Tab2Component&#125; ]; 4. 路由的挂载----自动完成5. 导航的链接 //routerLink的值可以是一个字符串,便于在使用路由的时候传递参数 &lt;a routerLink=&quot;/demoComponent&quot;&gt;创建组件&lt;/a&gt; //routerLink的值可以是一个数组,便于在使用路由的时候传递参数 &lt;a [routerLink]=&quot;[&apos;/&apos;]&quot;&gt;主页&lt;/a&gt; &lt;a [routerLink]=&quot;[&apos;/product&apos;]&quot;&gt;商品详情页&lt;/a&gt; &lt;a [routerLink]=&quot;[&apos;/demoComponent&apos;, &#123; name: &apos;route&apos;, id: 123&#125;]&quot;&gt;商品详情页&lt;/a&gt;6. 组件的显示 显示组件内容的一个容器 &lt;router-outlet&gt;&lt;/router-outlet&gt; 具体实现 使用js控制路由跳转 和基本路由的实现一样,在这里只不过是将a简介跳转的形式换成一种使用js控制路由跳转 和之前相比有区别的地方 12345678910111. 导入路由对象 import &#123;Router&#125; from &apos;@angular/router&apos;2. 注入到构造函数 constructor(private router:Router)&#123;&#125;3. 使用navigate设置跳转的路由 this.router.navigate[&apos;/tab1&apos;] 路由参数和参数对象的获取实现的思路 和vue一样,在基本路由操作的基础上,只需要修改和路径相关的内容就可以了 12345678910111. 导入获取路由参数的对象 ---- ActivatedRoute import &#123;ActivatedRoute&#125; from &apos;@angular/router&apos; 2. 注入到构造函数 constructor(public routerInfo:ActivatedRoute) &#123; &#125;3. 使用snapshot这个对象的相关属性获取对应的参数和参数对象 参数的获取:params[&apos;id&apos;] this.routerInfo.snapshot.params[&apos;id&apos;] 参数对象的获取 this.routerInfo.snapshot.queryParams[&apos;id&apos;] 路由参数获取的另一种方式 上面使用的那一种是参数快照,还有一种是参数订阅的方式 参数订阅能够作什么? 123456 使用这种形式能够正确的获取到通过路由传递过来的参数,但是当当前路由跳转到当前路由的话会有问题 出现像参数快照那样的问题的原因是我们的ngOnInit生命周期钩子只会在创建当前组件的时候调用一次, 当前路由跳转到当前路由的时候,这个钩子不会重复执行使用参数订阅的方式能够解决当前路由跳转到当前路由的问题 参数快照和参数订阅的实现 路由通配符设置通配符号配置路由 每一个都会把一个URL路径(path)映射到一个组件 当所有其上面的路由路径都不符合(包括无效路径)时，就会采取通配符路由 12//当页面不存在的的时候,显示404页面 ---- 通配符这个路由要放到路由的最后面&#123;path:&apos;**&apos;,component:Code404Component&#125; 嵌套路由嵌套路由 重定向路由重定向123&#123;path:&apos;&apos;,component:HomeComponent&#125;,&#123;path:&apos;&apos;,redirectTo:&apos;/home&apos;,pathMatch:&apos;full&apos;&#125;,&#123;path:&apos;home&apos;,component:HomeComponent&#125;, routerLinkActive 一般情况下，我们会为当前激活的路径链接添加一些高亮效果，这时我们可以利用routerLinkActive属性 12345&lt;a routerLink=&quot;/demoComponent&quot; routerLinkActive=&quot;active&quot;&gt;创建组件&lt;/a&gt; 它的值是一个以空格分割的CSS样式类列表。 还可以是一个CSS类数组： [routerLinkActive]=&quot;[&apos;...&apos;]&quot; 注（来源官网）：RouterLinkActive指令会基于当前的RouterState对象来为激活的RouterLink切换CSS类。 这会一直沿着路由树往下进行级联处理，所以父路由链接和子路由链接可能会同时激活。 要改变这种行为，可以把[routerLinkActiveOptions]绑定到{exact: true}表达式。 如果使用了{ exact: true }那么只有在其URL与当前URL精确匹配时才会激活指定的RouterLink 补充12在特性模块中，应该使用RouterModule.forChild() 辅助路由 使用辅助路由可以实现多级视图的效果 1.路由链接和两个视图 1234567891011121314&lt;a [routerLink]=&quot;[&apos;/tab1&apos;]&quot;&gt;tab1&lt;/a&gt;&lt;a [routerLink]=&quot;[&apos;/tab2&apos;]&quot;&gt;tab2&lt;/a&gt;&lt;a [routerLink]=&quot;[&apos;/tab3&apos;]&quot;&gt;tab3&lt;/a&gt;&lt;a [routerLink]=&quot;[&apos;/tab4&apos;]&quot;&gt;tab4&lt;/a&gt;&lt;a [routerLink]=&quot;[&#123;outlets:&#123;aux:&apos;chat1&apos;&#125;&#125;]&quot;&gt;chat1&lt;/a&gt;&lt;a [routerLink]=&quot;[&#123;outlets:&#123;aux:&apos;chat2&apos;&#125;&#125;]&quot;&gt;chat2&lt;/a&gt; //将第二级视图绑定到tab1上 &lt;a [routerLink]=&quot;[&#123;outlets:&#123;primary:&apos;tab1&apos;,aux:&apos;chat2&apos;&#125;&#125;]&quot;&gt;chat2&lt;/a&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;router-outlet name=&apos;aux&apos;&gt;&lt;/router-outlet&gt; 2.路由信息定义 1234567891011121314151617181920212223242526272829import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;import &#123; Tab1Component &#125; from &apos;./component/tabs/tab1/tab1.component&apos;;import &#123; Tab2Component &#125; from &apos;./component/tabs/tab2/tab2.component&apos;;import &#123; Tab3Component &#125; from &apos;./component/tabs/tab3/tab3.component&apos;;import &#123; Tab4Component &#125; from &apos;./component/tabs/tab4/tab4.component&apos;;import &#123; Chat1Component &#125; from &apos;./component/chat/chat1/chat1.component&apos;;import &#123; Chat2Component &#125; from &apos;./component/chat/chat2/chat2.component&apos;;const routes: Routes = [ &#123;path:&quot;tab1&quot;,component:Tab1Component&#125;, &#123;path:&quot;tab2&quot;,component:Tab2Component&#125;, &#123;path:&quot;tab3&quot;,component:Tab3Component&#125;, &#123;path:&quot;tab4&quot;,component:Tab4Component&#125;, &#123;path:&quot;chat1&quot;,component:Chat1Component,outlet:&apos;aux&apos;&#125;, &#123;path:&quot;chat2&quot;,component:Chat2Component,outlet:&apos;aux&apos;&#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; 路由钩子/路由守卫任何用户都能在任何时候导航到任何地方。 但有时候这样是不对的。 考虑一下场景 123456789101. 该用户可能无权导航到目标组件。2. 可能用户得先登录（认证）。3. 在显示目标组件前，我们可能得先获取某些数据。4. 在离开组件前，我们可能要先保存修改。5. 我们可能要询问用户：你是否要放弃本次更改，而不用保存它们？ 路由守卫 123456789我们可以往路由配置中添加守卫，来处理这些场景。守卫返回一个值，以控制路由器的行为： 如果它返回true，导航过程会继续 如果它返回false，导航过程会终止，且用户会留在原地。 守卫还可以告诉路由器导航到别处，这样也取消当前的导航。 路由守卫的种类12345678910用CanActivate来处理导航到某路由的情况。用CanActivateChild来处理导航到某子路由的情况。用CanDeactivate来处理从当前路由离开的情况.用Resolve在路由激活之前获取路由数据。用CanLoad来处理异步导航到某特性模块的情况。 CanActivate的基本使用1.新建一个守卫 123456789101112131415161718 import &#123;CanActivate&#125; from &apos;@angular/router&apos; //使用angular router内置的接口CanActivate实现路由守卫 export class LoginGuard implements CanActivate &#123; canActivate()&#123; let loginIn:boolean = Math.random() &lt; 0.5 if(!loginIn) &#123; console.log(&quot;用户还没有登录&quot;) &#125; return loginIn &#125; &#125;` 2.在路由的配置文件中app-routing.module.ts使用守卫 1234567891011121314151617181920212223242526272829//1.导入定义好的路由守卫import &#123; LoginGuard &#125; from &apos;./guard/login.guard&apos;;//2.配置路由守卫const routes: Routes = [ &#123;path:&apos;&apos;,redirectTo:&apos;swiper&apos;,pathMatch:&apos;full&apos;&#125;, &#123;path:&apos;swiper&apos;,component:SwiperComponent&#125;, &#123;path:&apos;index&apos;,component:IndexComponent&#125;, &#123; path:&apos;tab2&apos;, component:Tab2Component, //路由进入的守卫 --- 可以执行多个路由守卫,---- 都满足的时候才能进行路由跳转 canActivate:[LoginGuard] &#125;, &#123;path:&apos;**&apos;,component:Error404Component&#125; ];//3.使用守卫----需要通过依赖注入的形式实现,也就是providers@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule], //路由守卫 providers:[LoginGuard]&#125;) CanDeactivate的基本使用1.新建一个守卫 1234567891011121314 import &#123;CanDeactivate&#125; from &apos;@angular/router&apos; import &#123; ProductComponent &#125; from &apos;../product/product.component&apos;; //导入路由离开时候的路由守卫 //泛型 指向当前组件的类型(也就是要保存的组件) export class UnsavedGuard implements CanDeactivate&lt;ProductComponent&gt;&#123; canDeactivate (component: ProductComponent)&#123; return window.confirm(&quot;你还没有保存,确定要离开吗?&quot;) &#125; &#125;` 2.在路由的配置文件中app-routing.module.ts使用守卫 1234567891011121314151617181920212223242526272829303132//1.导入定义好的路由守卫import &#123; LoginGuard &#125; from &apos;./guard/login.guard&apos;;import &#123; UnsavedGuard &#125; from &apos;./guard/unsaved.guard&apos;;//2.配置路由守卫const routes: Routes = [ &#123;path:&apos;&apos;,redirectTo:&apos;swiper&apos;,pathMatch:&apos;full&apos;&#125;, &#123;path:&apos;swiper&apos;,component:SwiperComponent&#125;, &#123;path:&apos;index&apos;,component:IndexComponent&#125;, &#123; path:&apos;tab2&apos;, component:Tab2Component, //路由进入的守卫 --- 可以执行多个路由守卫,---- 都满足的时候才能进行路由跳转 canActivate:[LoginGuard], //路由离开的守卫 canDeactivate:[UnsavedGuard], &#125;, &#123;path:&apos;**&apos;,component:Error404Component&#125; ];//3.使用守卫----需要通过依赖注入的形式实现,也就是providers@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule,UnsavedGuard], //路由守卫 providers:[LoginGuard]&#125;) Resolve: 预先获取组件数据123456789101112在Hero Detail和Crisis Detail中，它们等待路由读取完对应的英雄和危机。In the Hero Detail and Crisis Detail, the app waited until the route was activated to fetch the respective hero or crisis.这种方式没有问题，但是它们还有进步的空间。 如果我们在使用真实api，很有可能数据返回有延迟，导致无法即时显示。 在这种情况下，直到数据到达前，显示一个空的组件不是最好的用户体验。我们最好预先从服务器上获取完数据，这样在路由激活的那一刻数据就准备好了。 还要在路由到此组件之前处理好错误。 但当某个id无法对应到一个危机详情时，我们没办法处理它。 这时我们最好把用户带回到“危机列表”中，那里显示了所有有效的“危机”。总之，你希望的是只有当所有必要数据都已经拿到之后，才渲染这个路由组件。我们需要Resolve守卫。 1.创建守卫 12345678910111213141516171819202122232425262728293031import &#123;Resolve,ActivatedRouteSnapshot,RouterStateSnapshot,Router&#125; from &apos;@angular/router&apos;import &#123; Product &#125; from &apos;../product/product.component&apos;;import &#123;Observable&#125; from &apos;rxjs&apos;import &#123;Injectable&#125; from &apos;@angular/core&apos;//使用Injectable装饰器装饰 生成服务@Injectable()export class Test implements Resolve&lt;Product&gt;&#123; constructor(private router:Router)&#123;&#125; resolve (route: ActivatedRouteSnapshot,state:RouterStateSnapshot)&#123; let productId:number = route.params[&apos;id&apos;] //数据获取成功 if(productId ==1 )&#123; return new Product(1,&quot;success&quot;) &#125; //数据获取不成功 导航到新路径 else&#123; this.router.navigate([&apos;/home&apos;]) return undefined &#125; &#125; &#125;export class Test &#123;&#125; 2.使用守卫 1234567891011121314151617181920212223242526272829303132333435//1.导入定义好的路由守卫import &#123; LoginGuard &#125; from &apos;./guard/login.guard&apos;;import &#123; UnsavedGuard &#125; from &apos;./guard/unsaved.guard&apos;;import &#123; Test &#125; from &apos;./guard/test.test&apos;;//2.配置路由守卫const routes: Routes = [ &#123;path:&apos;&apos;,redirectTo:&apos;swiper&apos;,pathMatch:&apos;full&apos;&#125;, &#123;path:&apos;swiper&apos;,component:SwiperComponent&#125;, &#123;path:&apos;index&apos;,component:IndexComponent&#125;, &#123; path:&apos;tab2&apos;, component:Tab2Component, //路由进入的守卫 --- 可以执行多个路由守卫,---- 都满足的时候才能进行路由跳转 canActivate:[LoginGuard], //路由离开的守卫 canDeactivate:[UnsavedGuard], //导航之前获取数据 resolve:&#123; product: Test&#125; &#125;, &#123;path:&apos;**&apos;,component:Error404Component&#125; ];//3.使用守卫----需要通过依赖注入的形式实现,也就是providers@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule,UnsavedGuard,Test], //路由守卫 providers:[LoginGuard]&#125;) 3.数据的获取 1234567//使用路由守卫在渲染这个组件之前先从服务器读取数据this.routeInfo.data.subscribe((data:Product)=&gt;&#123; //this.productId = product.id //this.productName = product.name console.log(&quot;传递过来的数据是:&quot;+data)&#125;) 综合练习基本路由 配合bootstrap实现布局 路由使用1.效果图 2.题目描述 12345671.配置angular路由切换2.页面轮播的实现3.数据请求的实现 + 列表渲染4.实现搜索功能","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"10-生命周期钩子","slug":"angular2/10-生命周期钩子","date":"2018-05-10T00:36:05.009Z","updated":"2018-05-10T01:29:53.765Z","comments":true,"path":"2018/05/10/angular2/10-生命周期钩子/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/10-生命周期钩子/","excerpt":"","text":"生命周期钩子 在vue2.0中有八种生命周期钩子,之后又新增了两个钩子函数 ng2Pro中的生命周期钩子函数有九个 在ng2Pro中的生命周期钩子是一个接口,在这个接口里面定义了方法,在使用的时候要先实例化 1234567891011121314151617181920212223242526272829301.ngOnChanges() 当Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的SimpleChanges对象 当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit()之前。2.ngOnInit() 在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。 在第一轮ngOnChanges()完成之后调用，只调用一次。3.ngDoCheck() 检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。 在每个Angular变更检测周期中调用，ngOnChanges()和ngOnInit()之后。4.ngAfterContentInit() 当把内容投影进组件之后调用。 第一次ngDoCheck()之后调用，只调用一次。只适用于组件。5.ngAfterContentChecked() 每次完成被投影组件内容的变更检测之后调用。 ngAfterContentInit()和每次ngDoCheck()之后调用 ,只适合组件。6.ngAfterViewInit() 初始化完组件视图及其子视图之后调用。 第一次ngAfterContentChecked()之后调用，只调用一次。只适合组件。7.ngAfterViewChecked() 每次做完组件视图和子视图的变更检测之后调用。 ngAfterViewInit()和每次ngAfterContentChecked()之后调用。只适合组件。8.ngOnDestroy 当Angular每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。 在Angular销毁指令/组件之前调用。 钩子函数不需要全部设置,根据自己的需求,有选择的去使用","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"09-组件之间的数据传递","slug":"angular2/09-组件之间的数据传递","date":"2018-05-10T00:36:05.006Z","updated":"2018-05-10T01:29:47.174Z","comments":true,"path":"2018/05/10/angular2/09-组件之间的数据传递/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/09-组件之间的数据传递/","excerpt":"","text":"组件之间的数据传递 基本思路/逻辑和vue很相似 有数据可以传递(传递什么数据) 如何传递数据 将数据传递到哪(数据的接收) 父组件向子组件传递数据 使用输入属相 @Input() 可以实现父组件向子组件传递数据 具体使用的方式 123456789101112131.有数据可以传递----确定传递哪个数据 222 / selectedHero2.如何传递数据----使用属性绑定的形式实现 [test]=&apos;222&apos;3.接收传递过来的数据并在视图中使用,先从@angular/core这个包中导入 Input import &#123; Component, OnInit ,Input&#125; from &apos;@angular/core&apos; @Input() test 子组件向父组件传递数据 在子组件中使用 @Output 输出一个自定义事件 在父组件中绑定一个自定义事件,通过绑定的自定义事件的事件处理函数接收传递过来的数据 具体实现的方式 12345678910111213141516171.有数据可以传递----确定传递哪个数据----在子组件中输出自定义事件,在触发的时候将数据传递出去2.如何传递数据----在触发自定义事件的时候将数据传递出去 //输出属性,输出一个外部能够访问的自定义事件 @Output() sendData = new EventEmitter() //在创建组件的时候会默认执行一次 ngOnInit() &#123; //触发自定义事件将数据传递出去 this.sendData.emit(&apos;这是子组件数据&apos;) &#125;3.接收传递过来的数据并在视图中使用,先从@angular/core这个包中导入 Input &lt;app-tab2 (sendData)=&apos;getData($event)&apos;&gt;&lt;/app-tab2&gt; //在执行自定义事件处理函数的时候接收数据------------详情参考上图 非父子组件之间的数据传递 在vue中, 提出了一种中间人模式 也就是在两个没有关系的组件之间建立关联 var bus = new Vue() 中间人模式 选定一个组件当做中间人—-使用这个中间人进行 父亲 和 兄弟二人 使用服务的形式实现组件之间的数据传递 代码实现 以下详细说明了如何试用服务实现组件之间的数据的传递 基本配置 至少两个组件 ng g component sibling1ng g component sibling2 使用服务实现两个组件的传值 ng g service service/pass 在跟模块的provider下声明服务先导入服务 再提供服务{PassService} from ‘./service/pass.service’providers: [PassService], 使用服务传值1.service 123456789101112131415161718192021222324import &#123; Injectable &#125; from &apos;@angular/core&apos;;@Injectable()export class PassService &#123; constructor() &#123; &#125; // 用于存消息的变量 message:&quot;&quot; // &#123;&#125; [] send(data)&#123; this.message = data &#125; receive()&#123; return this.message &#125; &#125; 2.sibling1 1234567891011121314151617181920212223import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123;PassService&#125; from &apos;../service/pass.service&apos;@Component(&#123; selector: &apos;app-sibling1&apos;, templateUrl: &apos;./sibling1.component.html&apos;, styleUrls: [&apos;./sibling1.component.css&apos;]&#125;)export class Sibling1Component implements OnInit &#123; constructor( public pass:PassService ) &#123; &#125; ngOnInit() &#123; this.pass.send(&apos;我是组件1&apos;) &#125;&#125; 3.sibling2 1234567891011121314151617181920212223import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123;PassService&#125; from &apos;../service/pass.service&apos;@Component(&#123; selector: &apos;app-sibling2&apos;, templateUrl: &apos;./sibling2.component.html&apos;, styleUrls: [&apos;./sibling2.component.css&apos;]&#125;)export class Sibling2Component implements OnInit &#123; constructor( public pass:PassService ) &#123; &#125; ngOnInit() &#123; console.log(this.pass.receive()) &#125;&#125; 其他方式模板本地变量的使用 通过模板本地变量的使用,能够实现父组件获取并使用子组件里面的属性和方法 ViewChild 可以实现子组件数据和方法在父组件使用 实现的是在父组件中直接访问子组件内容 在父组件的 ngAfterViewInit 生命周期钩子中才能成功获取通过 ViewChild 查询的元素 12345678910111213141516171819202122232425262728//父组件中使用@ViewChild拿到子组件的变量和方法(父组件可调用子组件的方法和变量)import &#123; Component , ViewChild ,ContentChild&#125; from &apos;@angular/core&apos;;// 导入子组件import &#123; ChildComponent &#125; from &apos;./child/child.component&apos;;@Component(&#123; selector: &apos;app-root&apos;, templateUrl: &apos;./app.component.html&apos;, styleUrls: [&apos;./app.component.css&apos;]&#125;)export class AppComponent &#123; // 通过@ViewChild注册子组件 @ViewChild(ChildComponent) public viewChild:ChildComponent; title = &apos;app&apos;; ngAfterViewInit ()&#123; console.log(this.viewChild) &#125; &#125; Inject 子组件中使用@Inject调用父组件中的变量和方法 parent 123456789101112131415161718import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;my-parent&apos;, templateUrl: &apos;./parent.component.html&apos;, styleUrls: [ &apos;./parent.component.css&apos; ],&#125;)export class ParentComponent implements OnInit &#123; constructor() &#123;&#125; ngOnInit(): void &#123; &#125; sayHello()&#123; console.log(&quot;Hello!&quot;) &#125;&#125; child 12345678910111213141516171819import &#123; Component, OnInit, Inject, forwardRef&#125; from &apos;@angular/core&apos;;import &#123; ParentComponent &#125; from &apos;./parent.component&apos;;@Component(&#123; selector: &apos;my-child&apos;, templateUrl: &apos;./child.component.html&apos;, styleUrls: [ &apos;./child.component.css&apos; ],&#125;)export class ChildComponent implements OnInit &#123; constructor( @Inject(forwardRef(()=&gt;ParentComponent)) public parent:ParentComponent ) &#123;&#125; ngOnInit(): void &#123; this.parent.sayHello(); //&quot;Hello!&quot; &#125;&#125; ContentChildhttps://www.cnblogs.com/zheng-chuang/p/7418833.html https://www.cnblogs.com/mttcug/p/8004359.html app.html 12345&lt;h4&gt;Welcome to Angular World&lt;/h4&gt;&lt;app-parent&gt; &lt;app-child&gt;&lt;/app-child&gt;&lt;/app-parent&gt; parent 12345678&lt;p&gt; parent works!&lt;/p&gt;&lt;p&gt;Parent Component&lt;/p&gt;&lt;ng-content&gt;&lt;/ng-content&gt; 1234567891011121314151617181920212223import &#123; Component, OnInit, ContentChild, AfterContentInit &#125; from '@angular/core';import &#123; ChildComponent &#125; from '../child/child.component';@Component(&#123; selector: 'app-parent', templateUrl: './parent.component.html', styleUrls: ['./parent.component.css']&#125;)export class ParentComponent implements OnInit &#123; @ContentChild(ChildComponent) childCmp: ChildComponent; constructor() &#123;&#125; ngOnInit() &#123;&#125; ngAfterContentInit() &#123; console.dir(this.childCmp); &#125;&#125; child 1234567&lt;p&gt; child works!&lt;/p&gt;&lt;p&gt;Child Component&lt;/p&gt; 123456789101112131415161718import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-child', templateUrl: './child.component.html', styleUrls: ['./child.component.css']&#125;)export class ChildComponent implements OnInit &#123; num = 1 constructor() &#123; &#125; ngOnInit() &#123; &#125;&#125; 综合练习父组件向子组件传递数据描述: 点击按钮,实现将文本款里面的数据传递到子组件 备注: 仔细分析一下数据传递的基本流程 子组件向父组件传递数据描述: 点击按钮,实现将子组件文本款里面的数据传递到父组件 代码实现 备注: 仔细分析一下数据传递的基本流程 非父子组件传递数据描述: 实现非父子组件之间的数据通信,点击组件1的按钮,将数据传递到组件2 备注: 仔细分析一下数据传递的基本流程 综合技能1:效果图如下: 综合描述: 使用组件化的方式进行页面的开发,对于星级别评价部分使用数据传递的方式实现 综合技能2:使用组件化的方式完成以下页面的开发 综合练习3 综合练习四1.效果图 2.实现要求 123456789101112131415161. 使用ngIf实现页面选项卡切换2. 在英雄面板显示排在头部的数据3. 在列表页面显示所有的英雄4. 面板页面和列表页面的数据都定义在父组件中5. 使用Input属性/装饰器将父组件中定义好的面板页面的数据传递到对应的子组件中6. 在子组件页面点击添加按钮,能够新增一条数据7. 使用Output属性/装饰器将添加的数据更新到父组件8. 点击 x 能够删除当前数据 , 并保持数据的同步更新","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"08-ng2Pro中的组件化开发","slug":"angular2/08-组件化开发","date":"2018-05-10T00:36:05.001Z","updated":"2018-05-10T01:29:38.865Z","comments":true,"path":"2018/05/10/angular2/08-组件化开发/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/08-组件化开发/","excerpt":"","text":"ng2Pro中的组件化开发 为了使得开发的项目更容易维护,一般需要在结构上进行项目的拆分 也就是一组件化的形式实现模块化开发 哈哈哈哈 子组件的创建 在创建子组件的时候有一种简答的方式,也就是直接使用命令行的形式进行组件的创建 1ng g component componentName 生成的组件的基本结构 简单解析 这个目录结构就相当于是vue中的单文件组件 template标签 —- html文件 script标签 —- ts文件 style标签 —- css文件 组件内容解析 主要是ts文件 12345678910111213import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;; @Component(&#123; selector: &apos;app-tab1&apos;, templateUrl: &apos;./tab1.component.html&apos;, styleUrls: [&apos;./tab1.component.scss&apos;] &#125;) export class Tab1Component implements OnInit &#123; constructor() &#123; &#125; ngOnInit() &#123;&#125; &#125; @Component()是一个装饰器，唯一需要的参数是一个元数据对象。 对象的参数/属性说明： 12345678selector：组件选择器名称,作为标签的形式显示到页面templateUrl：模板文件路径styleUrls：样式文件路径当然，还有两个属性： template：模板字符串 styles：样式数组，比如：styles: [&apos;h1&#123;font-size:20px;&#125;&apos;] 动态插入内容 类似于vue的slot,允许我们动态的向组件内部插入内容,可以用于封装独立组件 组件的基本使用1&lt;app-tab1&gt;&lt;/app-tab1&gt; 动态内容嵌入123&lt;app-tab1&gt; &lt;span&gt;这是动态插入内容&lt;/span&gt;&lt;/app-tab1&gt; 嵌入内容的显示: 将组件内部的内容插入指定位置 ng-content还有一个特别的属性，值可以是”element”, #id”, “.class”, “[name=value] 12//将组件标签内部嵌入的span标签显示到指定的位置&lt;ng-content select=&quot;span&quot;&gt;&lt;/ng-content&gt; 组件样式添加1.在tab1.component.css文件中书写 123span&#123; background: pink;&#125; 2.使用样式字符串 1styles: [&apos;span &#123; font-weight: normal; &#125;&apos;] 3.使用行内样式 1&lt;span style=&quot;background: red;&quot;&gt;这是动态插入内容&lt;/span&gt; 给组件标签添加样式 也就是给当前组件添加样式 host表示的是宿主,可以看成是当前的组件名 1.:host就表示当前样式模板的宿主元素。 注意：默认情况下，自定义组件的display属性是空字符串的，也就是不占据空间。123:host&#123; background: red;&#125; 2.如果只要当其有一定条件的时候才显示某个样式，比如只要当宿主元素具有active类时，才出现灰色背景，可以这样： 123:host(.active) &#123; background: red; &#125; 3.当组件外部有一些条件时，组件内容的样式才变化。最明显的就是主题，比如当某个祖先元素具有CSS类.theme-blue时，字体才变为蓝色： 123:host-context(.theme-blue) &#123; color: blue; &#125; 组件树 理解下面这样一幅图,每一部分内容都是一个组件,不用去管 .vue后缀 组件树概念简单理解 一个工具，允许您查看您的Angular应用程序依赖关系。","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"07-管道","slug":"angular2/07-管道--过滤器","date":"2018-05-10T00:36:04.997Z","updated":"2018-05-10T01:29:28.067Z","comments":true,"path":"2018/05/10/angular2/07-管道--过滤器/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/07-管道--过滤器/","excerpt":"","text":"管道 这里所说的管道指的就是vue中的过滤器 和vue与区别的是在新版本的vue中,取消了内置过滤器的使用,只允许使用自定义过滤器 ng2Pro中的过滤器既有内置的 也允许 自定义 内置管道/过滤器基本管道 和vue没有太大差别 12// 基本过滤器的使用&#123;&#123;name | uppercase&#125;&#125; 日期管道 丰富的日期格式 123456789101112&apos;short&apos;: equivalent to &apos;M/d/yy, h:mm a&apos; (e.g. 6/15/15, 9:03 AM)&apos;medium&apos;: equivalent to &apos;MMM d, y, h:mm:ss a&apos; (e.g. Jun 15, 2015, 9:03:01 AM)&apos;long&apos;: equivalent to &apos;MMMM d, y, h:mm:ss a z&apos; (e.g. June 15, 2015 at 9:03:01 AM GMT+1)&apos;full&apos;: equivalent to &apos;EEEE, MMMM d, y, h:mm:ss a zzzz&apos; (e.g. Monday, June 15, 2015 at 9:03:01 AM GMT+01:00)&apos;shortDate&apos;: equivalent to &apos;M/d/yy&apos; (e.g. 6/15/15)&apos;mediumDate&apos;: equivalent to &apos;MMM d, y&apos; (e.g. Jun 15, 2015)&apos;longDate&apos;: equivalent to &apos;MMMM d, y&apos; (e.g. June 15, 2015)&apos;fullDate&apos;: equivalent to &apos;EEEE, MMMM d, y&apos; (e.g. Monday, June 15, 2015)&apos;shortTime&apos;: equivalent to &apos;h:mm a&apos; (e.g. 9:03 AM)&apos;mediumTime&apos;: equivalent to &apos;h:mm:ss a&apos; (e.g. 9:03:01 AM)&apos;longTime&apos;: equivalent to &apos;h:mm:ss a z&apos; (e.g. 9:03:01 AM GMT+1)&apos;fullTime&apos;: equivalent to &apos;h:mm:ss a zzzz&apos; (e.g. 9:03:01 AM GMT+01:00) 具体使用 1234567891011可以以多样化的形式格式化日期输出&lt;p&gt;&#123;&#123;birthday | date:&apos;fullDate&apos;&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;birthday | date:&quot;MM/dd/yy&quot;&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;birthday | date:&apos;shortDate&apos;&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;birthday | date:&quot;yyyy/MM/dd,hh:mm:ss&quot; &#125;&#125;&lt;/p&gt; json管道 将对象转化为json格式进行输出 参考链接 具体实现 1234561. 导入json管道 import &#123; JsonPipe &#125; from &apos;@angular/common&apos;;2. 使用json管道 &lt;h1&gt;json管道&lt;/h1&gt; &lt;p&gt;&#123;&#123;obj | json&#125;&#125;&lt;/p&gt; 链式管道 我们可以把管道链在一起，以组合出一些潜在的有用功能 12345//过滤器支持连写 也就是多次过滤&lt;p&gt;我的生日是 &#123;&#123;birthday | date | uppercase&#125;&#125;&lt;/p&gt;//特殊的日期格式&lt;p&gt;我的生日是 &#123;&#123;birthday | date | uppercase&#125;&#125;&lt;/p&gt; 更多管道查看更多管道可以参考链以下接 管道API 自定义管道/过滤器基本管道使用1.使用命令行的形式生成一个管道 12//生成一个用于乘法计算的管道ng g pipe pipe/multiple 2.基本结构 12345678910111213import &#123; Pipe, PipeTransform &#125; from &apos;@angular/core&apos;;@Pipe(&#123; name: &apos;multiple&apos;&#125;)export class MultiplePipe implements PipeTransform &#123; transform(value: any, args?: any): any &#123; return null; &#125;&#125; 使用 @Pipe 装饰器定义 Pipe 的 metadata 信息，如 Pipe 的名称 - 即 name 属性 实现 PipeTransform 接口中定义的 transform 方法 3.给管道定义将要实现的功能 数组排序的管道1234567891011121314151617181920import &#123; Pipe, PipeTransform &#125; from &apos;@angular/core&apos;; @Pipe(&#123; name: &apos;sort&apos; &#125;) export class SortPipe implements PipeTransform &#123; transform(array: Array&lt;any&gt;, args?: string): Array&lt;any&gt; &#123; array.sort((a: any, b: any) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; else if (a &gt; b) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;); return array; &#125; &#125; 注解我们更倾向使用纯管道。对于自定义管道，默认是纯管道，如果需要转为非纯管道，可以将@Pipe()中的元数据的pure属性设置为false。 附录（来源官网）： 纯管道 Angular只有在它检测到输入值发生了纯变更时才会执行纯管道。 纯变更是指对原始类型值(String、Number、Boolean、Symbol)的更改， 或者对对象引用(Date、Array、Function、Object)的更改。 Angular会忽略(复合)对象内部的更改。 如果我们更改了输入日期(Date)中的月份、往一个输入数组(Array)中添加新值或者更新了一个输入对象(Object)的属性，Angular都不会调用纯管道。 非纯管道 Angular会在每个组件的变更检测周期中执行非纯管道。 非纯管道可能会被调用很多次，和每个按键或每次鼠标移动一样频繁。","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"06-知识小结","slug":"angular2/06-知识点集锦","date":"2018-05-10T00:36:04.992Z","updated":"2018-05-10T01:29:13.154Z","comments":true,"path":"2018/05/10/angular2/06-知识点集锦/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/06-知识点集锦/","excerpt":"","text":"知识小结知识点集锦类型注解的另一种使用的方式 自定义一个类,使用类型注解的方式使用 123456789101112//创建一个类export class Hero &#123; id: number; name: string;&#125;//类型注解 hero变量是一个Hero类型的数据------自定义数据类型hero:Hero = &#123; id:1, name:&quot;hahaha&quot;&#125; 数据的双向绑定 在ng2Pro中,默认使用的是单向的数据绑定 使用[(ngModel)]语法可以实现数据的双向绑定 1234&lt;h1&gt;数据的双向绑定&lt;/h1&gt;&lt;p&gt;&#123;&#123;title&#125;&#125;&lt;/p&gt;&lt;input type=&quot;text&quot; [(ngModel)]=&quot;title&quot; /&gt; &lt;input type=&quot;text&quot; [value]=&quot;title&quot; /&gt; 一点问题 不幸的是，做了这项改动之后，我们的程序崩溃了。 打开浏览器的控制台，我们会看到Angular抱怨说：“ngModel … isn’t a known property of input.”（ngModel不是input元素的已知属性） 虽然NgModel是一个有效的Angular指令，但它默认情况下却是不可用的。 默认情况下的数据是单向绑定的 它属于一个可选模块FormsModule。 我们必须选择使用这个模块。 代码 1234import &#123; FormsModule &#125; from &apos;@angular/forms&apos;; // &lt;-- NgModel lives hereFormsModule // &lt;-- import the FormsModule before binding with [(ngModel)] 列表/表格渲染 在vue中使用的是v-for指令 在ng2Pro中使用的是 *ngFor 进行列表和表格的渲染 12345678&lt;!--基本的循环渲染--&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr *ngFor=&quot;let data of arr&quot;&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.sex&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 在ngFor中使用索引值 let i = index 这部分和vue稍微有所区别 12345678910&lt;!--循环渲染 添加索引值--&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr *ngFor=&quot;let data of arr let i = index&quot;&gt; &lt;td&gt;&#123;&#123;i&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.sex&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 使用索引值的另外一种方式 123&lt;ul&gt; &lt;li *ngFor=&quot;let data of arr; index as i&quot;&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt; &lt;/ul&gt; 可以在此基础上添加一些事件处理的逻辑 在这里可以尝试一下使用ng2Pro的形式实现一下类似于vue之中的数据的增删改查 ngIf 条件渲染 类似于vue中的v-if (v-else-if v-else v-show),能够根据条件判断是否渲染当前元素 12345&lt;div *ngIf=&quot;bool&quot;&gt; &lt;p&gt;这是一个p标签&lt;/p&gt; &lt;/div&gt; 描述: 当定义的数据 bool的值是true的时候,当前元素会显示 否则隐藏 else效果 在angular4中,新增else效果(使用模板变量#name) 1234&lt;button (click)=&quot;isShowElse = !isShowElse&quot;&gt;点击试试ngIf else&lt;/button&gt; &lt;div *ngIf=&quot;isShowElse else next&quot;&gt;ngIf结构型指令中的else&lt;/div&gt; &lt;ng-template #next&gt;else效果&lt;/ng-template&gt; 补充 ng-container元素会将其里面的内容插入或移除，但ng-container元素不会出现在页面里。 1&lt;ng-container *ngIf=&quot;isShow&quot;&gt;&lt;/ng-container&gt; 样式的添加 有两种方式 1.直接使用属性绑定2.使用ngClass 和 ngStyle 类样式ngClass 123456&lt;button [ngClass]=&quot;&apos;test&apos;&quot;&gt;click&lt;/button&gt;&lt;button [ngClass]=&quot;&apos;test test1&apos;&quot;&gt;click&lt;/button&gt;//只有当isTrue变量的值为true时，active样式类才会添加到div上&lt;div [ngClass]=&quot;&#123;active: isTrue&#125;&quot;&gt;Active类&lt;/div&gt; 单个类样式 在vue中使用v-bind绑定属性,在ng2Pro中使用的是[]的形式进行属性的绑定 12345&lt;div [class.bg]=&apos;bool&apos;&gt; &lt;p&gt;这是一个p标签&lt;/p&gt; &lt;/div&gt; 描述: 当定义的bool值或者是逻辑表达式为true的时候,给div添加bg这个类样式 行内样式ngStyle 1&lt;button [ngStyle]=&quot;&#123;&apos;width&apos;:&apos;100px&apos;&#125;&quot;&gt;click&lt;/button&gt; 行内样式 123456&lt;!-- 直接绑定行内样式 --&gt;&lt;button [style.color] = &quot;isSpecial ? &apos;red&apos;: &apos;green&apos;&quot;&gt;红色&lt;/button&gt; &lt;button [style.background-color]=&quot;canSave ? &apos;cyan&apos;: &apos;grey&apos;&quot; &gt;保存&lt;/button&gt;&lt;!-- 带有单位的样式绑定 --&gt;&lt;button [style.font-size.em]=&quot;isSpecial ? 3 : 1&quot; &gt;大&lt;/button&gt;&lt;button [style.font-size.%]=&quot;!isSpecial ? 150 : 50&quot; &gt;小&lt;/button&gt; 事件操作 在vue中, 使用v-on的形式进行事件的绑定 12//点击按钮的时候,执行fn方法&lt;button v-on:click=&quot;fn()&quot;&gt;click&lt;/button&gt; 在ng2Pro中 1234567//点击按钮的时候,执行fn方法&lt;button (click)=&quot;fn()&quot;&gt;click&lt;/button&gt;&lt;button on-click=&quot;fn()&quot;&gt;click&lt;/button&gt;//使用原生js的事件操作,需要传递特殊的事件参数&lt;button on-click=&quot;fn($event)&quot;&gt;click&lt;/button&gt; 属性操作 在vue中使用的是v-bind,在ng2Pro中使用的是[] 1234//变量imgSrc在ts文件中定义&lt;img [src]=&quot;src&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;&#123;&#123;src&#125;&#125;&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;../../assets/favicon.ico&quot; alt=&quot;&quot; /&gt; ngSwitch 当需要从一组可能的数据中选择其中的一个的时候,就要用到ngSwitch 1234567&lt;ul [ngSwitch]=&apos;item&apos;&gt; &lt;li *ngSwitchCase=&quot;&apos;王&apos;&quot;&gt;王&lt;/li&gt; &lt;li *ngSwitchCase=&quot;&apos;李&apos;&quot;&gt;李&lt;/li&gt; &lt;li *ngSwitchCase=&quot;&apos;吾&apos;&quot;&gt;吾&lt;/li&gt; &lt;li *ngSwitchCase=&quot;&apos;刘&apos;&quot;&gt;刘&lt;/li&gt; &lt;li *ngSwitchDefault&gt;哈哈哈哈&lt;/li&gt;&lt;/ul&gt; 当item = “王”的时候,只显示王…… 综合练习投票1.案例效果图 2.题目要求 12345完成列表渲染数据的添加列表的排序 增删改查1.案例效果图 2.题目要求 123456789101112131415161718191.使用正确的命令渲染列表数据2.双向数据绑定引入正确的模3.正确的使用双向数据绑定4.正确的进行商品名模糊搜索5.正确的进行价格区间查询6.正确的进行商品名和价格区间的联合查询7.清空条件后回复列表数据8.新增商品9.编辑商品10.删除商品","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"05-插件使用第一种方式","slug":"angular2/05-bootstrap和jquery的使用","date":"2018-05-10T00:36:04.988Z","updated":"2018-05-10T01:29:02.715Z","comments":true,"path":"2018/05/10/angular2/05-bootstrap和jquery的使用/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/05-bootstrap和jquery的使用/","excerpt":"","text":"ng2Pro中插件的使用第一种方式 也是一种较为麻烦的方式,不过也是推荐使用的方式 以bootstrap 和 jquery为例 1.安装bootstrap和jquery 12npm install bootstrap--save npm install jquery --save 2.在.angular-cli.json文件，添加bootstrap和jQuery 12345678&quot;styles&quot;: [ &quot;styles.css&quot;, &quot;../node_modules/bootstrap/dist/css/bootstrap.css&quot;],&quot;scripts&quot;: [ &quot;../node_modules/jquery/dist/jquery.js&quot;, &quot;../node_modules/bootstrap/dist/js/bootstrap.js&quot;], 3.在typescript环境中使用bootstrap和jquery 需要安装两个依赖,否则的话,不能够识别在jquery的bootstrap中的js语法 12npm install @types/bootstrap --save-devnpm install @types/jquery --save-dev 4.声明 使之成为一个可用的变量 12345declare var $:any;或者是import * as $ from &apos;jquery&apos;; 第二种使用的方式 这种方式比较简单,但是不推荐使用 其他插件的使用方式类似 1.直接在index.html文件中引入相关文件 12345&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; 2.在使用的地方进行声明,使之成为一个可用的变量 12345declare var $:any;或者是import * as $ from &apos;jquery&apos;;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"04-项目启动","slug":"angular2/04-项目启动过程","date":"2018-05-10T00:36:04.983Z","updated":"2018-05-10T01:28:55.076Z","comments":true,"path":"2018/05/10/angular2/04-项目启动过程/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/04-项目启动过程/","excerpt":"","text":"项目启动 整个angular项目的启动是从.angular-cli.json文件开始的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123; &quot;project&quot;: &#123; &quot;version&quot;: &quot;1.0.0-beta.28.3&quot;, &quot;name&quot;: &quot;test1&quot; &#125;, &quot;apps&quot;: [ &#123; &quot;root&quot;: &quot;src&quot;, &quot;outDir&quot;: &quot;dist&quot;, &quot;assets&quot;: [ &quot;assets&quot;, &quot;favicon.ico&quot; ], &quot;index&quot;: &quot;index.html&quot;, //--------------------------------------------项目的启动从index.html &quot;main&quot;: &quot;main.ts&quot;, //--------------------------------------------项目启动的脚本文件 &quot;polyfills&quot;: &quot;polyfills.ts&quot;, &quot;test&quot;: &quot;test.ts&quot;, &quot;tsconfig&quot;: &quot;tsconfig.json&quot;, &quot;prefix&quot;: &quot;app&quot;, &quot;styles&quot;: [ &quot;styles.css&quot; ], &quot;scripts&quot;: [], &quot;environments&quot;: &#123; &quot;source&quot;: &quot;environments/environment.ts&quot;, &quot;dev&quot;: &quot;environments/environment.ts&quot;, &quot;prod&quot;: &quot;environments/environment.prod.ts&quot; &#125; &#125; ], &quot;e2e&quot;: &#123; &quot;protractor&quot;: &#123; &quot;config&quot;: &quot;./protractor.conf.js&quot; &#125; &#125;, &quot;lint&quot;: [ &#123; &quot;files&quot;: &quot;src/**/*.ts&quot;, &quot;project&quot;: &quot;src/tsconfig.json&quot; &#125;, &#123; &quot;files&quot;: &quot;e2e/**/*.ts&quot;, &quot;project&quot;: &quot;e2e/tsconfig.json&quot; &#125; ], &quot;test&quot;: &#123; &quot;karma&quot;: &#123; &quot;config&quot;: &quot;./karma.conf.js&quot; &#125; &#125;, &quot;defaults&quot;: &#123; &quot;styleExt&quot;: &quot;css&quot;, &quot;prefixInterfaces&quot;: false, &quot;inline&quot;: &#123; &quot;style&quot;: false, &quot;template&quot;: false &#125;, &quot;spec&quot;: &#123; &quot;class&quot;: false, &quot;component&quot;: true, &quot;directive&quot;: true, &quot;module&quot;: false, &quot;pipe&quot;: true, &quot;service&quot;: true &#125; &#125;&#125; 1.从main.ts和index.html开始启动项目 整个项目的启动是从main.ts文件开始的,main.ts的文件内容如下所示,可能部分内容是有所区别的,但是问题不到(版本原因)index.html文件是项目启动的参考文件 main.ts的文件内容如图所示 1234567891011121314151617181920212223//导入一些必要的库,以便于兼容,使angular能够正常运行在常见的浏览器import &apos;./polyfills.ts&apos;//使用什么模块启动整个应用import &#123; platformBrowserDynamic &#125; from &apos;@angular/platform-browser-dynamic&apos;;//开发者模式是否启用import &#123; enableProdMode &#125; from &apos;@angular/core&apos;;//导入环境配置,在打包部署的时候会用到import &#123; environment &#125; from &apos;./environments/environment&apos;;//导入主模块import &#123; AppModule &#125; from &apos;./app/app.module&apos;;//如果当前是生产环境,关闭开发者模式if (environment.production) &#123; enableProdMode();&#125;//整个程序从这个位置开始启动platformBrowserDynamic().bootstrapModule(AppModule); index.html文件 在这个文件的内容里面有一个 Loading… 这个东西你可以理解为组件的名称,具体的内容在跟组件中可以找到依据 就是类似于vue的组件和组件民,这部分定义的是显示组件的位置,也就是组件的名称 2.项目的启动从主模块开始123456789101112131415161718192021222324252627//导入一些必要的包import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; FormsModule &#125; from &apos;@angular/forms&apos;;import &#123; HttpModule &#125; from &apos;@angular/http&apos;;import &#123; AppComponent &#125; from &apos;./app.component&apos;;//模块元素装饰器,可以理解为是向模块里面添加内容的@NgModule(&#123; //声明模块中拥有的内容,在这一部分,只能声明组件,指令和管道 declarations: [ AppComponent ], //导入需要的依赖内容----模块 imports: [ BrowserModule, FormsModule, HttpModule ], //在这里声明提供的服务 providers: [], //声明主组件 bootstrap: [AppComponent]&#125;)//导出一个模块export class AppModule &#123; &#125; 3.在主模块中,加载了主组件1234567891011121314//定义组件,需要导入一个组件装饰器import &#123; Component &#125; from &apos;@angular/core&apos;;//组件元数据装饰器,会将元数据附加到typescript类中@Component(&#123; selector: &apos;app-root&apos;, //组件名称----在index.html页面,组件名作为标签显示到页面上 //template: &apos;&lt;p&gt;&#123;&#123;title&#125;&#125;&lt;p/&gt;&apos;, //组件内容 templateUrl: &apos;./app.component.html&apos;, styleUrls: [&apos;./app.component.css&apos;] //组件样式&#125;)export class AppComponent &#123; title = &apos;app works!&apos;; //组件要处理的业务逻辑部分(数据--方法---属性)&#125; 主组件和样式文件 app.component.html 和 app.component.css 在主模块中使用的内容 和 样式文件 //将主模块中的数据渲染到 app.component.html 页面上 &lt;h1&gt;{{title}}&lt;/h1&gt;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"03-项目简介","slug":"angular2/03-项目目录结构解析","date":"2018-05-10T00:36:04.978Z","updated":"2018-05-10T01:28:37.059Z","comments":true,"path":"2018/05/10/angular2/03-项目目录结构解析/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/03-项目目录结构解析/","excerpt":"","text":"项目简介目录介绍1234567891.e2e end to end 端到端的测试目录2.src目录 这个应用的源代码文件3.karam 配置文件,自动化测试4.protractor 配置文件 ,和karam类似 , 做自动化测试5.tslint typescript语法检测 重点 src目录123456789101112131.app目录 ,代码一般都是写在这个目录,包含应用的模块和组件2.assets: 静态资源目录3.environments目录, 开发环境配置,支持多环境开发4.index.html 整个应用的根html,整个应用就是从这个文件开始的------------&lt;app-root&gt;&lt;/app-root&gt;5.main.ts 脚本执行的入口点,从这个文件启动ng应用程序6.polyfile.ts 导入的一些库,可以做一些兼容方面的内容,也就是运行在低版本浏览器7.style.css 定义全局的样式","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"02-开发环境","slug":"angular2/02-开发环境搭建","date":"2018-05-10T00:36:04.973Z","updated":"2018-05-10T01:28:51.296Z","comments":true,"path":"2018/05/10/angular2/02-开发环境搭建/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/02-开发环境搭建/","excerpt":"","text":"开发环境搭建开发环境基本环境需求1.安装nodejs 2.全局安装@angular/cli 1234567npm install -g angular-clinpm install -g @angular/cli 新版本npm install -g @angular/cli@latest 最近更新的版本-推荐使用npm install -g @angular/cli@1.3.1 安装指定的版本 3.安装成功,使用ng -v命令查看版本,成功的话就可以正常创建我们的项目了 12查看版本命令行: ng -v 4.项目的创建 123使用以下命令进行项目的创建 ng new projectName 5.切换目录 1cd projectName 6.启动服务 启动成功后可以看到ng的标识 12345678//需要手动输入主机名和端口号ng serve//自动打开浏览器ng serve -o // 生成最小化的测试单元ng serve --prod --aot 7.项目打包 将做好的项目进行打包 1234ng build// 生成最小化的包,抛弃一些无用的单元/模块ng build --prod --aot 其他命令1234567891011121314151. 创建组件 ng g component componentName2. 创建服务 ng g service serviceName3. 创建指令 ng g directive directiveName4. 创建管道 ng g pipe pipeName5. 创建类 ng g class className6. 创建接口 ng g intetrface interfaceName7. 创建枚举 ng g enum enumName8. 创建模块 ng g module moduleName 关于安装过程中的小问题1.速度慢 123456789切换配置源,默认使用淘宝镜像: npm config set registry https://registry.npm.taobao.org 淘宝镜像安装 npm install -g cnpm --registry=https://registry.npm.taobao.org升级淘宝镜像 cnpm install cnpm -g 2.cnpm 建议不要使用cnpm进行安装,在使用的时候可能会有一些小问题 能够使用npm的尽量使用npm进行,实在安装不上的话,再使用cnpm 安装报错可以尝试一下操作 1234567891011121.先卸载包 npm uninstall -g @angular/cli2.强制清缓存 旧版本: npm cache clean 新版本: npm cache clean --force 3.重新安装 npm install -g @angular/cli@latest","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"01-angular概述","slug":"angular2/01-简介","date":"2018-05-10T00:36:04.968Z","updated":"2018-05-10T01:28:23.565Z","comments":true,"path":"2018/05/10/angular2/01-简介/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/01-简介/","excerpt":"","text":"angular概述test angular简介 angular2Pro使用typescript,typescript是angular2Pro应用程序的主要开发语言 知识点概述12345678910111213141.路由2.依赖注入----编写可重用组件3.绑定,响应式编程和管道4.组件通信5.表单处理6.与服务器通信7.构建和部署 angular架构 12345671. 模块: angular必须包含一个模块,模块用来将应用中不同的组织组成一个angular框架可以理解的单元 2. 组件是基本组成部分,也就是angular的基本构建块可以理解为一段具有业务逻辑和数据的html3. 服务:用来封装可以重用的业务逻辑4. 指令: 允许你向html添加自定义行为 与vue的对比vue123456789101112优点: 1.小型 2.灵活 3.性能--虚拟dom小问题: 1.个人主导 2.只关注于web 3.vue本身不支持服务器端渲染","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"ts简单总结","slug":"ts/07-简单总结/07-简单总结","date":"2018-05-10T00:35:41.599Z","updated":"2018-05-10T01:03:01.085Z","comments":true,"path":"2018/05/10/ts/07-简单总结/07-简单总结/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/07-简单总结/07-简单总结/","excerpt":"","text":"ts简单总结 类型注解 声明一个变量 提前确定类型 1234567891011121314151617181920// 基本的类型注解 number string boolean null undefined var a:number = 10//对象的类型注解 object(function array) public $http:Http --- public routerInfo:ActivatedRoute ---// 补充any enumdeclare var $:any; ----declare var Swiper:any; ----var arr:enum // 这是枚举类型 模块化语法 1234567891011121314151617181920212223242526272829303132333435 导入 import &#123;Tab1Component&#125; from &quot;路径&quot; 导出 export class Tab1Component&#123;&#125; 导入重命名语法 import &#123;Tab1Component as tab1&#125; from &quot;路径&quot; 在vue单文件组件中 导出 export default &#123;&#125; 导入 import aaa from &apos;./components/01-head/head.vue&apos;1. 单个export 导出 导出的是单个变量 需要使用 &#123;&#125;2. 使用export default 导出的是当前的所有 内容 是一个集合 export default &#123; name: &apos;app&apos;, data() &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, created()&#123; &#125;, methods:&#123; &#125; &#125;3. 使用export 导入和导出名称要一致4. 使用export default 名称可以随便命名 let const var 123456let 定义变量 ----- 局部作用域var 定义变量 ------ 全局作用域const 定义常量,声明只读关键字 class 123456789101112定义类 class Parent&#123;&#125; class Tab1Component&#123;&#125;继承类 class Child extends Parent&#123;&#125;类的成员属性 public private protected static readonly 装饰器 123456789101112@Component@NgModule@Pipe@Input@Output@inject 浏览器: 浏览器支持 html css js es6 .ts 浏览器不完全支持 es6 使用babel-loader 将es6转化为es5 浏览器不支持ts 需要使用typescript包将ts转化为es5","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"07-简单总结","slug":"ts/07-简单总结","permalink":"http://yoursite.com/categories/ts/07-简单总结/"}],"tags":[]},{"title":"装饰器","slug":"ts/06-装饰器/06-装饰器","date":"2018-05-10T00:35:41.581Z","updated":"2018-05-10T01:02:55.534Z","comments":true,"path":"2018/05/10/ts/06-装饰器/06-装饰器/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/06-装饰器/06-装饰器/","excerpt":"","text":"装饰器 以@开头 装饰即附加内容 这一部分知识在后期讲解","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"06-装饰器","slug":"ts/06-装饰器","permalink":"http://yoursite.com/categories/ts/06-装饰器/"}],"tags":[]},{"title":"模块化","slug":"ts/05-模块化/05-模块化","date":"2018-05-10T00:35:41.550Z","updated":"2018-05-10T01:02:51.412Z","comments":true,"path":"2018/05/10/ts/05-模块化/05-模块化/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/05-模块化/05-模块化/","excerpt":"","text":"模块化 重点是模块的导入和导出 import 和 export 基本使用导出 在ModuleA.js导出内容 12345678//导出变量 export var a = 10//导出函数 export function fn()&#123;&#125;//导出类 export class Parent&#123;&#125; 导入 在另一个文件中导入 12345678//导出单个变量import &#123;a&#125; from &quot;ModuleA&quot;import &#123;a,fn&#125; from &quot;ModuleA&quot;//导入类import &#123;Parent&#125; from &quot;ModuleA&quot; 导入重命名语法 as语法 123456//导入jquery所有内容重命名为$import * as $ from &quot;jquery&quot; //将变量a重命名为bimport &#123;a as b&#125; from &quot;moduleA&quot;","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"05-模块化","slug":"ts/05-模块化","permalink":"http://yoursite.com/categories/ts/05-模块化/"}],"tags":[]},{"title":"类和继承","slug":"ts/04-类/04-类","date":"2018-05-10T00:35:41.522Z","updated":"2018-05-10T01:02:47.540Z","comments":true,"path":"2018/05/10/ts/04-类/04-类/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/04-类/04-类/","excerpt":"","text":"类和继承12345678class : 封装/继承 特点: 可以书写属性和方法 能够实现继承 能够实例化 基本知识点123456789101112131415161718192021书写方式 class className&#123; &#125;构造函数 construct()&#123;&#125; 在创建实例的时候,这个函数会默认执行成员类型 public 默认的/公共的 所有实例都能访问 private 私有的 只有在class中使用 protected 受保护的 实例下不能用 在子类中能够使用 static 声明静态成员 js使用原型模拟类1.扩展原型 1234567function Person(name) &#123; this.name = name;&#125;Person.prototype.say = function()&#123;&#125;Person.prototype.toString = function()&#123;&#125;Person.prototype.toString1 = function()&#123;&#125;Person.prototype.toString2 = function()&#123;&#125; 2.替换原型 123456Person.prototype = &#123; constructor: function () &#123; &#125;, toString: function () &#123; &#125;, toValue: function () &#123; &#125;, say: function () &#123;console.log(&quot;考试一团糟&quot;);&#125;&#125;; 3.函数名称简写 类的雏形由此而来 123456Person.prototype = &#123; constructor () &#123; &#125;, toString () &#123; &#125;, toValue () &#123; &#125;, say () &#123;console.log(&quot;考试一团糟&quot;);&#125;&#125;; 类的定义123456789101112131415class Person &#123; //构造函数会默认执行 constructor () &#123; console.log(1) &#125; toString() &#123;&#125; toValue() &#123;&#125; say()&#123; console.log(&quot;考试一团糟&quot;) &#125;&#125; 存取器 设置/获取值的时候自动调用相关的方法 123456789101112class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &apos;getter&apos;; &#125; set prop(value) &#123; console.log(&apos;setter: &apos;+value); &#125;&#125; 继承的实现 super 123456789101112131415161718192021222324//类的实现 class Person &#123; public name: string; constructor(name: string) &#123; this.name = name; &#125; &#125; class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; //继承父类的内容 super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125; &#125; let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;); console.log(howard.getElevatorPitch()); console.log(howard.name); // error","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"04-类","slug":"ts/04-类","permalink":"http://yoursite.com/categories/ts/04-类/"}],"tags":[]},{"title":"接口","slug":"ts/03-接口/03-接口","date":"2018-05-10T00:35:41.413Z","updated":"2018-05-10T01:02:43.911Z","comments":true,"path":"2018/05/10/ts/03-接口/03-接口/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/03-接口/03-接口/","excerpt":"","text":"接口什么是接口 方法-索引-事件-属性的集合 在编程中,接口就是一个抽象的数据类型,使用interface声明 接口不能像对象那样实例化,只能被继承 1234interface Person &#123; firstName: string; lastName: string;&#125; 为什么使用接口 一些抽象的方法和特征的集合,可以通过 继承接口的方式,来继承接口中的属性和方法 可以有效的减少代码的冗余 接口的特点 1234书写形式上和class很相似封装属性和方法不能实例化,只能被继承默认所有的属性必须全部被实现 / 如果不全部实现,添加 ? 接口补充 在默认的情况下,接口里面的内容必须都被实现 123只读属性 readonly可选属性 ? 接口的基本使用 在js中实现一个接口 123456789101112interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;&#125;var user = &#123; firstName: &quot;Jane&quot;, lastName: &quot;User&quot; &#125;;document.body.innerHTML = greeter(user); 和其他语言有区别 我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements语句。 接口的实现 除了上述使用的方式之外,也可以使用implements的方式来实现接口 实现接口之后,可以使用接口里面所有的属性和方法 123456789interface parent&#123;&#125;//继承接口之后,可以实现接口里面的属性和方法class child implements parent&#123;&#125; 补充123456789101112131415161718192021221. 正常的接口定义 interface Person &#123; firstName: string; lastName: string; &#125;2. 接口的可选属性定义 interface SquareConfig &#123; color?: string; width?: number; &#125;3. 接口的只读属性定义 interface Point &#123; readonly x: number; readonly y: number; &#125;4. 函数类型的接口 interface SearchFunc &#123; (source: string, subString: string): boolean; &#125;","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"03-接口","slug":"ts/03-接口","permalink":"http://yoursite.com/categories/ts/03-接口/"}],"tags":[]},{"title":"强类型和类型注解","slug":"ts/02-类型注解/02-类型注解","date":"2018-05-10T00:35:41.401Z","updated":"2018-05-10T01:02:40.320Z","comments":true,"path":"2018/05/10/ts/02-类型注解/02-类型注解/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/02-类型注解/02-类型注解/","excerpt":"","text":"强类型和类型注解js本身是一种弱类型的语言 123没有严格的变量声明规范变量的类型根据变量的值确定现有变量值,再有变量类型 强类型 类似于c语言 java…. 在变量定义的时候确定变量的类型 对变量加以严格约束 123456int : 整型float: 浮点型double : 双精度 .............. 在ts中使用类型注解的形式显示语言强类型 什么是类型注解 TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式 在定义变量的时候添加类型注解,可以预防一些编译时的错误 js类型类型 在讲解typescript的基础数据类型之前,先看一下js的数据类型 js的六大数据类型: js中有六种数据类型，包括五种基本数据类型（Number,String,Boolean,Null,Undefined）,和一种混合数据类型（Object）。 typescript支持的数据类型和JavaScript基本上完全相同 在此基础上增加了枚举数据类型以方便我们使用 常见数据类型的类型注解1.boolean 12//添加类型注解----当前的数据类型值只能是boolean类型let bool:boolean = false 2.number 12//添加类型注解 ---- 当前的数据类型只能是数字类型let num:number = 1 3.string 123//添加类型注解----当前的数据类型只能是字符串类型----在此基础上,还支持模板字符串的使用let str:string=&quot;坏孩子&quot;let sentence = `我们都是$&#123;str&#125;,我们都是坏孩子` 4.null和undefined 1let n:null = null 5.undefined 1let u:undefined = undefined 6.array 12345678910//定义数组并添加类型注解的形式 //添加类型注解,数组里面的元素只能是数字类型 ---- 这是第一种方式 let arr:number[] = [1,2,3] // 使用数组泛型 ---- 这是第二种方式 let arr:Array&lt;number&gt; = [1,2,3]//定义元组Tuple----元组里面的数据可以是不同的数据类型let x: [string, number] = [&quot;1&quot;,2] 类型注解补充1.enum 枚举 可以简单理解为遍历 12345678910111213141516//在默认的情况下,从0开始赋予编号,也可以手动指定成员的数值,进行手动编号enum Color &#123;Red, Green, Blue&#125;//(function (Color) &#123;// Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;;// Color[Color[&quot;Green&quot;] = 1] = &quot;Green&quot;;// Color[Color[&quot;Blue&quot;] = 2] = &quot;Blue&quot;;//&#125;)(Color || (Color = &#123;&#125;));let c: Color = Color.Green;console.log(Color)//手动设置成员的编号enum Color &#123;Red = 1, Green, Blue&#125; 2.any 不对变量的值进行检查,也就是说变量的值可以是任意类型的 1let notSure: any = 4; 3.void 1234有参数 有返回值有参数 无返回值无参数 有返回值无参数 无返回值 在定义一个函数的时候 如果有个函数没有返回值,可以使用void声明 给一个变量使用类型注解的时候没有太大意义,只能给值 undefined / null 1function fn:void &#123; &quot;这是函数体&quot;&#125; 4.never never类型表示的是哪些永不存在的值 never可以赋值个任何类型,任何类型的值都不能赋值给never never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(&quot;Something failed&quot;);&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 5.断言 断言好比类型转换,但是不进行特殊的数据检查和解构 1234//&lt;&gt;语法let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length; 1234//as语法let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 一个简单的例子123456789101112//在这里,传递参数的时候给这个参数添加一个类型:stringfunction greeter(person:string) &#123; return &quot;Hello, &quot; + person;&#125;//var user = &quot;Jane User&quot;;//在这里,尝试修改一些user的值变成一个数组var user = [1,2,3]document.body.innerHTML = greeter(user); 上述代码在编译的过程中会发生错误 TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。 1greeter.ts(11,35): error TS2345: Argument of type &apos;number[]&apos; is not assignable to parameter of type &apos;string&apos;. 要注意的是尽管有错误，greeter.js文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行。 知识点补充基本数据类型和复杂数据类型 检测基本数据类型: typeof检测复杂数据类型: instanceof 补充1 123456789101112typeof 1 ----- numbertypeof 1 + &quot;2&quot; ----- number2typeof -&apos;2&apos; ----- numbertypeof 1-&apos;2&apos; ----- number-&quot;2&quot; NaNtypeof null objecttypeof undefined undefinednull==undefined truenull===undefined false 补充2 12345678910111213141516function fn()&#123;&#125;fn instanceof Function[] instanceof Array&#123;&#125; instanceof Object特殊 : Function 所有的函数都是直接或者是间接通过Function构造函数创建 对象Object也是由Function构造函数创建","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"02-类型注解","slug":"ts/02-类型注解","permalink":"http://yoursite.com/categories/ts/02-类型注解/"}],"tags":[]},{"title":"typescript知识点","slug":"ts/01-ts入门/01-typescript入门","date":"2018-05-10T00:35:41.384Z","updated":"2018-05-10T01:02:36.215Z","comments":true,"path":"2018/05/10/ts/01-ts入门/01-typescript入门/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/01-ts入门/01-typescript入门/","excerpt":"","text":"typescript知识点typescript什么是typescript TypeScript 是一种由微软开发的自由和开源的编程语言，它是JavaScript的一个超集，扩展了JavaScript的语法。 语法特性123456类 Classes接口 Interfaces模块 Modules 类型注解 Type annotations编译时类型检查 Compile time type checking Arrow 函数 (类似 C## 的 Lambda 表达式) JavaScript 与 TypeScript 的区别 TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。 开始使用typescript1.使用npm安装 1npm install -g typescript 2.构建第一个typescript文件 命名为 test.ts文件,写入一下内容 1234567function greeter(person) &#123; return &quot;Hello, &quot; + person;&#125;var user = &quot;Jane User&quot;;document.body.innerHTML = greeter(user); 3.编译 .ts文件 在执行 .ts文件之前,需要将 .ts文件 编译为 .js文件 1tsc test.ts 执行以上命令,可以将 test.ts文件转化为同名的 test.js文件 4. 使用 创建有个html文件,引入test.js文件","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"01-ts入门","slug":"ts/01-ts入门","permalink":"http://yoursite.com/categories/ts/01-ts入门/"}],"tags":[]},{"title":"06-主题设置","slug":"ionic2/06-主体化","date":"2018-05-10T00:35:17.973Z","updated":"2018-05-10T01:27:54.235Z","comments":true,"path":"2018/05/10/ionic2/06-主体化/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/06-主体化/","excerpt":"","text":"主题设置 在ionic中提供了快速定义主题的方式 自定义主题参考链接 自定义一套ionic主题 主题修改 项目目录 src/theme/variables.scss 件中的$colors 你可以在这里定制你的主题 1.样式修改 2.变量定义 使用$定义变量 可以使用多次 文字修改1234567891011121314文本对齐 text-left text-right text-start text-end text-center text-justify text-wrap text-nowrap文本转换 text-uppercase text-lowercase text-capitalize响应文本属性 text-&#123;modifier&#125; 在所有屏幕尺寸上将修饰符应用于元素。 text-sm-&#123;modifier&#125; 将修饰符应用于元素min-width: 576px。 text-md-&#123;modifier&#125; 将修饰符应用于元素min-width: 768px。 text-lg-&#123;modifier&#125; 将修饰符应用于元素min-width: 992px。 text-xl-&#123;modifier&#125; 将修饰符应用于元素min-width: 1200px。 元素放置1234567891011浮动元素 float-left float-right float-start float-end响应浮动属性 float-&#123;modifier&#125; 在所有屏幕尺寸上将修饰符应用于元素。 float-sm-&#123;modifier&#125; 将修饰符应用于元素min-width: 576px。 float-md-&#123;modifier&#125; 将修饰符应用于元素min-width: 768px。 float-lg-&#123;modifier&#125; 将修饰符应用于元素min-width: 992px。 float-xl-&#123;modifier&#125; 将修饰符应用于元素min-width: 1200px。 元素填充123456789padding padding: 16px 适用于各方面的填充。padding-top padding-top: 16px 将填充应用到顶部。padding-left padding-left: 16px 在左侧应用填充。padding-right padding-right: 16px 在右侧应用填充。padding-bottom padding-bottom: 16px 将填充应用于底部。padding-vertical padding: 16px 0 将填充应用于顶部和瓶颈。padding-horizontal padding: 0 16px 适用于左侧和右侧的填充。no-padding padding: 0 适用于所有方面的填充。 外边距12345678margin margin: 16px 适用于各方面。margin-top margin-top: 16px 应用边缘到顶部。margin-left margin-left: 16px 在左边应用边距。margin-right margin-right: 16px 适用于右侧的保证金。margin-bottom margin-bottom: 16px 将余量应用到底部。margin-vertical margin: 16px 0 应用顶部和瓶颈的余量。margin-horizontal margin: 0 16px 应用左边和右边的边距。no-margin margin: 0 对各方没有利润。 动态属性 通过动态设置CSS属性，可以根据特定条件从组件添加或删除功能。要动态设置属性，请使用以下语法： 1&lt;div [attr.text-center]=&quot;isMD ? &apos;&apos; : null&quot;&gt;I will be centered when isMD is true.&lt;/div&gt; 平台样式 ionic是一个跨平台的框架,针对于不同的平台设置了不同的样式 1234567 android: md ios: ios window:wp 不符合的以上三种/core: md默认的平台样式也是md 课程重点/考点1234567891011121314151617主题使用 theme/.sasssass--less变量 定义 sass $ less @工具属性平台样式样式覆写 css层叠特性 css优先级 !important&gt;行内&gt;id&gt;类&gt;标签动态属性 什么是动态属性","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"05-导航","slug":"ionic2/05-组件补充","date":"2018-05-10T00:35:17.962Z","updated":"2018-05-10T01:27:45.381Z","comments":true,"path":"2018/05/10/ionic2/05-组件补充/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/05-组件补充/","excerpt":"","text":"navigation/导航详情参考官网api文档 使用这一部分内容基本可以替代路由操作 导航的使用 可以将所有的页面理解为一个栈的结构 实现页面的导航,也就是出栈和入栈的过程 基本导航的实现三步操作 1231. 导入控制器类2. 注入到构造函数3. 调用方法 1.导入控制器类 1import &#123; NavController &#125; from &apos;ionic-angular&apos;; 2. 注入到构造函数 注入多个内容,中间使用逗号隔开 1constructor(public navCtrl: NavController) &#123;&#125; 3.调用方法 可以实现基本导航,也可以实现像路由跳转那样进行参数的传递 1234567891011121314151617//在html页面调用这个函数即可实现基本导航操作pushPage()&#123; //这里OtherPage指代的是你需要导航到的页面,这个页面需要自己手动创建 //页面创建完成之后需要在根模块完成配置并导入到当前页面 this.navCtrl.push(OtherPage); &#125;//在进行页面导航的时候还可以进行参数传递 pushPage()&#123; //在进行页面导航的时候传递id参数和name参数 this.navCtrl.push(OtherPage, &#123; id: &quot;123&quot;, name: &quot;Carl&quot; &#125;); &#125; 路由导航参数的获取 在页面导航的时候,如果需要进行参数的传递,在已传递参数的情况下,可以在导航到的页面获取之前传递的参数 比如在上述示例中导航到OtherPage页面,可以在这个页面获取到传递过来的参数 1.导入控制器类 1import &#123; NavParams &#125; from &apos;ionic-angular&apos;; 2.注入到构造函数1constructor(private navParams: NavParams) &#123;&#125; 3.调用方法 12//获取传递的id参数this.navParams.get(&apos;id&apos;); 从根组件开始导航12345678910111213141. 导入控制器 import &#123; Component, ViewChild &#125; from &apos;@angular/core&apos;; import &#123; NavController &#125; from &apos;ionic-angular&apos;;2. 注入 使用ViewChild @ViewChild(&apos;myNav&apos;) nav: NavController 3. 调用方法 this.nav.push(Page1); //导航到Page1页面,这个页面需要手动生成并完成配置 导航移除 从栈中移除导航的页面 12345678910111. 导入控制器 import &#123; NavController &#125; from &apos;ionic-angular&apos;;2. 注入 使用ViewChild constructor(public navCtrl: NavController )&#123;&#125; 3. 调用方法 this.navCtrl.pop(); 综合练习手机qq1.案例效果图 2.题目要求 1234567891011121. 点击头像,弹出侧边菜单2. 使用图标组件实现侧边页面布局3. 侧边数据使用ngFor指令渲染4. 侧边列表的实现使用ionic的列表组件5. 实现底部导航6. 在qq首页完成数据渲染7. 使用ngFor指令配合ionic列表组件实现页面布局(avatar)8. 正确使用徽章组件9. 实现页面导航效果----点击钱包,进行页面跳转10. 在聊天页面点击每一条都能够跳转到聊天页面 知识点补充-数据请求数据请求的实现 123456789101112131415161718192021222324252627281.导入请求模块,在angular中,使用什么东西首先要在app.module中导入 import &#123; HttpModule &#125; from &apos;@angular/http&apos;; 并将导入的模块添加到 @NgModule 的 imports中2.在需要的地方导入http模块,也就是说要在哪里发送请求,就在哪里导入http模块(类)即可 import &#123; Http &#125; from &apos;@angular/http&apos;; 3.将到如的模块注入到构造函数中 constructor(private $http: Http) &#123; &#125;4.发送请求,获取数据 ngOnInit() &#123; const url = &quot;http://127.0.0.1/00-exam/1508A/week1/select.php&quot; this.$http.get(url) .subscribe((res)=&gt;&#123; //调用 HTTP 的Reponse对象的json方法，以提取出其中的数据 console.log(res.json()) //将我们读取到的数据赋值给数据并进行渲染就可以了 &#125;) //捕获错误 -------------------------------------根据需要选择 .catch((error)=&gt;&#123; console.log(error) &#125;) &#125; 掌阅读书 使用swipe事件进行操作,模拟实现翻页效果 因为没有可用的数据接口 当滑动的时候加载下一页数据即可 1.案例效果图以及说明 2.要求 1234561.滑动的时候实现翻页效果,翻页数据使用其他的接口进行模拟,重点是实现的思路 //分页数据 //第一页 offet=0 //第二页 offet=6 //第三页 offet=12 //http://musicapi.duapp.com/api.php?type=topPlayList&amp;cat=%E5%85%A8%E9%83%A8&amp;offset=0&amp;limit=6 网易云音乐1.题目描述 可以通过tabsPlacement控制tabs导航显示的位置,默认值是bottom , 还可以是top 请求数据,完成歌单渲染,点击歌单,进入歌曲列表,点击列表,实现音乐播放 2.数据接口 12345678//获取歌单//http://musicapi.duapp.com/api.php?type=topPlayList&amp;cat=%E5%85%A8%E9%83%A8&amp;offset=0&amp;limit=6//获取播放列表详情//https://api.imjad.cn/cloudmusic/?type=playlist&amp;id= 736235890//根据id获取歌曲//http://musicapi.duapp.com/api.php?type=url&amp;id= 739467315 3.效果图 1.歌单页面 2.播放列表页面 和 3.音乐播放页面","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"04-组件使用下","slug":"ionic2/04-ionic组件的使用-下","date":"2018-05-10T00:35:17.953Z","updated":"2018-05-10T01:27:38.500Z","comments":true,"path":"2018/05/10/ionic2/04-ionic组件的使用-下/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/04-ionic组件的使用-下/","excerpt":"","text":"组件使用下 在这一部分,主要是学习ionic标签组件/属性以及其他相关内容的使用 组件工具栏组件 toolbar 将页面按照一定的结构进行划分 1234567891011121314151617181920212223&lt;!--页面头部--&gt;&lt;ion-header&gt; &lt;!--导航组件--&gt; &lt;ion-navbar&gt; &lt;!--标题组件--&gt; &lt;ion-title&gt; Ionic Blank &lt;/ion-title&gt; &lt;/ion-navbar&gt;&lt;/ion-header&gt;&lt;!--页面中间部分--&gt;&lt;ion-content padding&gt;&lt;/ion-content&gt;&lt;!--页面底部--&gt;&lt;ion-footer&gt;&lt;/ion-footer&gt; 补充 123Toolbar可以⽤来当做App的header， sub-header,footer,sub-footer因为ion-toolbar基于flexbox， 所以不管你在⻚⾯中放⼏个Toolbar， 它们都能正确显⽰， ion-content会⾃动调整适应。 ⼀般情况下， NavBar会放在ion-header⾥， ⽤来配合导航。 也可以通过设置color属性来改变toolbar的颜⾊。 当把Toolbar当做footer来⽤的时候， 可以⽤ion-footer来代替ion-toolbar。 列表组件 列表组件通常情况下配合ngFor指令使用 知识点扩展 123456789属性: no-lines:在列表项之间隐藏分隔线 inset: 添加外部边距标签: ion-list-header:添加表头 ion-icon:添加图标 ion-avatar: 添加头像 button/按钮 使用的方式类似于bootstrap,但是在这里是以属性的方式添加 按钮大致可以分为以下几部分 图片/文本/图标…… 123456789101112131415161718192021222324基本按钮 --------------ion-button不能以 标签的形式存在 ion-button &lt;button ion-button&gt;Button&lt;/button&gt;添加颜色 color &lt;button ion-button color=&quot;light&quot;&gt;Light&lt;/button&gt;轮廓 outline &lt;button ion-button color=&quot;light&quot; outline&gt;Light Outline&lt;/button&gt;圆形边框 round &lt;button ion-button color=&quot;light&quot; round&gt;Light Round&lt;/button&gt;清晰风格 clear &lt;button ion-button color=&quot;light&quot; clear&gt;Light Clear&lt;/button&gt;块按钮 block &lt;button ion-button block&gt;Block Button&lt;/button&gt;全按钮 full &lt;button ion-button full&gt;Full Button&lt;/button&gt;按钮大小 large/small &lt;button ion-button large&gt;Large&lt;/button&gt; badges/徽章 Badges(徽章)常常⽤来展⽰给⽤户⼀个数字。 它常⽤于列表项内的数字展⽰。 1234//可以使用color属性指定颜色&lt;ion-badge&gt;&lt;/ion-badge&gt; icon/图标 你可以理解成是通过某种手段绘制出来的东西,只需要会使用即可 12345name属性: 指定图标样式color属性: 指定图标颜色 isActive属性: 指定图标是否激活的状态&lt;ion-icon name=&quot;heart&quot; color=&quot;danger&quot; &gt;&lt;/ion-icon&gt; 更多图标内容请查看此链接 fabs/弹出小图标 可以以更好的体验形式实现页面上常见的分享效果 代码不做详解 123456789101112131415161718192021222324 &lt;ion-content&gt; &lt;!-- Real floating action button, fixed. It will not scroll with the content --&gt; &lt;ion-fab top right edge&gt; &lt;button ion-fab mini&gt;&lt;ion-icon name=&quot;add&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;ion-fab-list&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-facebook&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-twitter&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-vimeo&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-googleplus&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;/ion-fab-list&gt; &lt;/ion-fab&gt; &lt;ion-fab right bottom&gt; &lt;button ion-fab color=&quot;light&quot;&gt;&lt;ion-icon name=&quot;arrow-dropleft&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;ion-fab-list side=&quot;left&quot;&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-facebook&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-twitter&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-vimeo&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-googleplus&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;/ion-fab-list&gt; &lt;/ion-fab&gt;&lt;/ion-content&gt; segment/选项卡/分割 选项卡是借助于switch case实现的 在ionic/angular中,提供了ngSwitch和ngSwitchCase指令 当然,我们也可以使用ngIf实现 下面看一下ionic本身提供的选项卡 代码部分不做过多讲解 1234567891011121314151617181920212223242526272829303132&lt;div padding&gt; &lt;ion-segment [(ngModel)]=&quot;pet&quot;&gt; &lt;ion-segment-button value=&quot;kittens&quot;&gt; Kittens &lt;/ion-segment-button&gt; &lt;ion-segment-button value=&quot;puppies&quot;&gt; Puppies &lt;/ion-segment-button&gt; &lt;/ion-segment&gt;&lt;/div&gt;&lt;div [ngSwitch]=&quot;pet&quot;&gt; &lt;ion-list *ngSwitchCase=&quot;&apos;puppies&apos;&quot;&gt; &lt;ion-item&gt; &lt;ion-thumbnail item-start&gt; &lt;img src=&quot;img/thumbnail-puppy-1.jpg&quot;&gt; &lt;/ion-thumbnail&gt; &lt;h2&gt;Ruby&lt;/h2&gt; &lt;/ion-item&gt; ... &lt;/ion-list&gt; &lt;ion-list *ngSwitchCase=&quot;&apos;kittens&apos;&quot;&gt; &lt;ion-item&gt; &lt;ion-thumbnail item-start&gt; &lt;img src=&quot;img/thumbnail-kitten-1.jpg&quot;&gt; &lt;/ion-thumbnail&gt; &lt;h2&gt;Luna&lt;/h2&gt; &lt;/ion-item&gt; ... &lt;/ion-list&gt;&lt;/div&gt; grid 栅格布局123456789&lt;ion-grid&gt; &lt;ion-row&gt; &lt;!--页面横向分为12部分,每一个占据一半--&gt; &lt;ion-col col-6&gt;&lt;/ion-col&gt; &lt;ion-col col-6&gt;&lt;/ion-col&gt; &lt;/ion-row&gt; &lt;/ion-grid&gt; card/卡片 这一部分完全可以使用自定义样式实现 123456ion-card&gt;ion-card-header+ion-card-content &lt;ion-card&gt; &lt;ion-card-header&gt;&lt;/ion-card-header&gt; &lt;ion-card-content&gt;&lt;/ion-card-content&gt; &lt;/ion-card&gt; gesture/手势 这个组件涉及的是移动端的一些相关的事件操作 具体的使用方式可以参考点击事件 点击事件 1234(click)=&quot;fn()&quot;fn()&#123;console.log(1)&#125; gesture事件 12345678910111213(pan)=&quot;fn()&quot;fn()&#123;console.log(1)&#125;//以下内容自行理解 pan 触屏上手指按下滑动的过程中一直触发 press 按下触发一次 tap 点击 swipe 上下左右滑动 slide/幻灯片/轮播 基本实现 123456789101112131415&lt;ion-slides pager&gt; &lt;ion-slide style=&quot;background-color: green&quot;&gt; &lt;h2&gt;Slide 1&lt;/h2&gt; &lt;/ion-slide&gt; &lt;ion-slide style=&quot;background-color: blue&quot;&gt; &lt;h2&gt;Slide 2&lt;/h2&gt; &lt;/ion-slide&gt; &lt;ion-slide style=&quot;background-color: red&quot;&gt; &lt;h2&gt;Slide 3&lt;/h2&gt; &lt;/ion-slide&gt;&lt;/ion-slides&gt; 更多内容请参考此链接 searchbar/模糊搜索 这一部分不做讲解 使用我们学过的js的相关知识实现 表单1234输入框: ion-input单选框: radio select/下拉框1234567891011121314&lt;ion-list&gt; &lt;ion-item&gt; &lt;ion-label&gt;Gaming&lt;/ion-label&gt; &lt;ion-select [(ngModel)]=&quot;gaming&quot;&gt; &lt;ion-option value=&quot;nes&quot;&gt;NES&lt;/ion-option&gt; &lt;ion-option value=&quot;n64&quot;&gt;Nintendo64&lt;/ion-option&gt; &lt;ion-option value=&quot;ps&quot;&gt;PlayStation&lt;/ion-option&gt; &lt;ion-option value=&quot;genesis&quot;&gt;Sega Genesis&lt;/ion-option&gt; &lt;ion-option value=&quot;saturn&quot;&gt;Sega Saturn&lt;/ion-option&gt; &lt;ion-option value=&quot;snes&quot;&gt;SNES&lt;/ion-option&gt; &lt;/ion-select&gt; &lt;/ion-item&gt;&lt;/ion-list&gt; toggle/开关 看文档 综合练习1.效果图 2.题目描述 12345678功能点1 点击展开左侧菜单功能点2 路由切换功能功能点3 浮动按钮的展功能点4 左侧菜单展开后的头部布功能点5 左侧菜单展开后的主体布功能点6 文件夹的列表获取功能点7 点击标签显示“添加标签让您更容易找到您的笔记”功能点8 近期文章列表里的下拉刷新功","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"03-组件使用上","slug":"ionic2/03-ionic组件的使用-上","date":"2018-05-10T00:35:17.933Z","updated":"2018-05-10T01:27:31.000Z","comments":true,"path":"2018/05/10/ionic2/03-ionic组件的使用-上/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/03-ionic组件的使用-上/","excerpt":"","text":"组件使用上参考链接 下面这几部分内容为讲解的重点 ionic官网 ionic的API文档 ionic主题配置文档 —theme 指令和语法为了更好的使用组件,先讲解一部分基本语法 接触过vue框架的情况下,对于这一部分内容更容易理解 在这里具体的使用方式不再多做讲解 基本语法123456数据显示 &#123;&#123;&#125;&#125;列表渲染 *ngFor=&quot;let data of arr let i=index&quot;条件判断 *ngIf=&apos;bool&apos; 属性绑定 可以有两种实现形式 12&lt;img src=&quot;&#123;&#123;imgUrl&#125;&#125;&quot; alt=&quot;&quot; /&gt;&lt;img [src]=&quot;imgUrl&quot; alt=&quot;&quot; /&gt; 事件绑定 可以有两种实现方式 12on-click=&quot;fn()&quot;(click)=&quot;fn()&quot; 综合练习 使用以上知识点完成一下练习 1234要求: 1. 使用*ngIf实现选项卡切换效果 2. 使用*ngFor指令完成列表渲染和索引值添加 3. 使用&#123;&#123;&#125;&#125;语法完成数据显示 组件使用 ionic初体验 先了解一下页面常见的效果 menu 实现的效果 点击左上角的菜单项,弹出侧边菜单** 代码实现 在跟组件实现 —- 也就是app组件 12345678910111213141516171819202122232425&lt;ion-menu [content]=&quot;content&quot;&gt; &lt;ion-header&gt; &lt;ion-toolbar&gt; &lt;ion-title&gt;Menu&lt;/ion-title&gt; &lt;/ion-toolbar&gt; &lt;/ion-header&gt; &lt;ion-content&gt; &lt;ion-list&gt; &lt;button ion-item (click)=&quot;openPage(homePage)&quot;&gt; Home &lt;/button&gt; &lt;button ion-item (click)=&quot;openPage(friendsPage)&quot;&gt; Friends &lt;/button&gt; &lt;button ion-item (click)=&quot;openPage(eventsPage)&quot;&gt; Events &lt;/button&gt; &lt;button ion-item (click)=&quot;closeMenu()&quot;&gt; Close Menu &lt;/button&gt; &lt;/ion-list&gt; &lt;/ion-content&gt;&lt;/ion-menu&gt;&lt;ion-nav id=&quot;nav&quot; #content [root]=&quot;rootPage&quot;&gt;&lt;/ion-nav&gt; 相关api 详情可查阅api文档 1234567891011121314151617181920212223242526272829menuToggle : 实现菜单栏的切换menuClose : 关闭菜单栏js控制: 三步操作实现菜单打开/关闭/切换 1. 导入控制器类 import &#123; MenuController &#125; from &apos;ionic-angular&apos;; 2. 注入到构造函数 constructor(public menuCtrl: MenuController) &#123;&#125; 3. 调用方法 (要实现什么样的功能,调用对应的方法即可) openMenu() &#123; this.menuCtrl.open(); &#125; closeMenu() &#123; this.menuCtrl.close(); &#125; toggleMenu() &#123; this.menuCtrl.toggle(); &#125; tabs导航 效果: 底部导航栏 实现手机应用上常见的底部菜单导航效果 组件树 tabs组件的实现较为复杂 在完成这部分内容之前,先理解一下组件的组织结构 以下面一幅图为例 在ionic中,整个应用程序中使用到的组件必须在根模块app.module下完成配置大致如下: tabs实现步骤1. 生成导航的组件 也就是完成组件的创建 —-生成组件tab1 tab2 tab3 ionic g page tab1 ——————使用ionic命令生成页面 ionic g page tab2 ionic g page tab3 2. 配置根模块 可以理解为以app.component为根组件构建组件树 3.实现tabs导航 这一部分参考官网内容即可 作业要求作业1 中间列表部分使用自定义json数据文件实现 ionic组件(js部分) ionic以组件的形式提供了很多好用的效果,提供良好的用户体验以部分组件为例,讲解ionic组件的使用方式 Action Sheets/行动表 ActionSheet是从屏幕底部滑出的， 带着确认(confirm)和取消(cancel)操作的选项集合。 ActionSheet可以⽤作菜单的替换， 但是不能作为导航的替换 实现步骤 1234567891011121314151617181920212223242526272829303132333435361. 导入控制器类 import &#123; ActionSheetController &#125; from &apos;ionic-angular&apos;;2. 注入到构造函数 constructor(public actionSheetCtrl: ActionSheetController) &#123; &#125;3. 调用方法----执行这个方法即可创建弹出框 presentActionSheet() &#123; let actionSheet = this.actionSheetCtrl.create(&#123; //定义标题 title: &apos;Modify your album&apos;, //定义按钮 buttons: [ &#123; //文本和角色和处理点击时的响应事件 text: &apos;Destructive&apos;, role: &apos;destructive&apos;, handler: () =&gt; &#123; console.log(&apos;Destructive clicked&apos;); &#125; &#125;,&#123; text: &apos;Archive&apos;, handler: () =&gt; &#123; console.log(&apos;Archive clicked&apos;); &#125; &#125;,&#123; text: &apos;Cancel&apos;, role: &apos;cancel&apos;, handler: () =&gt; &#123; console.log(&apos;Cancel clicked&apos;); &#125; &#125; ] &#125;); actionSheet.present(); &#125; alert/警告 提示框/弹出框 1234567891011121314151. 导入控制器类 import &#123; AlertController &#125; from &apos;ionic-angular&apos;;2. 注入到构造函数 constructor(public alertCtrl: AlertController) &#123;&#125;3. 调用方法 showAlert() &#123; let alert = this.alertCtrl.create(&#123; title: &apos;New Friend!&apos;, subTitle: &apos;Your friend, Obi wan Kenobi, just accepted your friend request!&apos;, buttons: [&apos;OK&apos;] &#125;); alert.present(); &#125; 流程化操作 根据以上两个示例我们可以看到使用ionic组件(或者是angular)的一个流程化操作 组件(js操作)三步 1231. 导入控制器类(模块)2. 注入到构造函数3. 调用方法 toast/通知1234567891011121314import &#123; ToastController &#125; from &apos;ionic-angular&apos;;export class MyPage &#123; constructor(public toastCtrl: ToastController) &#123; &#125; presentToast() &#123; let toast = this.toastCtrl.create(&#123; message: &apos;User was added successfully&apos;, duration: 3000 &#125;); toast.present(); &#125;&#125; modals/模态框12345678910111213import &#123; ModalController &#125; from &apos;ionic-angular&apos;;import &#123; ModalPage &#125; from &apos;./modal-page&apos;;export class MyPage &#123; constructor(public modalCtrl: ModalController) &#123; &#125; presentModal() &#123; let modal = this.modalCtrl.create(ModalPage); modal.present(); &#125;&#125; Popover/弹出框123456789101112import &#123; PopoverController &#125; from &apos;ionic-angular&apos;;import &#123; MyPopOverPage &#125; from &apos;./my-pop-over&apos;;export class MyPage &#123; constructor(public popoverCtrl: PopoverController) &#123; &#125; presentPopover() &#123; let popover = this.popoverCtrl.create(MyPopOverPage); popover.present(); &#125;&#125; 综合练习 1.数据 12345678910111213Arr = [ &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;上海&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;广州&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;] 2.题目描述 12341.)当点击”城市”，弹出北京、上海、广州2.)点击”薪资”，弹出2.5K、5K、10K3.)当点击”公司”，弹出中软、浪潮、用友4.)按照用户的选择对列表进行过滤 3、案例完成思路要求: 12345(1)在Ionic的TS文件中声明数组(2)在html页面渲染数组(3)当点击选项的时候，进行过滤(4)当点击每一项时，弹出这一项在列表中的索引位置 4.评分明细 123456789101.良好的注释（10分）2.正确的制作三个滑出控件的数据(10分)3.正确的使用ion-button和给按钮正确的注册事件（10分）4.正确的使用ActionShetConroller（10分）5.正确的制作列表数据（10分）6.正确的使用ion-list控件（10分）7.选中城市或薪资或公司能正确过滤列表数据（10分）8.当取消选中城市或薪资或公司的时候能正确过滤数据（10分）9.点击每一项弹出每一项的索引位置(10分)10.良好的布局（10分）","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"02-ionic的安装与使用","slug":"ionic2/02-ionic安装与使用","date":"2018-05-10T00:35:17.132Z","updated":"2018-05-10T01:27:17.145Z","comments":true,"path":"2018/05/10/ionic2/02-ionic安装与使用/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/02-ionic安装与使用/","excerpt":"","text":"ionic的安装与使用ionic的安装与启动步骤vue项目模板的安装步骤 12345671. npm install -g vue-cli2. vue init webpack vueproject 项目名称(也就是文件夹名称)3. cd vueproject4. npm install5. npm run dev6. npm run build ionic项目模板的安装步骤 123451. npm install -g ionic2. ionic start projectname3. cd projectname4. ionic serve5. ionic build 1.在node环境的基础下适用npm进行全局安装 推荐在使用之前统一下node和npm的版本,要不然可能会存在一系列的问题 在这里 cordova 可以先安装上,cordova的作用是打包手机app,但是配置的过程比较繁琐,我们会在这里使用一种新的方式进行 1npm install -g ionic 2.全局安装完成之后创建一个项目 1234567891011//使用ionic命令开始创建一个项目模板ionic start projectName//在ionic中提供了多种多样的模板ionic start projectName 可选参数 tabs ：一个简单的3选项卡布局 sidemenu：侧面有可滑动菜单的布局 blank:一个单独的启动器 super：启动项目超过14个可以使用的页面设计 tutorial: 一个引导项目 3.切换到项目目录 1cd projectName 4.启动项目 1ionic serve 5.项目打包 1ionic build ionic项目的启动和基本使用 安装项目模板 ionic start projectName 可选参数 根据不同的参数可以生成不同的项目模板 空模板-blank 导航模板-tabs 侧边菜单模板 -sidemenu 辅助命令 在ionic中,除了直接生成模板的命令之外,还提供了一些其他的命令 创建一个新的页面 12//使用ionic命令生成一个页面 g:generateionic g page pageName 当然还有一些其他的扩展命令,这些命令后期会进行详细讲解 1Ionic CLI 可以生成 pages, providers, tabs, pipes, components，directives等。 项目目录结构 以空模板目录结构为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445├─node_modules --------------------------------依赖包的目录├─resources --------------------------------使用cordova打包(android/ios)需要的资源目录│ │ icon.png --------------------------------图标│ │ README.md --------------------------------使用说明│ │ splash.png ---------------------------------启动页│ │ │ ├─android ---------------------------------跨平台打包生成android应用的相关资源│ │ ├─icon │ │ └─splash │ └─ios ---------------------------------跨平台打包生成ios应用的相关资源│ ├─icon │ └─splash│ ├─src ---------------------------------整个应用程序的代码以及相关配置的目录│ │ index.html│ │ manifest.json │ │ service-worker.js│ │ │ ├─app --------------------------------整个应用程序的根组件│ │ app.component.ts│ │ app.html│ │ app.module.ts│ │ app.scss│ │ main.ts│ │ │ ├─assets ---------------------------------静态资源目录│ │ ├─icon│ │ │ favicon.ico │ │ │ │ │ └─imgs│ │ logo.png│ │ │ ├─pages ---------------------------------应用程序的组件/页面所在目录│ │ └─home│ │ home.html│ │ home.scss│ │ home.ts│ │ │ └─theme ---------------------------------应用程序的主题目录│ variables.scss ---------------------------------应用程序的配置目录│ └─www ----------------------------------应用程序打包之后的资源目录 .gitkeep manifest.json service-worker.js 目录结构详解 1231. 在应用程序中,所有的静态资源可以放到assets目录(css/js/图片.......) 使用的时候直接以./assets/.....2. 应用程序使用到的组件/管道/指令/模块等内容都需要在跟模块app.module文件下完成配置 补充 cordova打包现阶段,有很多工具都可以打包生成应用程序,不必再依赖于cordova,这一部分知识点可以作为 可以搜索搭建android开发环境 参考链接:android开发环境 参考","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"01-ionic知识点","slug":"ionic2/01-ionic概述","date":"2018-05-10T00:35:17.124Z","updated":"2018-05-10T01:27:11.161Z","comments":true,"path":"2018/05/10/ionic2/01-ionic概述/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/01-ionic概述/","excerpt":"","text":"ionic知识点哈哈哈哈哈群威群胆无qhh ionic2概述课程简介 本门课程大致可以分为三部分内容 12345ionic2 类似于muse-ui,mui,element-ui,是一个ui框架typescript 一种版本的jsangular2 前端流行框架之一 1.ionic是什么? 一款优秀的跨平台移动端开发框架 你可以理解成是vue的ui框架,例如 muse-ui mint-ui element-uiionic基于google的angular2,使用typescript语言编写 typescript是什么? 123456js:es6:第六代版本的jstypescript:是js的超集,使用后端语言的规范,对js的语法进行了扩展 可以看做是一种面向对象的js语言版本 2.ionic能做什么? ionic框架的目的是以web技术开发移动端应用程序 配合 apache 服务器的 cordova的编译平台,实现了编译打包成各个移动操作平台适配的移动端应用 通过cordova平台打包,能够实现多平台共用一套代码 123android平台ios平台window平台 3.如何使用ionic2 ionic提供了cli,只需要一个命令就可以创建应用的初始框架 具体如何使用,下章节讲解 认识ionic2几点基本概念 1234567891011121314151617跨平台开发: 简单来说就是一套代码, 多个平台都可以使用cordova和phonegap: PhoneGap或Cordova将做好的东西打包生成手机app,这项技术可以让开发人员使用Web技术开发出媲美原生App的移动应用。 但是Cordova只提供了使用 JavaScript 调用 Native 功能， 在开发的时候还需要开发人员自己去实现诸如样式美化、页面切换、数据展示、弹出框、Modal窗体、日期选择器等功能或组件， 为了提高开发效率，出现了各种前端框架，如 Ionic、 JQuery Mobile UI、 Sencha Touch、 Framework7等。需要复杂的配置过程,这一部分不作为重点讲解,我们会使用一种替代方案ionic: 前端框架,用来实现页面效果,对 Angular 进行了封装，提供了一套适配各移动平台UI风格的前端组件， 使用 Cordova 进行打包，可以让开发人员免去调试大量 CSS 的工作，专注业务逻辑开发即可。Ionic2 基于 Angular 开发(ionic1基于angularjs,由于AngularJS 1.x版本在性能上已经很难有较大提升， Google 又推出了全新设计的 Angular 2) ionic2介绍123456789Ionic 2 专注于以标准的HTML、CSS和JavaScript来构建移动站点，并可以通过Cordova打包成移动App，只需编写一次代码，就可以分别部署到 iOS 、Android 等多种移动平台上。这项技术已经帮助很多开发者创建了很多漂亮的 App。现在 Ionic 2 已经发布了第二代版本，使移动开发更容易、更有效率。Ionic 2 与一代相比有较大的变化，基于最新的 Angular 2 ，使用 TypeScript进行开发，如果您没有接触过 AngularJS或Ionic1.x，完全不用担心，直接从Ionic 2` 开始学习即可。在使用 Ionic 2 之前，您应该具备 HTML、CSS、JavaScript 基础。 ionic的优势和不足 Ionic 2 借助 Angular 2 的革命性改进，与 1.x 版本相比具有以下优势： 更快的性能 123Angular 1 的检测机制在某些场景下会导致性能降低，由于最初的架构限制已经很难进行提升了。Angular 2 有效避免了这种情况。数据显示 Angular 2 比Angular 1 快5到10倍。官方提供了一个动画来展示 Ionic 2 的性能提升： 更加清晰的结构 12345678910Angualr 2 应用是模块化的，因此Ionic 2的项目结构比Ionic 1更为清晰，如：-home.page--home.page.ts--home.page.html--home.page.scss-about.page--about.page.ts--about.page.html--about.page.scss每个页面的代码、模板、样式都放在一块，意义非常清晰。 更强大的CLI 12345678Ionic CLI 提供了更强大的功能，如添加一个页面，可以使用以下命令：ionic g page NewPageIonic CLI 会生成以下的文件，并且文件中已经生成了基本的代码：-new-page--new-page.ts--new-page.html--new-page.scssIonic CLI 可以生成 pages, providers, tabs, pipes, components，directives等。 更友好的页面导航123456789101112131415161718Ionic 2 的导航方式相比一代有了巨大的改进，完全进行了重写。在 Ionic 1.x 中，需要配置路由： .config(function($stateProvider, $urlRouterProvider) &#123; $stateProvider .state(&apos;home&apos;, &#123; url: &apos;/&apos;, templateUrl: &apos;templates/home.html&apos;, controller: &apos;HomeCtrl&apos; &#125;) .state(&apos;main&apos;, &#123; url: &apos;/main&apos;, templateUrl: &apos;templates/main.html&apos;, controller: &apos;MainCtrl&apos; &#125;); $urlRouterProvider.otherwise(&quot;/&quot;); &#125;);Ionic 2抛弃了这种繁琐的方式，更类似原生的开发体验，一行代码即可搞定：this.nav.push(SecondPage);使用全新的NavController组件，导航栈的操作方式更加方便，实现前进、后退等功能就像操作数组那么简单。 更强大的模板语法 Angular2的模板语法刚接触时可能会觉得有点难以上手，但熟悉之后就能够更加灵活的控制单向绑定、双向绑定、事件绑定等各种功能。 更高效的开发体验12基于 TypeScript，使用 Ionic 2 拥有更好的开发体验，支持类、模块、接口、lambda表达式等新的特性，大大改善了 JavaScript的开发体验。当然你需要一个好的编辑器，如VS Code： 强大的智能感知 自定义的类都可以哦，真的有点开发强类型语言的感觉啊 8-)当然，因为最终还是要依靠 Cordova 进行打包，因此不可避免的会遇到所有 Cordova 类跨平台应用面临的问题，在某些性能较差的移动设备上渲染速度较慢。Ionic 2 已经明确提出不支持低版本 Android 设备，并且在 Angular 2正式版发布以后，支持 AoT 编译也会在一定程度上优化 App 性能。","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"controller","slug":"angular1/04-模块/043-控制器","date":"2018-05-10T00:34:45.776Z","updated":"2018-05-10T01:11:12.575Z","comments":true,"path":"2018/05/10/angular1/04-模块/043-控制器/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/04-模块/043-控制器/","excerpt":"","text":"controller-控制器 控制angularjs应用程序的数据 控制器是常规的js对象,由javascripe对象的构造函数创建 ng-controller指令指定应用程序的所使用的制器 添加控制器 护手霜就是 程序代码 12345678910111213//------------2 &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;...&lt;/div&gt;&lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); //添加控制器----作用域当做参数传递 app.controller(&quot;myController&quot;,function($scope)&#123; &#125;)&lt;/script&gt; 代码解析 12345678910111. ng-app 声明一个应用程序,它 的值指定 这个应用程序使用了哪个模块2. ng-controller 定义一个控制器,表示当前应用或标签使用了哪个控制器3. angular.module(): 使用angular的module方法创建一个模块4. 使用模块的controller方法创建控制器 控制器方法有两个属性 第一个属性: 控制器的名称 第二个属性: 一个方法,传入作用域,可以用来定义数据模型 在控制器上添加方法以及方法的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&apos;myCtl&apos;&gt; &lt;!--使用$scope的属性--&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;!--使用$scope的方法--&gt; &lt;p&gt;&#123;&#123;fn()&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app = angular.module(&apos;app&apos;,[]) //在模块上添加控制器 app.controller(&apos;myCtl&apos;,function($scope)&#123; //在控制器上添加属性 $scope.name = &quot;高辉&quot;; //在控制器上添加方法 $scope.fn = function()&#123; //存在的问题,这个方法为什么会执行三次 console.log(1) return &quot;name&quot;+ &quot; &quot;+ $scope.name &#125; &#125;)&lt;/script&gt; 外部文件中的控制器 直接将页面中script标签内部的代码剪切到一个js文件中,再将js文件引入即可","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"04-模块","slug":"angular1/04-模块","permalink":"http://yoursite.com/categories/angular1/04-模块/"}],"tags":[]},{"title":"作用域","slug":"angular1/04-模块/042-作用域","date":"2018-05-10T00:34:45.773Z","updated":"2018-05-10T01:11:16.747Z","comments":true,"path":"2018/05/10/angular1/04-模块/042-作用域/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/04-模块/042-作用域/","excerpt":"","text":"scoped-作用域 Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。 Scope 是一个对象，有可用的方法和属性。 Scope 可应用在视图和控制器上。 在在angularjs中创建控制器的时候,你可以将$scope对象当做一个参数来传递 实例演示123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--4. 创建一个应用,并指定这个应用使用的控制器--&gt; &lt;div ng-app=&quot;myapp&quot; ng-controller=&apos;myController&apos;&gt; &lt;!-- 5. 在视图中使用$scope对象中添加的属性 不需要添加$scope,直接使用即可 --&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建一个模块 var app = angular.module(&apos;myapp&apos;,[]); //2. 在模块上添加控制器,并传入作用域这个特殊参数 app.controller(&apos;myController&apos;,function($scope)&#123; //3. 给$scope对象添加一个属性,在视图中能够直接使用 $scope.name = &quot;gaohui&quot; &#125;)&lt;/script&gt; $scope概述scope是angularjs的数据模型部分 $scope是一个对象,这个对象中有属性和方法,可以直接在视图和控制器中使用 $scope的作用域是局部的 $rootScope根作用域所有的应用程序都有一个跟作用域,可以作用于ng-app指令包含下的所有的html元素 $rootScope作用于整个应用程序,是各个controller中scope的桥梁 使用rootScope定义的值,可以在各个控制器(controller)中使用 12","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"04-模块","slug":"angular1/04-模块","permalink":"http://yoursite.com/categories/angular1/04-模块/"}],"tags":[]},{"title":"模块","slug":"angular1/04-模块/041-模块","date":"2018-05-10T00:34:45.770Z","updated":"2018-05-10T01:11:21.504Z","comments":true,"path":"2018/05/10/angular1/04-模块/041-模块/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/04-模块/041-模块/","excerpt":"","text":"模块模块的基本概念 模块定义了一个应用程序 模块是应用程序中不同部分的容器 模块是应用控制器的容器 控制器通常属于一个模块 模块的定义 可以通过angular.module()函数来创建一个模块 第一个参数对应的是执行应用程序的html元素 12345678//------------1 &lt;div ng-app=&quot;myApp&quot;&gt;...&lt;/div&gt;&lt;script&gt; var app = angular.module(&quot;myApp&quot;, []);&lt;/script&gt; 创建好模块之后,就可以在angularjs中添加控制器,过滤器,指令 在创建好的模块上进行控制器的添加12345678910111213//------------2 &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;...&lt;/div&gt;&lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); //添加控制器----作用域当做参数传递 app.controller(&quot;myController&quot;,function($scope)&#123; &#125;)&lt;/script&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"04-模块","slug":"angular1/04-模块","permalink":"http://yoursite.com/categories/angular1/04-模块/"}],"tags":[]},{"title":"全局api","slug":"angular1/19-conclusion/19-知识点总结","date":"2018-05-10T00:34:45.767Z","updated":"2018-05-10T01:12:35.548Z","comments":true,"path":"2018/05/10/angular1/19-conclusion/19-知识点总结/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/19-conclusion/19-知识点总结/","excerpt":"","text":"angularsjs参考手册AngularJS 指令本教程中使用的 AngularJS 指令： 指令 描述 讲解 ng_app 定义应用程序的根元素。 指令 ng_bind 绑定 HTML 元素到应用程序数据。 简介 ng_click 定义元素被单击时的行为。 HTML 事件 ng_controller 为应用程序定义控制器对象。 控制器 ng_disabled 绑定应用程序数据到 HTML 的 disabled 属性。 HTML DOM ng_init 为应用程序定义初始值。 指令 ng_model 绑定应用程序数据到 HTML 元素。 指令 ng_repeat 为控制器中的每个数据定义一个模板。 指令 ng_show 显示或隐藏 HTML 元素。 HTML DOM AngularJS 过滤器本教程中使用的 AngularJS 过滤器： 过滤器 描述 currency 格式化数字为货币格式。 filter 从数组项中选择一个子集。 lowercase 格式化字符串为小写。 orderBy 根据某个表达式排列数组。 uppercase 格式化字符串为大写。","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"19-conclusion","slug":"angular1/19-conclusion","permalink":"http://yoursite.com/categories/angular1/19-conclusion/"}],"tags":[]},{"title":"ng路由","slug":"angular1/18-router/18-angularjs路由","date":"2018-05-10T00:34:45.764Z","updated":"2018-05-10T01:12:39.802Z","comments":true,"path":"2018/05/10/angular1/18-router/18-angularjs路由/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/18-router/18-angularjs路由/","excerpt":"","text":"ng路由 路由允许我们使用不同的 url 访问 不同的内容 通过路由操作可以实现单页面应用 路由的配置配置路由的一般流程 引入实现路由的 js 文件：angular-route.js。 1&lt;script src=&quot;http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js&quot;&gt;&lt;/script&gt; 创建一个模块并注入ngRoute(路由)依赖 1var app = angular.module(&apos;app&apos;,[&apos;ngRoute&apos;]) 进行路由的配置 123456789101112131415app.config([&apos;$routeProvider&apos;, function($routeProvider) &#123; $routeProvider .when(&apos;/&apos;, &#123; template: &apos;&lt;h1&gt;home&lt;/h1&gt;&apos; &#125;) .when(&apos;/about&apos;, &#123; template: &apos;&lt;h1&gt;about&lt;/h1&gt;&apos; &#125;) .when(&apos;/login&apos;, &#123; template: &apos;&lt;h1&gt;login&lt;/h1&gt;&apos; &#125;) .otherwise(&#123; template: &apos;&lt;h1&gt;404&lt;/h1&gt;&apos; &#125;) &#125;]) 简单解析 angularjs模块的config函数用于进行路由的配置 * ----通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数 * ----并且使用$routeProvider.whenAPI来定义我们的路由规则。 * $routeProvider 为我们提供了 when(path,object) &amp; otherwise(object) 函数按顺序定义所有路由，函数包含两个参数:第一个参数是 URL 或者 URL 正则规则。第二个参数是路由配置对象。 在页面上定义路由跳转的链接,也就是 a 链接 123456&lt;div class=&quot;router&quot;&gt; &lt;a href=&quot;#/&quot;&gt;home&lt;/a&gt; &lt;a href=&quot;#/about&quot;&gt;about&lt;/a&gt; &lt;a href=&quot;#/login&quot;&gt;login&lt;/a&gt; &lt;a href=&quot;#/404&quot;&gt;404&lt;/a&gt;&lt;/div&gt; 路由对应内容的显示 1&lt;div ng-view id=&quot;view&quot;&gt;&lt;/div&gt; 完整的实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--1. cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular-animate.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; #view &#123; width: 500px; margin: 0 auto; border: 1px solid red; height: 300px; background: pink; &#125; .router&#123; width: 500px; margin: 0 auto; border: 1px solid red; border-bottom: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--开启一个angular应用程序,使用app这个模块--&gt; &lt;div ng-app=&quot;app&quot;&gt; &lt;!--定义路由--&gt; &lt;div class=&quot;router&quot;&gt; &lt;a href=&quot;#/&quot;&gt;home&lt;/a&gt; &lt;a href=&quot;#/about&quot;&gt;about&lt;/a&gt; &lt;a href=&quot;#/login&quot;&gt;login&lt;/a&gt; &lt;a href=&quot;#/404&quot;&gt;404&lt;/a&gt; &lt;/div&gt; &lt;!--路由对应的内容的显示--&gt; &lt;div ng-view id=&quot;view&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //2. 创建一个模块 并注入ngRouter(路由)依赖 var app = angular.module(&apos;app&apos;, [&apos;ngRoute&apos;]); /* * * 3. 进行路由的配置,使用模块的config方法 * ---AngularJS 模块的 config 函数用于配置路由规则。 * ----通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数 * ----并且使用$routeProvider.whenAPI来定义我们的路由规则。 * * * */ app.config([&apos;$routeProvider&apos;, function($routeProvider) &#123; $routeProvider .when(&quot;/&quot;, &#123; //template:在ng-view中简单的插入html内容 template: &quot;&lt;h1&gt;Home&lt;/h1&gt;&quot; &#125;) .when(&quot;/login&quot;, &#123; template: &quot;&lt;h1&gt;Login&lt;/h1&gt;&quot; &#125;) .when(&quot;/about&quot;, &#123; template: &quot;&lt;h1&gt;about&lt;/h1&gt;&quot; &#125;) .otherwise(&#123; template: &quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot; &#125;) &#125;])&lt;/script&gt; 路由配置对象 总结上节的内容,可以总结出以下几点 我们创建一个模块,在模块中注入ngRoute依赖,通过模块的config方法配置路由 在路由配置的时候,我们需要把$routeProvider注入到我们的配置函数 $routeProvider 为我们提供了 when(path,object) &amp; otherwise(object)函数按顺序定义所有路由，函数包含两个参数: 第一个参数是 URL 或者 URL 正则规则。 第二个参数是路由配置对象。 路由配置对象1234567891011121314151617181920$routeProvider.when(url, &#123; //定义模板字符串 template: string, //定义模板文件 templateUrl: string, //添加控制器 controller: string, function 或 array, //为控制器指定别名 controllerAs: string, //重定向的地址 redirectTo: string, function, //指定当前controller依赖的其他模块 resolve: object&lt;key, function&gt;&#125;);","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"18-router","slug":"angular1/18-router","permalink":"http://yoursite.com/categories/angular1/18-router/"}],"tags":[]},{"title":"依赖注入","slug":"angular1/17-inject/17-依赖注入","date":"2018-05-10T00:34:45.707Z","updated":"2018-05-10T01:12:47.121Z","comments":true,"path":"2018/05/10/angular1/17-inject/17-依赖注入/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/17-inject/17-依赖注入/","excerpt":"","text":"依赖注入","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"17-inject","slug":"angular1/17-inject","permalink":"http://yoursite.com/categories/angular1/17-inject/"}],"tags":[]},{"title":"angularjs动画","slug":"angular1/16-animation/16-angularjs动画","date":"2018-05-10T00:34:45.704Z","updated":"2018-05-10T01:11:50.523Z","comments":true,"path":"2018/05/10/angular1/16-animation/16-angularjs动画/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/16-animation/16-angularjs动画/","excerpt":"","text":"angularjs动画 angularjs提供了动画效果,可以配合css使用 AngularJS 使用动画需要引入 angular-animate.min.js 库。 动画库的使用1. angularjs动画的引入 1&lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular-animate.min.js&quot;&gt;&lt;/script&gt; 2. 在应用中使用模型 ngAnimate 1&lt;body ng-app=&quot;ngAnimate&quot;&gt; 动画的实现 通过样式类的操作实现 123456789101112131415161718192021ngAnimate 模型可以添加或移除 class 。ngAnimate 模型并不能使 HTML 元素产生动画，但是 ngAnimate 会监测事件，类似隐藏显示 HTML 元素 ，如果事件发生 ngAnimate 就会使用预定义的 class 来设置 HTML 元素的动画。AngularJS 添加/移除 class 的指令: ng-show ng-hide ng-class ng-view ng-include ng-repeat ng-if ng-switchng-show 和 ng-hide 指令用于添加或移除 ng-hide class 的值。其他指令会在进入 DOM 会添加 ng-enter 类，移除 DOM 会添加 ng-leave 属性。当 HTML 元素位置改变时，ng-repeat 指令同样可以添加 ng-move 类 。此外， 在动画完成后，HTML 元素的类集合将被移除。例如：ng-hide 指令会添加一下类： ng-animate ng-hide-animate ng-hide-add (如果元素将被隐藏) ng-hide-remove (如果元素将显示) ng-hide-add-active (如果元素将隐藏) ng-hide-remove-active (如果元素将显示) 过渡例子12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; div &#123; transition: all linear 0.5s; background-color: lightblue; height: 100px; &#125; .ng-hide &#123; height: 0; &#125; &lt;/style&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular-animate.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;myApp&quot;&gt; &lt;h1&gt;隐藏 DIV: &lt;input type=&quot;checkbox&quot; ng-model=&quot;myCheck&quot;&gt;&lt;/h1&gt; &lt;div ng-hide=&quot;myCheck&quot;&gt;&lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, [&apos;ngAnimate&apos;]); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 动画例子1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular-animate.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; @keyframes myChange &#123; from &#123; height: 100px; &#125; to &#123; height: 0; &#125; &#125; div &#123; height: 100px; background-color: lightblue; &#125; div.ng-hide &#123; animation: 0.5s myChange; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body ng-app=&quot;ngAnimate&quot;&gt; 隐藏 DIV: &lt;input type=&quot;checkbox&quot; ng-model=&quot;myCheck&quot;&gt; &lt;div ng-hide=&quot;myCheck&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"16-animation","slug":"angular1/16-animation","permalink":"http://yoursite.com/categories/angular1/16-animation/"}],"tags":[]},{"title":"页面包含","slug":"angular1/15-include/15-include","date":"2018-05-10T00:34:45.702Z","updated":"2018-05-10T01:11:56.242Z","comments":true,"path":"2018/05/10/angular1/15-include/15-include/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/15-include/15-include/","excerpt":"","text":"页面包含ng-include:这个指令可以实现页面的包含操作 实现的是在一个页面中使用多页页面里面的内容 存在的小问题: 在一个页面添加样式,会作用于所有页面里面的内容 12345678&lt;!--开启一个应用,使用页面包含--&gt;&lt;div ng-app&gt; &lt;div ng-include=&quot;&apos;./01-head.html&apos;&quot;&gt;&lt;/div&gt; &lt;div ng-include=&quot;&apos;./02-body.html&apos;&quot;&gt;&lt;/div&gt; &lt;div ng-include=&quot;&apos;./03-foot.html&apos;&quot;&gt;&lt;/div&gt; &lt;/div&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"15-include","slug":"angular1/15-include","permalink":"http://yoursite.com/categories/angular1/15-include/"}],"tags":[]},{"title":"","slug":"angular1/14-bootstrap/14-bootstrap使用","date":"2018-05-10T00:34:45.699Z","updated":"2018-05-10T00:52:27.478Z","comments":true,"path":"2018/05/10/angular1/14-bootstrap/14-bootstrap使用/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/14-bootstrap/14-bootstrap使用/","excerpt":"","text":"1title: bootstrap angularjs bootstrapbootstrap概述 AngularJS 的首选样式表是 Twitter Bootstrap， Twitter Bootstrap 是目前最受欢迎的前端框架。 bootstrap使用 引入bootstrap样式之后,就可以使用样式表里面已经定义好的样式了 你可以在你的 AngularJS 应用中加入 Twitter Bootstrap，你可以在你的 元素中添加如下代码: 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt; 如果站点在国内，建议使用百度静态资源库的Bootstrap，代码如下： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://apps.bdimg.com/libs/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"14-bootstrap","slug":"angular1/14-bootstrap","permalink":"http://yoursite.com/categories/angular1/14-bootstrap/"}],"tags":[]},{"title":"全局api","slug":"angular1/13-全局api/13-全局api","date":"2018-05-10T00:34:45.696Z","updated":"2018-05-10T01:12:01.660Z","comments":true,"path":"2018/05/10/angular1/13-全局api/13-全局api/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/13-全局api/13-全局api/","excerpt":"","text":"全局api API 意为 Application Programming Interface（应用程序编程接口）。 全局api使用angular这个对象进行访问 四种基本的api以及其使用的方式 1234567angular.lowercase() 转换字符串为小写angular.uppercase() 转换字符串为大写angular.isString() 判断给定的对象是否为字符串，如果是返回 true。angular.isNumber() 判断给定的对象是否为数字，如果是返回 true。 一个完整的例子123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;app&quot; ng-controller=&quot;myController&quot;&gt; &lt;h1&gt;name: &#123;&#123; userName1 &#125;&#125;&lt;/h1&gt; &lt;h1&gt;sex : &#123;&#123; userSex1 &#125;&#125;&lt;/h1&gt; &lt;h1&gt;isString : &#123;&#123; isString &#125;&#125;&lt;/h1&gt; &lt;h1&gt;isNumber : &#123;&#123; isNumber &#125;&#125;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建模块 var app = angular.module(&quot;app&quot;, []); //2. 添加控制器 app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) &#123; $scope.userName = &quot;gaohui&quot;; $scope.userSex = &quot;GENDER&quot;; $scope.userName1 = angular.uppercase($scope.userName); $scope.isString = angular.isString($scope.userName); $scope.userSex1 = angular.lowercase($scope.userSex); $scope.isNumber = angular.isNumber($scope.userSex); &#125;])&lt;/script&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"13-全局api","slug":"angular1/13-全局api","permalink":"http://yoursite.com/categories/angular1/13-全局api/"}],"tags":[]},{"title":"表单和输入验证","slug":"angular1/12-validate/12-表单和输入验证","date":"2018-05-10T00:34:45.692Z","updated":"2018-05-10T01:12:07.378Z","comments":true,"path":"2018/05/10/angular1/12-validate/12-表单和输入验证/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/12-validate/12-表单和输入验证/","excerpt":"","text":"表单和输入验证表单 angularjs表单是输入控件的集合 html表单 通常与 html控件同时存在 HTML 控件,以下 HTML input 元素被称为 HTML 控件: input 元素 select 元素 button 元素 textarea 元素 基本表单实例123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--开启一个angularjs应用程序 使用模块 添加控制器--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;form action=&quot;javascript:void(0)&quot; method=&quot;post&quot;&gt; &lt;!--使用数据模型里面的数据--&gt; name:&lt;input type=&quot;text&quot; ng-model=&quot;person.name&quot; /&gt; &lt;br /&gt; age:&lt;input type=&quot;text&quot; ng-model=&quot;person.age&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app = angular.module(&apos;app&apos;, []) //在模块上添加控制器,并传入作用域参数 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.person = &#123; &quot;name&quot;: &quot;gaohui&quot;, &quot;age&quot;: &quot;23&quot; &#125; &#125;)&lt;/script&gt; 表单使用提升12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;formCtrl&quot;&gt; &lt;form novalidate&gt; &lt;p&gt;First Name:&lt;/p&gt; &lt;input type=&quot;text&quot; ng-model=&quot;user.firstName&quot;&gt; &lt;p&gt;Last Name:&lt;/p&gt; &lt;input type=&quot;text&quot; ng-model=&quot;user.lastName&quot;&gt; &lt;div&gt; &lt;button ng-click=&quot;reset()&quot;&gt;RESET&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;p&gt;form = &#123;&#123;user &#125;&#125;&lt;/p&gt; &lt;p&gt;master = &#123;&#123;master&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;formCtrl&apos;, function($scope) &#123; $scope.master = &#123; firstName: &quot;John&quot;, lastName: &quot;Doe&quot; &#125;; $scope.reset = function() &#123; //angular.copy()方法实现数据的拷贝 $scope.user = angular.copy($scope.master); &#125;; //默认先执行一次方法 $scope.reset(); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输入验证 AngularJS 表单和控件可以提供验证功能，并对用户输入的非法数据进行警告。 HTML 属性 novalidate 用于禁用浏览器的默认验证。客户端的验证不能确保用户输入数据的安全，所以服务端的数据验证也是必须的。 表单输入验证例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;验证实例&lt;/h2&gt; &lt;form ng-app=&quot;myApp&quot; ng-controller=&quot;validateCtrl&quot; name=&quot;myForm&quot; novalidate&gt; &lt;p&gt;用户名:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; ng-model=&quot;user&quot; required&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.user.$dirty &amp;&amp; myForm.user.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.user.$error.required&quot;&gt;用户名是必须的。&lt;/span&gt; &lt;/span&gt; &lt;/p&gt; &lt;p&gt;邮箱:&lt;br&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; ng-model=&quot;email&quot; required&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.email.$dirty &amp;&amp; myForm.email.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.email.$error.required&quot;&gt;邮箱是必须的。&lt;/span&gt; &lt;span ng-show=&quot;myForm.email.$error.email&quot;&gt;非法的邮箱地址。&lt;/span&gt; &lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; ng-disabled=&quot;myForm.user.$dirty &amp;&amp; myForm.user.$invalid || myForm.email.$dirty &amp;&amp; myForm.email.$invalid&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;validateCtrl&apos;, function($scope) &#123; $scope.user = &apos;Loen Wang&apos;; $scope.email = &apos;loenwang@loen.wang&apos;; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"12-validate","slug":"angular1/12-validate","permalink":"http://yoursite.com/categories/angular1/12-validate/"}],"tags":[]},{"title":"事件","slug":"angular1/111-event/11-事件","date":"2018-05-10T00:34:45.689Z","updated":"2018-05-10T01:12:13.733Z","comments":true,"path":"2018/05/10/angular1/111-event/11-事件/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/111-event/11-事件/","excerpt":"","text":"事件 ng-click制定了angular应用程序的单机事件 简单实例实例1 点击按钮,进行数字加1的操作 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--ng-app开启一个angularjs应用程序 使用app这个模块 并添加控制器--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&apos;myCtl&apos;&gt; &lt;button ng-click=&quot;num=num+1&quot;&gt;点击加1&lt;/button&gt; &lt;p&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app = angular.module(&apos;app&apos;,[]) //在模块上添加控制器, 并传入作用域参数 app.controller(&apos;myCtl&apos;,function($scope)&#123; $scope.num=0; console.log($scope.num) &#125;) &lt;/script&gt; 实例2 点击按钮,进行元素的显示和隐藏操作 以下操作可以通过简单改写,以点击按钮,执行函数的形式实现 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--ng-app开启一个angularjs应用程序 使用app这个模块 并添加控制器--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&apos;myCtl&apos;&gt; &lt;button ng-click=&quot;bool = !bool&quot;&gt;点击按钮进行元素的显示和隐藏切换&lt;/button&gt; &lt;p&gt;&#123;&#123;bool&#125;&#125;&lt;/p&gt; &lt;!--下面是进行显示额隐藏切换的元素--&gt; &lt;ul ng-show=&apos;bool&apos;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app = angular.module(&apos;app&apos;, []) //在模块上添加控制器, 并传入作用域参数 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.bool = true; &#125;)&lt;/script&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"111-event","slug":"angular1/111-event","permalink":"http://yoursite.com/categories/angular1/111-event/"}],"tags":[]},{"title":"DOM","slug":"angular1/10-dom/10-dom","date":"2018-05-10T00:34:45.684Z","updated":"2018-05-10T01:12:18.639Z","comments":true,"path":"2018/05/10/angular1/10-dom/10-dom/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/10-dom/10-dom/","excerpt":"","text":"angularjs DOM angularjs有自己的html属性指令 ng-disabledng-disabled绑定应用程序数据到html的disabled属性 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--启动一个angularjs应用程序--&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;!--ng-disabled指令绑定应用应用程序数据到html元素的disabled指令--&gt; &lt;button ng-disabled=&quot;bool&quot;&gt;按钮&lt;/button&gt; &lt;!-- ng-model绑定应用程序数据bool到input标签的value值 --&gt; &lt;input type=&quot;checkbox&quot; ng-model=&apos;bool&apos; name=&quot;&quot; id=&quot;&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; ng-show ng-show指令进行元素的显示和隐藏,其值可以是bool值,也可以是一个bool表达式 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--启动一个angularjs应用程序--&gt; &lt;div ng-app&gt; &lt;!-- ng-show指令进行元素的显示和隐藏 其值可以是一个bool表达式 --&gt; &lt;p ng-show=&apos;true&apos;&gt;元素显示&lt;/p&gt; &lt;p ng-show=&apos;false&apos;&gt;元素隐藏&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; ng-hide","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"10-dom","slug":"angular1/10-dom","permalink":"http://yoursite.com/categories/angular1/10-dom/"}],"tags":[]},{"title":"AngularJS概述","slug":"angular1/09-sql/09-sql","date":"2018-05-10T00:34:45.680Z","updated":"2018-05-10T01:12:22.408Z","comments":true,"path":"2018/05/10/angular1/09-sql/09-sql/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/09-sql/09-sql/","excerpt":"","text":"sql","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"09-sql","slug":"angular1/09-sql","permalink":"http://yoursite.com/categories/angular1/09-sql/"}],"tags":[]},{"title":"选择框和表格","slug":"angular1/08-form/08-选择框和表格","date":"2018-05-10T00:34:45.674Z","updated":"2018-05-10T01:12:28.579Z","comments":true,"path":"2018/05/10/angular1/08-form/08-选择框和表格/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/08-form/08-选择框和表格/","excerpt":"","text":"选择框和表格选择框 也叫下拉列表 AngularJS 可以使用数组或对象创建一个下拉列表选项。 使用 ng-options 创建选择框 列表项通过对象和数组循环输出 使用ng-options创建一个下拉列表123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myController&quot;&gt; &lt;!--创建一个下拉列表--&gt; &lt;select ng-model=&quot;selectedName&quot; ng-options=&quot;data for data in arr&quot;&gt; &lt;/select&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1 创建一个模块 var app = angular.module(&apos;app&apos;,[]) //2 在模块上添加控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.arr = [1,2,3] &#125;) /&lt;/script&gt; 使用ng-repeat创建下拉列表12 ng-options更强大12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--开启一个angularjs应用程序--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;select name=&quot;&quot;&gt; &lt;option ng-repeat=&quot;data in arr&quot;&gt;&#123;&#123;data&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app =angular.module(&apos;app&apos;,[]) //在创建好的模块上添加控制器 app.controller(&apos;myCtl&apos;,function($scope)&#123; //数据模型 $scope.arr = [1,2,3] &#125;)&lt;/script&gt; 表格 ng-repeat 指令可以完美的显示表格。 基本表格操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; table, th, td &#123; border: 1px solid grey; border-collapse: collapse; padding: 5px; &#125; table tr:nth-child(odd) &#123; background-color: #f1f1f1; &#125; table tr:nth-child(even) &#123; background-color: #ffffff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--创建一个angular应用程序--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;en&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;!--使用ng-repeat进行表格数据的渲染--&gt; &lt;tr ng-repeat=&quot;data in stu&quot;&gt; &lt;td&gt;&#123;&#123;data.en&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建一个模块 var app = angular.module(&apos;app&apos;, []) //2. 在模块上添加控制器 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.stu = [ &#123; &quot;en&quot;: &quot;gaohui&quot;, &quot;name&quot;: &quot;高辉&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;angda&quot;, &quot;name&quot;: &quot;昂达&quot;, &quot;age&quot;: &quot;22&quot; &#125;, &#123; &quot;en&quot;: &quot;guofeng&quot;, &quot;name&quot;: &quot;国锋&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;liujina&quot;, &quot;name&quot;: &quot;刘健&quot;, &quot;age&quot;: &quot;23&quot; &#125; ] &#125;)&lt;/script&gt; 表格的排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; table, th, td &#123; border: 1px solid grey; border-collapse: collapse; padding: 5px; &#125; table tr:nth-child(odd) &#123; background-color: #f1f1f1; &#125; table tr:nth-child(even) &#123; background-color: #ffffff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--创建一个angular应用程序--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;en&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;!--表格的排序显示--&gt; &lt;tr ng-repeat=&quot;data in stu | orderBy:&apos;en&apos;&quot;&gt; &lt;td&gt;&#123;&#123;data.en&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建一个模块 var app = angular.module(&apos;app&apos;, []) //2. 在模块上添加控制器 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.stu = [ &#123; &quot;en&quot;: &quot;gaohui&quot;, &quot;name&quot;: &quot;高辉&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;angda&quot;, &quot;name&quot;: &quot;昂达&quot;, &quot;age&quot;: &quot;22&quot; &#125;, &#123; &quot;en&quot;: &quot;guofeng&quot;, &quot;name&quot;: &quot;国锋&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;liujina&quot;, &quot;name&quot;: &quot;刘健&quot;, &quot;age&quot;: &quot;23&quot; &#125; ] &#125;)&lt;/script&gt; 对表格单元格数据使用过滤器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; table, th, td &#123; border: 1px solid grey; border-collapse: collapse; padding: 5px; &#125; table tr:nth-child(odd) &#123; background-color: #f1f1f1; &#125; table tr:nth-child(even) &#123; background-color: #ffffff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--创建一个angular应用程序--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;en&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;tr ng-repeat=&quot;data in stu&quot;&gt; &lt;!--表格数据的过滤显示--&gt; &lt;td&gt;&#123;&#123;data.en | uppercase&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建一个模块 var app = angular.module(&apos;app&apos;, []) //2. 在模块上添加控制器 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.stu = [ &#123; &quot;en&quot;: &quot;gaohui&quot;, &quot;name&quot;: &quot;高辉&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;angda&quot;, &quot;name&quot;: &quot;昂达&quot;, &quot;age&quot;: &quot;22&quot; &#125;, &#123; &quot;en&quot;: &quot;guofeng&quot;, &quot;name&quot;: &quot;国锋&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;liujina&quot;, &quot;name&quot;: &quot;刘健&quot;, &quot;age&quot;: &quot;23&quot; &#125; ] &#125;)&lt;/script&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"08-form","slug":"angular1/08-form","permalink":"http://yoursite.com/categories/angular1/08-form/"}],"tags":[]},{"title":"Http","slug":"angular1/07-http/07-http","date":"2018-05-10T00:34:45.668Z","updated":"2018-05-10T01:11:35.753Z","comments":true,"path":"2018/05/10/angular1/07-http/07-http/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/07-http/07-http/","excerpt":"","text":"AngularJS Http 是AngularJS 的 XMLHttpRequest,类似于原生js的 ajax 对象$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。 实例$http.get(url).then(function(res){})12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; table&#123; border-collapse: collapse; &#125; th,td&#123; padding: 5px 20px; &#125; img&#123; width: 100px; height: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&apos;myController&apos;&gt; &lt;!--将请求回来的数据渲染在一个表格中--&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;th&gt;img&lt;/th&gt; &lt;/tr&gt; &lt;tr ng-repeat=&quot;data in arr&quot;&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;&#123;&#123;data.imgSrc&#125;&#125;&quot; alt=&quot;&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;,[]) app.controller(&apos;myController&apos;,function($scope,$http)&#123; //使用$http服务发送请求,获取数据 var url = &apos;json/my.json&apos; $http.get(url).then(function(res)&#123; console.log(res.data) //将请求回来的数据保存在数据模型中 $scope.arr = res.data &#125;) &#125;) &lt;/script&gt;; $http.get(url).success(function(res){})12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;//apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;customersCtrl&quot;&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;data in arr&quot;&gt; &#123;&#123; data.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;customersCtrl&apos;, function($scope, $http) &#123; var url = &apos;json/my.json&apos; //发送请求,请求成功后获取数据,通过函数的参数来接受获取的数据 $http.get(url).success(function(res) &#123; console.log(res) $scope.arr = res; &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"07-http","slug":"angular1/07-http","permalink":"http://yoursite.com/categories/angular1/07-http/"}],"tags":[]},{"title":"服务","slug":"angular1/06-service/06-服务","date":"2018-05-10T00:34:45.657Z","updated":"2018-05-10T01:10:56.455Z","comments":true,"path":"2018/05/10/angular1/06-service/06-服务/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/06-service/06-服务/","excerpt":"","text":"服务 在angularjs中,可以创建自己的服务,或者使用内置的服务 服务概述什么是服务 服务是一个函数或者是一个对象,可以在angularjs应用程序中使用 angularjs内置了30多个服务 实例演示$location服务 $location服务可以返回当前页面的url地址 $location服务和$scope一样,是作为一个参数传递到controller中AngularJS 会一直监控应用，处理事件变化， AngularJS 使用 $location 服务比使用 window.location 对象更好。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!--视图 开启一个应用--&gt; &lt;body ng-app=&quot;app&quot; ng-controller=&quot;RegisterController&quot;&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- service:AngularJS 中你可以创建自己的服务，或使用内建服务。 在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。 ----------AngularJS 内建了30 多个服务 1.$location 服务，它可以返回当前页面的 URL 地址。 --------注意 $location 服务是作为一个参数传递到 controller 中。如果要使用它，需要在 controller 中定义。 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建模块 var app = angular.module(&apos;app&apos;, []); //添加控制器 app.controller(&apos;RegisterController&apos;, function($scope, $location) &#123; console.log($location); console.log($location.$$absUrl); console.log(&quot;协议: &quot; + $location.$$protocol) console.log(&quot;主机: &quot; + $location.$$host) console.log(&quot;端口: &quot; + $location.$$port) &#125;)&lt;/script&gt; $http服务 $http 是 AngularJS 应用中最常用的服务。 服务向服务器发送请求，应用响应服务器传送过来的数据。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!--视图 开启一个应用--&gt; &lt;body ng-app=&quot;app&quot; ng-controller=&quot;RegisterController&quot;&gt; &lt;div class=&quot;contain&quot;&gt;&#123;&#123;myWelcome&#125;&#125;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- service:AngularJS 中你可以创建自己的服务，或使用内建服务。 在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。 ----------AngularJS 内建了30 多个服务 2.$http 服务向服务器请求数据:--&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建模块 var app = angular.module(&apos;app&apos;, []); //添加控制器 app.controller(&apos;RegisterController&apos;, function($scope, $http) &#123; $http.get(&quot;views/index.html&quot;).then(function(response) &#123; $scope.myWelcome = response.data; console.log($scope.myWelcome) &#125;) &#125;)&lt;/script&gt; $timeout服务 和 $interval 服务 AngularJS $timeout 服务对应了 JS window.setTimeout 函数。 AngularJS $interval 服务对应了 JS window.setInterval 函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!--视图 开启一个应用--&gt; &lt;body ng-app=&quot;app&quot; ng-controller=&quot;RegisterController&quot;&gt; &lt;form&gt; name: &lt;input type=&quot;text&quot; ng-model=&apos;name&apos; /&gt; &lt;br /&gt; age : &lt;input type=&quot;text&quot; ng-model=&apos;age&apos; /&gt; &lt;br /&gt; sex : &lt;input type=&quot;text&quot; ng-model=&apos;sex&apos; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; &lt;p ng-controller=&quot;timeController&quot;&gt;&#123;&#123;time&#125;&#125;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- service:AngularJS 中你可以创建自己的服务，或使用内建服务。 在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。 ----------AngularJS 内建了30 多个服务 3.$timeout对应js的setTimeout(function()&#123;&#125;,1000) ----interval--&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建模块 var app = angular.module(&apos;app&apos;, []); //添加控制器 app.controller(&apos;RegisterController&apos;, function($scope, $timeout) &#123; //添加模型数据 $scope.name = &quot;gaohui&quot;; $scope.age = &quot;18&quot;; $scope.sex = &quot;male&quot;; //设置定时器 $timeout(function()&#123; $scope.name = &quot;高辉&quot;; &#125;,1000); &#125;) //设置计时器 app.controller(&apos;timeController&apos;,function($scope,$interval)&#123; $scope.time = new Date().toLocaleTimeString(); $interval(function()&#123; $scope.time = new Date().toLocaleTimeString(); &#125;,1000) &#125;)&lt;/script&gt; 自定义服务 以下面的代码为例 123456789101112131415//1 创建一个模块var app = angular.module(&apos;app&apos;,[])//2. 在这里创建一个自定义的服务,添加到控制器app.service(&apos;$uc&apos;,function()&#123; this.toUC = function(data)&#123; return data.toUpperCase() &#125;&#125;)//3. 给模块添加控制器 并使用 自定义的服务app.controller(&apos;controller&apos;,function($scope,$uc)&#123; $scope.name=$uc.toUC(&quot;gaohui&quot;)&#125;) 代码解析 123在第二步实现中,使用模块app的service方法创建一个自定义的服务 第一个参数是服务的名称,第二个参数是一个韩式,定义这个服务要完成的一些操作 实例一: 在控制器中使用自定义服务1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;p&gt;255 的16进制是:&lt;/p&gt; &lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt; &lt;script&gt; //1. 创建模块 var app = angular.module(&apos;myApp&apos;, []); //2. 创建一个自定义的服务 hexafy app.service(&apos;hexafy&apos;, function() &#123; this.myFunc = function(x) &#123; return x.toString(16); &#125; &#125;); //3. 添加控制器,应用创建的服务 app.controller(&apos;myCtrl&apos;, function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实例二: 在过滤器中使用自定义的服务12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;, []); // 在模块的基础上,添加自定义的服务 app.service(&quot;$convert&quot;, function() &#123; //convert是服务的名称,后面是服务的方法声明 this.fn = function(data) &#123; return data.toString(16); &#125; &#125;) // 在模块的基础上添加自定义的过滤器 app.filter(&apos;myFormat&apos;, [&apos;$convert&apos;, function($convert) &#123; return function(data) &#123; return $convert.fn(data); &#125;; &#125;]); // 添加控制器,使用自定义的服务 app.controller(&quot;myController&quot;, [&quot;$scope&quot;, &quot;$convert&quot;, function($scope, $convert) &#123; $scope.counts = [255, 251, 200]; &#125;]) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myController&quot;&gt; &lt;p&gt;在获取数组 [255, 251, 200] 值时使用过滤器:&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in counts&quot;&gt;result: &#123;&#123;x | myFormat&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;过滤器使用服务将10进制转换为16进制。&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"06-service","slug":"angular1/06-service","permalink":"http://yoursite.com/categories/angular1/06-service/"}],"tags":[]},{"title":"angularjs过滤器","slug":"angular1/05-filter/05-过滤器","date":"2018-05-10T00:34:45.651Z","updated":"2018-05-10T01:11:06.720Z","comments":true,"path":"2018/05/10/angular1/05-filter/05-过滤器/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/05-filter/05-过滤器/","excerpt":"","text":"angularjs过滤器 进行过滤操作 实例: 水的过滤 使用一个管道符号添加到指令或者是表达式中 angularjs过滤器 angularjs过滤器可用于进行数据的转化 过滤器 描述 currency 格式化数字为货币格式。 filter 从数组项中选择一个子集。 lowercase 格式化字符串为小写。 orderBy 根据某个表达式排列数组。 uppercase 格式化字符串为大写。","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"05-filter","slug":"angular1/05-filter","permalink":"http://yoursite.com/categories/angular1/05-filter/"}],"tags":[]},{"title":"指令","slug":"angular1/03-ng指令/03-ng指令","date":"2018-05-10T00:34:45.646Z","updated":"2018-05-10T01:11:25.083Z","comments":true,"path":"2018/05/10/angular1/03-ng指令/03-ng指令/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/03-ng指令/03-ng指令/","excerpt":"","text":"指令基本指令ng-app 开启一个angularjs应用程序 ng-app指令定义了angularjs应用程序的根元素,在网页进行加载的时候,会自动渲染页面元素 一个页面可以包含多个运行在不同元素中的angularjs应用程序 123456//ng-app后面可以跟一个值来连接到代码模块&lt;div ng-app=&quot;myapp&quot; ng-controller=&apos;myController&apos;&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt; ng-init 使用ng-init初始化数据,这个指令不是太常用,后面会学习更好的进行数据绑定的方式 在后面的学习中,将使用控制器或者是模块代替这一部分的内容 ng-model 使用ng-model的形式进行数据的双向绑定 ng-model 指令 绑定 HTML 元素 到应用程序数据。 123456789ng-model 指令也可以： 为应用程序数据提供类型验证（number、email、required）。 为应用程序数据提供状态（invalid、dirty、touched、error）。 为 HTML 元素提供 CSS 类。 绑定 HTML 元素到 HTML 表单。 ng-bind 将应用程序的数据绑定到html视图中 ng-repeat ng-repeat指令用在对象或数组上,进行循环输出 angularjs支持数据库的增删改查的操作,可以将页面上的数据想像成数据库中定义的数据 本教程中使用的 AngularJS 指令： 指令 描述 讲解 ng_app 定义应用程序的根元素。 指令 ng_bind 绑定 HTML 元素到应用程序数据。 简介 ng_click 定义元素被单击时的行为。 HTML 事件 ng_controller 为应用程序定义控制器对象。 控制器 ng_disabled 绑定应用程序数据到 HTML 的 disabled 属性。 HTML DOM ng_init 为应用程序定义初始值。 指令 ng_model 绑定应用程序数据到 HTML 元素。 指令 ng_repeat 为控制器中的每个数据定义一个模板。 指令 ng_show 显示或隐藏 HTML 元素。 HTML DOM","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"03-ng指令","slug":"angular1/03-ng指令","permalink":"http://yoursite.com/categories/angular1/03-ng指令/"}],"tags":[]},{"title":"表达式","slug":"angular1/02-ng表达式/02-ng表达式","date":"2018-05-10T00:34:45.572Z","updated":"2018-05-10T01:19:43.435Z","comments":true,"path":"2018/05/10/angular1/02-ng表达式/02-ng表达式/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/02-ng表达式/02-ng表达式/","excerpt":"","text":"表达式AngularJS 使用 表达式 把数据绑定到 HTML。 AngularJS 表达式写在双大括号内：。可以实现和ng-bind同样的功能 AngularJS 表达式 很像 JavaScript 表达式：它们可以包含文字、运算符和变量。 基本表达式123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!-- 表达式可以实现和ng-bind相同的功能 angularjs表达式和js表达式一样,支持文本,变量和运算,对象 --&gt; &lt;body&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;!--表达式的实现--&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;Hello &#123;&#123;1+1&#125;&#125;&lt;/h1&gt; &lt;h1&gt;Hello &#123;&#123;&quot;高辉&quot;+ name&#125;&#125;&lt;/h1&gt; &lt;!--v-bind的实现--&gt; &lt;h1 ng-bind=&quot;&apos;hello&apos;+name&quot;&gt;&lt;/h1&gt; &lt;h1 ng-bind=&quot;1+1&quot;&gt;&lt;/h1&gt; &lt;h1 ng-bind=&quot;&apos;hello&apos;+&apos;高辉&apos;+name&quot;&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 表达式中angularjs对象的使用 和原生js中对象的访问是一样的,在中使用dian.的形式进行对象的属性的访问 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!-- 使用angularjs表达式进行对象的绑定 --&gt; &lt;body&gt; &lt;div ng-app=&quot;&quot; ng-init=&quot;obj=&#123;&apos;name&apos;:&apos;gaohui&apos;,&apos;age&apos;:&apos;18&apos;&#125;&quot;&gt; &lt;!--在表达式中输出对象的值--&gt; &#123;&#123;obj.name&#125;&#125; &#123;&#123;obj.age&#125;&#125; &lt;!--使用ng-bind的形式--&gt; &lt;p ng-bind=&quot;obj.name&quot;&gt;&lt;/p&gt; &lt;p ng-bind=&quot;obj.age&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 表达式中angularjs数组的使用 和原生js中对象的访问是一样的,在中使用dian.的形式进行对象的属性的访问 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!-- 使用angularjs表达式进行对象的绑定 --&gt; &lt;body&gt; &lt;div ng-app=&quot;&quot; ng-init=&quot;obj=&#123;&apos;name&apos;:&apos;gaohui&apos;,&apos;age&apos;:&apos;18&apos;&#125;&quot;&gt; &lt;!--在表达式中输出对象的值--&gt; &#123;&#123;obj.name&#125;&#125; &#123;&#123;obj.age&#125;&#125; &lt;!--使用ng-bind的形式--&gt; &lt;p ng-bind=&quot;obj.name&quot;&gt;&lt;/p&gt; &lt;p ng-bind=&quot;obj.age&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"02-ng表达式","slug":"angular1/02-ng表达式","permalink":"http://yoursite.com/categories/angular1/02-ng表达式/"}],"tags":[]},{"title":"AngularJS概述","slug":"angular1/01-ng基础/01-ng基础","date":"2018-05-10T00:34:45.565Z","updated":"2018-05-10T01:10:52.413Z","comments":true,"path":"2018/05/10/angular1/01-ng基础/01-ng基础/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/01-ng基础/01-ng基础/","excerpt":"","text":"AngularJS概述AngularJS简介什么是 AngularJS？ “AngularJS 是专门为应用程序设计的 HTML。” AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。 AngularJS 可以克隆和重复 HTML 元素。 AngularJS 可以隐藏和显示 HTML 元素。 AngularJS 可以在 HTML 元素”背后”添加代码。 AngularJS 支持输入验证。 AngularJS 历史123AngularJS 是比较新的技术，版本 1.0 是在 2012 年发布的。AngularJS 是由 Google 的员工 Miško Hevery 从 2009 年开始着手开发。这是一个非常好的构想，该项目目前已由 Google 正式支持，有一个全职的开发团队继续开发和维护这个库。 AngularJS特点 angular通过新的属性和表达式扩展html angular可以构建一个单页面应用程序 single page application AngularJS 简介 AngularJS 是一个 JavaScript 框架。它可通过 script 标签添加到 HTML 页面。 注意事项: 我们建议把脚本放在 元素的底部。 这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。 AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。 AngularJS 扩展了 HTML123456789AngularJS 通过 ng-directives(指令名) 扩展了 HTML。ng-是angular指令的前缀1. ng-app 指令定义一个 AngularJS 应用程序。2. ng-model 指令把元素值（比如输入域的值）绑定到应用程序。3. ng-bind 指令把应用程序数据绑定到 HTML 视图。4. ng-init 初始化应用程序变量 angularjs的组成 angularjs的组成可以分成三部分 view(视图),即html model(模型)也就是数据 controller(控制器),javascrpt函数,可以添加或修改数据 基本示例基本示例1 ng-app ng-model ng-bind的使用 ng-app 指令定义一个 AngularJS 应用程序。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序。 ng-bind 指令把应用程序数据绑定到 HTML 视图。 v-bind绑定的是i标签的nnerHTML 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--ng-app 指令告诉 AngularJS，&lt;div&gt; 元素是 AngularJS 应用程序 的&quot;所有者&quot;。--&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;!--ng-model 指令把输入域的值绑定到应用程序变量 name。--&gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;!--ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。--&gt; &lt;h1 ng-bind=&quot;name&quot;&gt;hello&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 基本示例2 ng-init的使用 ng-init 初始化应用程序变量 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--ng-app 指令告诉 AngularJS，&lt;div&gt; 元素是 AngularJS 应用程序 的&quot;所有者&quot;。--&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;!--ng-model 指令把输入域的值绑定到应用程序变量 name。--&gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;!--ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。--&gt; &lt;h1 ng-bind=&quot;name&quot;&gt;hello&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 基本示例3 data- html5中自定义属性的应用 AngularJS 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;!-- 在html5中，允许自定义属性，使用data- AngularJS 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。 --&gt; &lt;body&gt; &lt;div data-ng-app=&quot;&quot; data-ng-init=&quot;name=&apos;高辉&apos;&quot; &gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; data-ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;p data-ng-bind=&apos;name&apos;&gt;&lt;/p&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"01-ng基础","slug":"angular1/01-ng基础","permalink":"http://yoursite.com/categories/angular1/01-ng基础/"}],"tags":[]},{"title":"常见的查询","slug":"mysql/03-常见查询操作/03-常见的查询的例子","date":"2018-05-10T00:34:11.100Z","updated":"2018-05-10T01:07:28.993Z","comments":true,"path":"2018/05/10/mysql/03-常见查询操作/03-常见的查询的例子/","link":"","permalink":"http://yoursite.com/2018/05/10/mysql/03-常见查询操作/03-常见的查询的例子/","excerpt":"","text":"常见的查询查询所有 12345678910111213MariaDB [test]&gt; select * from shop;+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0001 | A | 3.45 || 0001 | B | 3.99 || 0002 | A | 10.99 || 0003 | B | 1.45 || 0003 | C | 1.69 || 0003 | D | 1.25 || 0004 | D | 19.95 |+---------+--------+-------+7 rows in set (0.00 sec) 1.获取列的最大值 “最大的物品号是什么？” 123456789101112131415MariaDB [test]&gt; select max(price) from shop;+------------+| max(price) |+------------+| 19.95 |+------------+1 row in set (0.00 sec)MariaDB [test]&gt; select max(price) as price from shop;+-------+| price |+-------+| 19.95 |+-------+1 row in set (0.00 sec) 2.拥有某个列的最大值的行的相关信息 任务：找出最贵物品的编号、销售商和价格。 方式1: 找到最大值直接返回 1234567MariaDB [test]&gt; select * from shop where price=(select max(price) from shop);+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0004 | D | 19.95 |+---------+--------+-------+1 row in set (0.00 sec) 方式2: 倒序排序之后返回第一条 1234567MariaDB [test]&gt; select * from shop order by price desc limit 1;+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0004 | D | 19.95 |+---------+--------+-------+1 row in set (0.00 sec) 3.列的最大值：按组 任务：每项物品的的最高价格是多少？ 1234567891011MariaDB [test]&gt; select article,max(price) as price from shop group by article;+---------+-------+| article | price |+---------+-------+| 0001 | 3.99 || 0002 | 10.99 || 0003 | 1.69 || 0004 | 19.95 |+---------+-------+4 rows in set (0.00 sec) 4.拥有某个字段的组间最大值的行 任务：对每项物品，找出最贵价格的物品的经销商。 123456789101112MariaDB [test]&gt; SELECT article, dealer, price FROM shop s1 -&gt; WHERE price=(SELECT MAX(s2.price) FROM shop s2 WHERE s1.article = s2.article);+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0001 | B | 3.99 || 0002 | A | 10.99 || 0003 | C | 1.69 || 0004 | D | 19.95 |+---------+--------+-------+4 rows in set (0.00 sec) 5.使用用户变量 如下所示,使用用户变量获取当前最大值和最小值 1234567891011121314151617MariaDB [test]&gt; select @min:=min(price),@max:=max(price) from shop;+------------------+------------------+| @min:=min(price) | @max:=max(price) |+------------------+------------------+| 1.25 | 19.95 |+------------------+------------------+1 row in set (0.00 sec)MariaDB [test]&gt; select * from shop where price=@min or price=@max;+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0003 | D | 1.25 || 0004 | D | 19.95 |+---------+--------+-------+2 rows in set (0.00 sec)","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"03-常见查询操作","slug":"mysql/03-常见查询操作","permalink":"http://yoursite.com/categories/mysql/03-常见查询操作/"}],"tags":[]},{"title":"获取 数据库和表的相关信息","slug":"mysql/02-数据库和表的相关信息/02-获取数据库和表的相关信息","date":"2018-05-10T00:34:11.092Z","updated":"2018-05-10T01:07:25.494Z","comments":true,"path":"2018/05/10/mysql/02-数据库和表的相关信息/02-获取数据库和表的相关信息/","link":"","permalink":"http://yoursite.com/2018/05/10/mysql/02-数据库和表的相关信息/02-获取数据库和表的相关信息/","excerpt":"","text":"获取 数据库和表的相关信息数据库 查看所有的数据库 show databases; 查看当前使用的数据库 select database();` 数据表 查看当前数据库下所有的数据表 show tables; 查看表中列的信息 describe pet; 或者是 explain pet; 查看索引信息 show index from pet;","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"02-数据库和表的相关信息","slug":"mysql/02-数据库和表的相关信息","permalink":"http://yoursite.com/categories/mysql/02-数据库和表的相关信息/"}],"tags":[]},{"title":"mysql 的基本使用","slug":"mysql/01-mysql基础/01-mysql基础","date":"2018-05-10T00:34:10.966Z","updated":"2018-05-10T01:09:40.178Z","comments":true,"path":"2018/05/10/mysql/01-mysql基础/01-mysql基础/","link":"","permalink":"http://yoursite.com/2018/05/10/mysql/01-mysql基础/01-mysql基础/","excerpt":"","text":"mysql 的基本使用简介 mysql高版本就是mariadb，完全兼容mysql，都是一家开发的。本来 MariaDB 的描绘初衷之一即是彻底兼容 MySQL，包含 API 和客户端协议，使之能轻松变成 MySQL 的代替品。 链接和断开mysql链接 打开shell命令窗口,输入以下命令 12mysql -h host -u user -p 断开1mysql&gt; QUIT 输入查询基本输入查询 一个查询返回一行,使用逗号 , 分隔多个查询项 12345678910111213// 输入的查询语句MariaDB [(none)]&gt; select version(),current_date,sin(pi()/3),(4+1)*5;// 返回的结果+-----------------+--------------+--------------------+---------+| version() | current_date | sin(pi()/3) | (4+1)*5 |+-----------------+--------------+--------------------+---------+| 10.1.31-MariaDB | 2018-04-24 | 0.8660254037844386 | 25 |+-----------------+--------------+--------------------+---------+1 row in set (0.00 sec) 多行查询 mysql支持多行查询 , 中间使用 分号 ; 隔开 , 也就是说每一个查询都是以分号进行分隔 , 如果不添加分号, 默认开启多行查询 123456789MariaDB [(none)]&gt; select version(),now(),user() -&gt; ;+-----------------+---------------------+----------------+| version() | now() | user() |+-----------------+---------------------+----------------+| 10.1.31-MariaDB | 2018-04-24 19:47:09 | root@localhost |+-----------------+---------------------+----------------+1 row in set (0.00 sec) 数据库使用数据库操作 以下是数据库操作的增删改查的相关命令 创建数据库 create database demo; 删除数据库 drop database demo 查看所有的数据库 show databases; 使用数据库 MariaDB [chat]&gt; use chat; 数据表的使用 在使用数据表之前要先确定在哪个数据库下面开始操作, 先使用 use 数据库 选择要使用的数据库, 也就是说在哪个数据库下面开始进行表的操作 1.创建数据表 create table pet (name varchar(20),owner varchar(20),species varchar(20),sex char(1),birth date,death date); 2.查看数据表show tables; 3.查看表的详细内容 DESCRIBE和 EXPLAIN语句是同义词，或者用于获取有关表结构或查询执行计划的信息 describe – 描述explain – 解释,说明 1234567891011121314151617181920212223242526MariaDB [test]&gt; describe pet;+---------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+-------------+------+-----+---------+-------+| name | varchar(20) | YES | | NULL | || owner | varchar(20) | YES | | NULL | || species | varchar(20) | YES | | NULL | || sex | char(1) | YES | | NULL | || birth | date | YES | | NULL | || death | date | YES | | NULL | |+---------+-------------+------+-----+---------+-------+6 rows in set (0.01 sec)MariaDB [test]&gt; explain pet;+---------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+-------------+------+-----+---------+-------+| name | varchar(20) | YES | | NULL | || owner | varchar(20) | YES | | NULL | || species | varchar(20) | YES | | NULL | || sex | char(1) | YES | | NULL | || birth | date | YES | | NULL | || death | date | YES | | NULL | |+---------+-------------+------+-----+---------+-------+6 rows in set (0.01 sec) field 列名 type 类型 null 是否能为null key 是否被索引 default 列的默认值 extra 如果表有索引，SHOW INDEX FROM tbl_name生成有关索引的信息。MariaDB [test]&gt; show index from pet;+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+| pet | 1 | name | 1 | name | A | 8 | NULL | NULL | YES | BTREE | | |+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+1 row in set (0.00 sec) 增 创建表后，您需要填充它。该 LOAD DATA和 INSERT语句是这个有用的。 1234567// 向数据库中插入内容insert into pet values (1,1,1,1,&apos;2010-1-1&apos;,&apos;2011-1-1&apos;);// 通过本地文件的形式向数据库中插入内容 ---- 读取本地的my.txt文件,将里面的内容插入到数据库// 在数据插入的时候需要固定的数据格式// 每条数据之间都需要一个制表符隔开 也就是一个tab键load data local infile &apos;D:/xampp/htdocs/my.txt&apos; into table pet; 删 删除name=1的数据 delete from pet where name=1; 改 更新所有的数据 update pet set name=1 更新部分数据 update pet set name=&#39;哈哈哈&#39; where name=1; 查 select声明用于从表中提取信息 基本格式 12select ... from ... where ... 查询所有的数据 select * from pet 选择特定的行 select * from pet where name=1 select * from pet where birth&gt;&#39;1994-11-11&#39;; and select * from where name=1 &amp;&amp; age=2 or select * from where anme=1 or age=2 and和or的连用 select * from where (name=1 and age=2) or (name=3 and age=4) 选择查看特定的列 查看name这一列的数据 select name from pet 查看name这一列的不重复的数据 select distinct name from pet; 组合语句 select name from pet where name=1 排序查询 order desc 使用 order by 实现查询 select * from pet order by name; 默认排序的情况是不区分大小写的, 在排序的时候区分大小写 select * from pet order by binary name; 降序排列 desc ,在使用 order by 的时候进行排序默认的是升序排序,使用倒序的话 ,需要添加 desc 关键字, 实例如下 select * from pet order by name desc; 对多个列进行排序 123456789101112131415161718192021// 先根据name进行排序,再根据birth进行逆序排序MariaDB [test]&gt; select * from pet order by name,birth desc;+------+-------+---------+------+------------+------------+| name | owner | species | sex | birth | death |+------+-------+---------+------+------------+------------+| 1 | NULL | NULL | NULL | 1999-10-10 | NULL || 1 | 1 | 1 | 1 | 0000-00-00 | 0000-00-00 || 2 | 2 | 2 | 2 | 1995-11-11 | 0000-00-00 |+------+-------+---------+------+------------+------------+3 rows in set (0.00 sec)// 先根据name进行排序,再根据birth进行升序排序MariaDB [test]&gt; select * from pet order by name,birth;+------+-------+---------+------+------------+------------+| name | owner | species | sex | birth | death |+------+-------+---------+------+------------+------------+| 1 | 1 | 1 | 1 | 0000-00-00 | 0000-00-00 || 1 | NULL | NULL | NULL | 1999-10-10 | NULL || 2 | 2 | 2 | 2 | 1995-11-11 | 0000-00-00 |+------+-------+---------+------+------------+------------+3 rows in set (0.00 sec) 日期计算 表操作获取当前日期 curdate() 表操作获取当前月份 month(birth) 时间计算 timestampdiff(年份,开始时间,结束时间)123456789101112MariaDB [test]&gt; select name,birth, curdate(),timestampdiff(year,birth,curdate()) as age from pet order by name;+------+------------+------------+------+| name | birth | curdate() | age |+------+------------+------------+------+| 1 | 2018-04-25 | 2018-04-25 | 0 || 1 | 2018-04-25 | 2018-04-25 | 0 || 2 | 1999-10-10 | 2018-04-25 | 18 || 2 | 1995-11-11 | 2018-04-25 | 22 || 3 | 2018-04-26 | 2018-04-25 | 0 || 4 | 2018-04-17 | 2018-04-25 | 0 |+------+------------+------------+------+6 rows in set (0.00 sec) 匹配模式 - like 查询所有的内容 12345678910111213MariaDB [test]&gt; select * from pet order by name;+------+-------------+---------+------+------------+------------+| name | owner | species | sex | birth | death |+------+-------------+---------+------+------------+------------+| 1 | qibaobao | 1 | 1 | 2018-04-25 | 2018-04-20 || 1 | gaohui | 1 | 1 | 2018-04-25 | 2018-04-28 || 2 | fengbin | 2 | 2 | 1999-10-10 | 2018-04-05 || 2 | suming | 2 | 2 | 1995-11-11 | 2018-04-17 || 3 | xiaotibai | 3 | 3 | 2018-04-26 | 2018-04-29 || 4 | wanghongyan | 4 | 4 | 2018-04-17 | 2018-04-30 || 5 | hahha | 5 | 5 | 2018-12-31 | 2019-01-01 |+------+-------------+---------+------+------------+------------+7 rows in set (0.00 sec) 查询以…开头的like像MariaDB [test]&gt; select * from pet where owner like &#39;q%&#39;; 查询以 … 结束的 likeMariaDB [test]&gt; select * from pet where owner like &#39;%a&#39;; 查询包含 … 的 likeMariaDB [test]&gt; select * from pet where owner like &#39;%a%&#39;; 查找含有指定字符个数的内容 —- 五个字符MariaDB [test]&gt; select * from pet where owner like &#39;_____&#39;; 扩展正则表达式`MariaDB [test]&gt; select * from pet where owner regexp ‘^a’; 计数行-分组 [test]> select name,count(*) from pet group by name;```123456788. 多表查询 - 查询两张表的数据`SELECT event.name,remark,type FROM pet INNER JOIN event ON pet.name = event.name` - 其他 mysql&gt; SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species -&gt; FROM pet AS p1 INNER JOIN pet AS p2 -&gt; ON p1.species = p2.species AND p1.sex = ‘f’ AND p2.sex = ‘m’;+——–+——+——–+——+———+| name | sex | name | sex | species |+——–+——+——–+——+———+| Fluffy | f | Claws | m | cat || Buffy | f | Fang | m | dog || Buffy | f | Bowser | m | dog |+——–+——+——–+——+———+ `","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"01-mysql基础","slug":"mysql/01-mysql基础","permalink":"http://yoursite.com/categories/mysql/01-mysql基础/"}],"tags":[]},{"title":"基本开发环境","slug":"react/555-开发环境搭建/555-1-react基本开发环境搭建","date":"2018-05-08T00:22:58.136Z","updated":"2018-05-08T00:49:49.165Z","comments":true,"path":"2018/05/08/react/555-开发环境搭建/555-1-react基本开发环境搭建/","link":"","permalink":"http://yoursite.com/2018/05/08/react/555-开发环境搭建/555-1-react基本开发环境搭建/","excerpt":"","text":"基本开发环境基本使用 在页面中使用引入 123456&lt;!--react的核心库--&gt;&lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;!--react的与dom相关的一些功能--&gt;&lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;!--将浏览器不支持的jsx语法转化为js语法--&gt;&lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; 开发环境搭建 使用 create-react-app 快速构建 React 开发环境 安装项目模板 基于webpack快速搭建开发环境 1.全局安装开发环境 1npm install -g create-react-app 2.创建react项目 1create-react-app my-app 3.切换目录 12345678cd my-app辅助cmd命令: mkdir del rmdir tree 4.启动应用程序 12npm start 目录结构解析 使用 tree /f &gt; tree.txt 命令生成项目目录结构 1234567891011121314151617├─ .gitignore│ package.json│ README.md│ ├─public│ favicon.ico│ index.html│ manifest.json│ └─src App.css App.js App.test.js index.css index.js logo.svg registerServiceWorker.js","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"555-开发环境搭建","slug":"react/555-开发环境搭建","permalink":"http://yoursite.com/categories/react/555-开发环境搭建/"}],"tags":[]},{"title":"组合和继承","slug":"react/22-组合和继承/22-组合和继承","date":"2018-05-08T00:22:58.120Z","updated":"2018-05-08T00:50:15.950Z","comments":true,"path":"2018/05/08/react/22-组合和继承/22-组合和继承/","link":"","permalink":"http://yoursite.com/2018/05/08/react/22-组合和继承/22-组合和继承/","excerpt":"","text":"组合和继承","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"22-组合和继承","slug":"react/22-组合和继承","permalink":"http://yoursite.com/categories/react/22-组合和继承/"}],"tags":[]},{"title":"react编程思想","slug":"react/23-react编程思想/23-react编程思想","date":"2018-05-08T00:22:58.120Z","updated":"2018-05-08T00:49:55.454Z","comments":true,"path":"2018/05/08/react/23-react编程思想/23-react编程思想/","link":"","permalink":"http://yoursite.com/2018/05/08/react/23-react编程思想/23-react编程思想/","excerpt":"","text":"react编程思想","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"23-react编程思想","slug":"react/23-react编程思想","permalink":"http://yoursite.com/categories/react/23-react编程思想/"}],"tags":[]},{"title":"状态提升","slug":"react/21-状态提升/21-状态提升","date":"2018-05-08T00:22:58.105Z","updated":"2018-05-08T00:41:29.337Z","comments":true,"path":"2018/05/08/react/21-状态提升/21-状态提升/","link":"","permalink":"http://yoursite.com/2018/05/08/react/21-状态提升/21-状态提升/","excerpt":"","text":"状态提升","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"21-状态提升","slug":"react/21-状态提升","permalink":"http://yoursite.com/categories/react/21-状态提升/"}],"tags":[]},{"title":"redux","slug":"react/16-redux/16-redux","date":"2018-05-08T00:22:58.105Z","updated":"2018-05-08T00:41:14.464Z","comments":true,"path":"2018/05/08/react/16-redux/16-redux/","link":"","permalink":"http://yoursite.com/2018/05/08/react/16-redux/16-redux/","excerpt":"","text":"redux 状态管理 redux是将整个应用程序的状态存储到一个地方, 称为store","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"16-redux","slug":"react/16-redux","permalink":"http://yoursite.com/categories/react/16-redux/"}],"tags":[]},{"title":"react-router","slug":"react/12-router/12-router","date":"2018-05-08T00:22:58.089Z","updated":"2018-05-08T00:41:02.421Z","comments":true,"path":"2018/05/08/react/12-router/12-router/","link":"","permalink":"http://yoursite.com/2018/05/08/react/12-router/12-router/","excerpt":"","text":"react-router路由的基本实现注意事项 Router或者说是 BrowserRouter 的内部 只能有一个根元素 1.引入相关的包 12345import &#123; BrowserRouter as Router, Route, Link&#125; from &apos;react-router-dom&apos; 2.创建组件并导入 123456789101112131415161718192021222324252627282930313233343536373839404142// 创建home组件import React , &#123;Component&#125; from &quot;react&quot;export class Home extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;// 创建About组件import React , &#123;Component&#125; from &quot;react&quot;export class About extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;关于&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;// 创建topic组件import React , &#123;Component&#125; from &quot;react&quot;export class Topic extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;主题&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;import &#123;Home&#125; from &apos;./home/home&apos;import &#123;About&#125; from &apos;./about/about&apos;import &#123;Topic&#125; from &apos;./topic/topic&apos; 3-4.完善路由跳转链接和路由信息配置 123456789101112131415161718192021222324&lt;Router&gt; &lt;div&gt; &#123;/*3. 定义路由跳转的链接*/&#125; &lt;ul&gt; &lt;li&gt; &lt;Link to=&apos;/&apos;&gt;首页&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&apos;/about&apos;&gt;关于&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&apos;/topic&apos;&gt;主题&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr/&gt; &#123;/*4. 配置路由信息*/&#125; &#123;/*exact : 确切的 精确的*/&#125; &lt;Route exact path=&apos;/&apos; component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path=&apos;/about&apos; component=&#123;About&#125;&gt;&lt;/Route&gt; &lt;Route path=&apos;/topic&apos; component=&#123;Topic&#125;&gt;&lt;/Route&gt; &lt;/div&gt;&lt;/Router&gt; 二级路由 在上述代码的基础上修改 Topic 组件 ,可以实现二级路由 注意事项 获取一级路由信息, 类组件使用 this.props , 函数式组件使用 props 参数 在路由跳转的时候进行拼接url &lt;Link to={${props.url}/topic2}&gt;topic2&lt;/Link&gt; &lt;Route path={${props.url}/topic1} component={Topic1}&gt;&lt;/Route&gt; 路由参数的获取 使用 console.log(props.match.params.id) 具体内容参考以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import React , &#123;Component&#125; from &quot;react&quot;import &#123;BrowserRouter as Router,Route, Link&#125; from &quot;react-router-dom&quot;// 主题组件1function Topic1 () &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )&#125;// 主题组件2function Topic2 () &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )&#125;// 主题组件3function Topic3 (props) &#123; // 获取传递的id参数 console.log(props.match.params.id) return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )&#125;// 函数式组件 ---- 路由创建2function BasicExample2 (props) &#123; console.log(props.url) return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;props.url&#125;/topic1`&#125;&gt;topic1&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;props.url&#125;/topic2`&#125;&gt;topic2&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;props.url&#125;/topic3`&#125;&gt;topic3&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=&#123;`$&#123;props.url&#125;/topic1`&#125; component=&#123;Topic1&#125;&gt;&lt;/Route&gt; &lt;Route path=&#123;`$&#123;props.url&#125;/topic2`&#125; component=&#123;Topic2&#125;&gt;&lt;/Route&gt; &lt;Route path=&#123;`$&#123;props.url&#125;/topic3`&#125; component=&#123;Topic3&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/Router&gt; )&#125;export class Topic extends Component&#123; render()&#123; console.log(this.props.match.path) return ( &lt;div&gt; &lt;h2&gt;主题&lt;/h2&gt; &lt;BasicExample2 url=&#123;this.props.match.path&#125;&gt;&lt;/BasicExample2&gt; &lt;/div&gt; ) &#125;&#125; api文档BrowserRouter","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"12-router","slug":"react/12-router","permalink":"http://yoursite.com/categories/react/12-router/"}],"tags":[]},{"title":"forms","slug":"react/10-form/10-forms","date":"2018-05-08T00:22:58.073Z","updated":"2018-05-08T00:40:47.420Z","comments":true,"path":"2018/05/08/react/10-form/10-forms/","link":"","permalink":"http://yoursite.com/2018/05/08/react/10-form/10-forms/","excerpt":"","text":"forms表单概述 HTML 表单元素与 React 中的其他 DOM 元素有所不同，因为表单元素自然地保留了一些内部状态。例如，这个纯 HTML 表单接受一个单独的 name： 1234567&lt;form&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 该表单和 HTML 表单的默认行为一致，当用户提交此表单时浏览器会打开一个新页面。如果你希望 React 中保持这个行为，也可以工作。但是多数情况下，用一个处理表单提交并访问用户输入到表单中的数据的 JavaScript 函数也很方便。实现这一点的标准方法是使用一种称为“受控组件(controlled components)”的技术。 受控组件Controll 在 HTML 中，表单元素如 &lt;input&gt;，&lt;textarea&gt; 和 &lt;select&gt;表单元素通常保持自己的状态，并根据用户输入进行更新。而在 React 中，可变状态一般保存在组件的 state(状态) 属性中，并且只能通过 setState()更新。 我们可以通过使 React 的 state 成为 “单一数据源原则”来结合这两个形式。然后渲染表单的 React 组件也可以控制在用户输入之后的行为。这种形式，其值由 React 控制的输入表单元素称为“受控组件”。 数据/状态的定义: 使用 this.state = {} 状态的修改: this.state.setState({}) 12345678910111213141516171819202122232425262728293031323334 // 定义类组件class NameForms extends React.Component&#123; constructor(props)&#123; super(props) // 定义状态 this.state = &#123;value:&apos;&apos;&#125; // 函数可以产生独立作用域 ,在这里修改函数内部的指针指向 当前组件(类) this.handleChange = this.handleChange.bind(this) this.handleSubmit = this.handleSubmit.bind(this) &#125; handleChange(e)&#123; this.setState(&#123;value:e.target.value&#125;) &#125; handleSubmit(e)&#123; alert(&quot;A name was submitted : &quot; + this.state.value) e.preventDefault() &#125; render()&#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label for=&quot;&quot;&gt; name : &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ) &#125;&#125;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"10-form","slug":"react/10-form","permalink":"http://yoursite.com/categories/react/10-form/"}],"tags":[]},{"title":"react数据请求","slug":"react/08-数据请求/08-fetchApi-数据请求","date":"2018-05-08T00:22:58.042Z","updated":"2018-05-08T00:40:36.587Z","comments":true,"path":"2018/05/08/react/08-数据请求/08-fetchApi-数据请求/","link":"","permalink":"http://yoursite.com/2018/05/08/react/08-数据请求/08-fetchApi-数据请求/","excerpt":"","text":"react数据请求参考文档 https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch 基本使用cdn链接1&lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; get请求静态数据 最初的时候, 渲染页面 , 数据都是写在本页面 这样操作的问题是修改页面内容不方便, 只能通过操作本页面完成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[ &#123;&quot;id&quot;:&quot;123001&quot;,&quot;name&quot;:&quot;xiaoming&quot;&#125;, &#123;&quot;id&quot;:&quot;123002&quot;,&quot;name&quot;:&quot;xiaobing&quot;&#125;, &#123;&quot;id&quot;:&quot;123003&quot;,&quot;name&quot;:&quot;xiaona&quot;&#125; ] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; json文件 实现页面结构和数据的分离, 修改页面内容的时候, 操作文件即可 以json文件为例, 修改json文件之后, 我们页面的内容也会发生变化 json文件定义—-数据定义 12345[ &#123;&quot;id&quot;:&quot;123001&quot;,&quot;name&quot;:&quot;xiaoming&quot;&#125;, &#123;&quot;id&quot;:&quot;123002&quot;,&quot;name&quot;:&quot;xiaobing&quot;&#125;, &#123;&quot;id&quot;:&quot;123003&quot;,&quot;name&quot;:&quot;xiaona&quot;&#125;] 请求json文件,完成页面的渲染 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &quot;data.json&quot; var option = &#123; methods:&quot;get&quot; &#125; fetch(url,option).then((res)=&gt;&#123; return res.json() &#125;).then((res)=&gt;&#123; // 请求到的数据 console.log(res) // 修改state this.setState(&#123; arr:res &#125;) // 打印输出 console.log(this.state.arr) &#125;) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 数据库 为了便于数据的操作, 我们平时看到的页面上的数据一般都是存在数据库的, 通过后台管理系统, 能够很方便的实现数据的修改 – 此例 不多做演示 在线接口 书写数据接口, 通过后台操作, 读取数据库数据, 并做成接口的形式, 我们需要对数据进行操作的时候,直接操作接口即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; [&#123;&quot;id&quot;:&quot;123001&quot;,&quot;name&quot;:&quot;xiaoming&quot;&#125;,&#123;&quot;id&quot;:&quot;123002&quot;,&quot;name&quot;:&quot;xiaobing&quot;&#125;,&#123;&quot;id&quot;:&quot;123003&quot;,&quot;name&quot;:&quot;xiaona&quot;&#125;] class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &quot;http://www.taoquan.store/robot/getUsers.php&quot; var option = &#123; methods:&quot;get&quot; &#125; fetch(url,option).then((res)=&gt;&#123; return res.json() &#125;).then((res)=&gt;&#123; // 请求到的数据 console.log(res.users) // 修改state this.setState(&#123; arr:res.users &#125;) // 打印输出 console.log(this.state.arr) &#125;) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; post请求 将数据提交到数据库 基本示例 在真正操作的时候只需要将要提交的数据换成表单数据即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; num:1 &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &apos;http://127.0.0.1:8899/api/insertData&apos; var options = &#123; method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125;, body: &apos;name=1&amp;sex=2&amp;email=3&amp;phone=4&amp;address=5&apos; &#125; fetch(url,options) .then((res)=&gt;&#123; return res.json() &#125;) .then((res)=&gt;&#123; console.log(res) &#125;) &#125; &#125; ReactDOM.render( &lt;Com&gt;&lt;/Com&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 核心代码1234567891011121314151617var url = &apos;http://127.0.0.1:8899/api/insertData&apos;var options = &#123; method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125;, body: &apos;name=1&amp;sex=2&amp;email=3&amp;phone=4&amp;address=5&apos;&#125;fetch(url,options).then((res)=&gt;&#123; return res.json()&#125;).then((res)=&gt;&#123; console.log(res)&#125;) 第二种方式12345678910111213141516171819202122componentDidMount()&#123; var data = &#123; name:&quot;1&quot;, sex:&quot;2&quot;, email:&quot;3&quot;, phone:&quot;4&quot;, address:&quot;5&quot; &#125; fetch(&apos;http://127.0.0.1:8899/api/insertData&apos;,&#123; method: &apos;POST&apos;, body: `data=$&#123;JSON.stringify(data)&#125;`, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125; &#125;) .then((res)=&gt;&#123; console.log(res.json()) &#125;)&#125; 文件上传 Content-Type：上传文件的时候，一定要设置为application/x-www-form-urlencoded 跨域fetch跨域概述 在fetch的配置中有 mode选项 , 提供了跨域的能力 mode: ‘cors’, // no-cors, cors, *same-origin mode:’cors’ 这个选项提供了跨域的能力, 但是服务端必须支持 cors ,也就是设置 res.header(“Access-Control-Allow-Origin”, “*”); mode:’no-cors’ 可以跨域进行数据请求 , 不需要设置跨域 header 在该模式下 得到的返回数据中 type为opaque。, 能够在控制台看到返回的数据, 但是没有权限使用这些数据 mode:”same-origin” 同源, 不允许跨域 并不能成功跨域进行数据的访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &quot;https://api.douban.com/v2/movie/top250&quot; // var url = &apos;http://127.0.0.1:8899/api/selectData&apos; var option = &#123; methods:&quot;get&quot;, mode:&apos;no-cors&apos; &#125; fetch(url,option).then((res)=&gt;&#123; console.log(res) &#125;) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 使用jsonp调取数据 在原生js中, 利用script标签的支持跨域的特性进行 第一种方式 利用script标签的跨域访问特性 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSONP实现跨域2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--代码的先后顺序 不能变--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn(response)&#123; console.log(response); &#125;&lt;/script&gt;&lt;script src=&quot;https://api.douban.com/v2/movie/top250?callback=fn&quot;&gt;&lt;/script&gt; 第二种方式 动态创建script标签 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSONP实现跨域2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--代码的先后顺序 不能变--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn(response)&#123; console.log(response); &#125; var script = document.createElement(&apos;script&apos;) script.src = &apos;https://api.douban.com/v2/movie/top250?callback=fn&apos; document.body.insertBefore(script, document.body.firstChild); &lt;/script&gt; 第三种方式 使用jquery 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; type:&apos;get&apos;, url:&quot;https://api.douban.com/v2/movie/top250?callback=?&quot;, success(res)&#123; console.log(res) &#125;, dataType:&quot;jsonp&quot; &#125;) &lt;/script&gt; 项目中使用 create-react-app fetchApi的使用 npm 地址 https://www.npmjs.com/package/whatwg-fetch 详细的使用说明可以参考这个文档 12345671. 安装 npm install whatwg-fetch --save2. 配置 在使用webpack的时候,需要完成这一步的配置 entry: [&apos;whatwg-fetch&apos;, ...]3. 使用 直接导入这个包即可 import &apos;whatwg-fetch&apos; 请求html文件12345678HTMLfetch(&apos;/users.html&apos;) .then(function(response) &#123; return response.text() &#125;).then(function(body) &#123; document.body.innerHTML = body &#125;) get 请求获取数据 在componentDidMount(){}生命周期钩子中进行数据的初始化操作 1.在构造函数中初始化状态(数据) 1234567constructor(props)&#123; super(props) this.state = &#123; arr:[], name:&quot;test&quot; &#125;&#125; 2.在 componentDidMount 中发送请求,获取数据 12345678910111213141516componentDidMount() &#123; console.log(1) fetch(&apos;http://gaohuimusic.nat123.cc:11444/personalized&apos;) .then((response) =&gt; &#123; return response.json() &#125;).then((json) =&gt; &#123; console.log(&apos;parsed json&apos;, json) this.setState(&#123; arr:json.result &#125;) console.log(this.state.arr) &#125;).catch(function(ex) &#123; console.log(&apos;parsing failed&apos;, ex) &#125;)&#125; 3.在render()函数中完成页面渲染—-将请求到的数据渲染到页面 1234567891011121314render() &#123; return ( &lt;div&gt; &lt;p&gt;这是tab1&lt;/p&gt; &lt;div&gt; &lt;ul&gt; &#123;this.state.arr.map(function(ele,index,arr)&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; )&#125; post 请求","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"08-数据请求","slug":"react/08-数据请求","permalink":"http://yoursite.com/categories/react/08-数据请求/"}],"tags":[]},{"title":"组件补充","slug":"react/07-组件补充/07-组件补充","date":"2018-05-08T00:22:57.995Z","updated":"2018-05-08T00:40:22.704Z","comments":true,"path":"2018/05/08/react/07-组件补充/07-组件补充/","link":"","permalink":"http://yoursite.com/2018/05/08/react/07-组件补充/07-组件补充/","excerpt":"","text":"组件补充组件的嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1.1 创建一个基本的组件 function Welcome(props)&#123; return ( &lt;div&gt; &lt;p&gt;&#123;props.name&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; // 1.2 创建一个app组件,并使用Welcome组件 function App(props)&#123; return ( &lt;div&gt; &lt;Welcome name=&quot;1&quot;&gt;&lt;/Welcome&gt; &lt;Welcome name=&quot;2&quot;&gt;&lt;/Welcome&gt; &lt;Welcome name=&quot;3&quot;&gt;&lt;/Welcome&gt; &lt;/div&gt; ) &#125; var element = &lt;App&gt;&lt;/App&gt; // 2. 组件的使用 ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 公共组件的提取12 props总结props是只读的 所有 React 组件都必须是纯函数，并禁止修改其自身 props 。 知识点扩充纯函数 不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。 123function sum(a, b) &#123; return a + b;&#125; 非纯函数 改变了自身的输入值 123function withdraw(account, amount) &#123; account.total -= amount;&#125;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"07-组件补充","slug":"react/07-组件补充","permalink":"http://yoursite.com/categories/react/07-组件补充/"}],"tags":[]},{"title":"组件传值","slug":"react/06-组件传值/06-组件传值","date":"2018-05-08T00:22:57.964Z","updated":"2018-05-08T00:52:18.304Z","comments":true,"path":"2018/05/08/react/06-组件传值/06-组件传值/","link":"","permalink":"http://yoursite.com/2018/05/08/react/06-组件传值/06-组件传值/","excerpt":"","text":"组件传值 每个组件 的作用域都是独立的, 有时候需要在组件之间完成数据的传递,需要通过组件传值的方式来实现 组件传值可以分为以下三类 父组件向子组件传递数据 子组件向父组件传递数据 非父子组件之间的数据传递 父传子 – 简化版函数式组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot; class=&quot;parent&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个函数组件 ---- 使用props完成值得接收 function Child(props)&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; ReactDOM.render( // 渲染组件 并通过name属性完成传值 &lt;Child name=&quot;3&quot;&gt;&lt;/Child&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个类组件 class Child extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Child name=&quot;1&quot;&gt;&lt;/Child&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 组件传值详解1234567我们调用了 ReactDOM.render() 方法并向其中传入了 &lt;Child name=&quot;1&quot; /&gt; 元素。React 调用 Child 组件，并向其中传入了 &#123;name: &apos;1&apos;&#125; 作为 props 对象。Child 组件返回 &lt;li&gt;1&lt;/li&gt;。React DOM 迅速更新 DOM ，使其显示为 &lt;li&gt;1&lt;/li&gt;。 父传子 – 完整版函数式组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个父组件 function Parent()&#123; return ( &lt;div&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &#123;/*在父组件中嵌套子组件*/&#125; &lt;Child name=&quot;1&quot;&gt;&lt;/Child&gt; &lt;/div&gt; ) &#125; // 创建一个子组件 列表 function Child(props)&#123; return ( &lt;div&gt; &lt;h3&gt;这是子组件&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&#123;props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; // 2. 组件的使用 ReactDOM.render( &lt;Parent&gt;&lt;/Parent&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个类组件 -- 父 class Parent extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &#123;/*在父组件中嵌套子组件*/&#125; &lt;Child name=&quot;1&quot;&gt;&lt;/Child&gt; &lt;/div&gt; ) &#125; &#125; // 创建一个类组件 -- 子 class Child extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;h3&gt;这是子组件&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Parent&gt;&lt;/Parent&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 子传父函数式组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; //子组件 function Child(props)&#123; return ( &lt;div&gt; &#123;/*当文本框内容发生变化的时候.会执行父组件里面的事件*/&#125; 子组件：&lt;input onChange=&#123;props.handleEmail&#125;/&gt; &lt;/div&gt; ) &#125; //父组件 function Parent() &#123; return ( &lt;div&gt; &lt;div id=&apos;div&apos;&gt;父组件：&#123;1&#125;&lt;/div&gt; &lt;Child name=&quot;email&quot; handleEmail=&#123; function (event)&#123; /*获取子组件的数据*/ console.log(event.target.value) document.getElementById(&apos;div&apos;) = event.target.value &#125; &#125;/&gt; &lt;/div&gt; ) &#125; ReactDOM.render( &lt;Parent /&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; //子组件 class Child extends React.Component&#123; render()&#123; return ( &lt;div&gt; &#123;/*当文本框内容发生变化的时候.会执行父组件里面的事件*/&#125; 子组件：&lt;input onChange=&#123;this.props.handleEmail&#125;/&gt; &lt;/div&gt; ) &#125; &#125; //父组件 class Parent extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; email:&apos;&apos; &#125; &#125; handleEmail(event)&#123; this.setState(&#123;email: event.target.value&#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;div&gt;父组件：&#123;this.state.email&#125;&lt;/div&gt; &lt;Child name=&quot;email&quot; handleEmail=&#123;this.handleEmail.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Parent /&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 非父子非父子组件传值之兄弟组件传值 使用中间人模式 , 定义一个公共的父组件来实现兄弟组件之间的数据传递 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Brother1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.props.refresh&#125;&gt; 更新兄弟组件 &lt;/button&gt; &lt;/div&gt; ) &#125; &#125; class Brother2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.text || &quot;兄弟组件未更新&quot;&#125; &lt;/div&gt; ) &#125; &#125; class Parent extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; refresh()&#123; return (e)=&gt;&#123; this.setState(&#123; text: &quot;兄弟组件沟通成功&quot;, &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;兄弟组件沟通&lt;/h2&gt; &lt;Brother1 refresh=&#123;this.refresh()&#125;/&gt; &lt;Brother2 text=&#123;this.state.text&#125;/&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;Parent /&gt;, document.getElementById(&apos;root&apos;));&lt;/script&gt; 使用jquery自定义事件完成传值 根据上面理解的思路, 使用jquery的事件机制作为中间人, 实现数据的传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Com1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; $(&apos;#root&apos;).on(&apos;bus&apos;,function(e,a,b)&#123; console.log(a,b) &#125;) &#125; &#125; class Com2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; $(&apos;#root&apos;).trigger(&apos;bus&apos;,[11,22]) &#125; &#125; ReactDOM.render( &lt;div&gt; &lt;Com1&gt;&lt;/Com1&gt; &lt;Com2&gt;&lt;/Com2&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;));&lt;/script&gt; 使用原生js的方式实现组件之间的数据的传递 上述使用jquery能够实现数据的传递,但是这样操作的话, 并不是最佳的方式 如果我们只是为了实现组件之间的数据传递而引入jquery框架, 会使项目变得臃肿 为了更好的体验, 我们可以使用原生js的自定义事件的方式完成组件之间的数据的传递 注意事项: 在这里,只是关注与功能的实现, 不考虑兼容性的问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 给dom元素绑定事件 ---- 作为中间人 var elem = document.getElementById(&apos;root&apos;) var events = new Event(&apos;build&apos;); class Com1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; // 给dom元素添加事件监听, 通过函数参数完成数据的接收 elem.addEventListener(&apos;build&apos;, function (event) &#123; console.log(event.name) &#125;, false); &#125; &#125; class Com2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; name:&apos;我是小高&apos; &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; events.name = this.state.name elem.dispatchEvent(events) &#125; &#125; ReactDOM.render( &lt;div&gt; &lt;Com1&gt;&lt;/Com1&gt; &lt;Com2&gt;&lt;/Com2&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;));&lt;/script&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"06-组件传值","slug":"react/06-组件传值","permalink":"http://yoursite.com/categories/react/06-组件传值/"}],"tags":[]},{"title":"state和生命周期","slug":"react/05-state和生命周期/05-state和生命周期","date":"2018-05-08T00:22:57.933Z","updated":"2018-05-08T00:40:00.388Z","comments":true,"path":"2018/05/08/react/05-state和生命周期/05-state和生命周期/","link":"","permalink":"http://yoursite.com/2018/05/08/react/05-state和生命周期/05-state和生命周期/","excerpt":"","text":"state和生命周期state state 允许 React 组件在不违反props规则的情况下, 根据用户操作, 网络响应, 或者其他随便什么东西, 来动态地改变其输出。类似于vue中的data state的定义 在类组件的constructor中定义state 12345678constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;; &#125; 状态的修改不能直接修改state 需要调用this.setState() 12345678910// 错误 这样将不会重新渲染一个组件：this.state.comment = &apos;Hello&apos;;// 正确 用 setState() 代替：this.setState(&#123;comment: &apos;Hello&apos;&#125;);唯一可以分配 this.state 的地方是构造函数。 state(状态) 更新可能是异步的使用回调函数的形式实现异步操作 需要将对象参数转变为回调函数的形式 1234567891011121314// 错误this.setState(&#123; counter: this.state.counter + this.props.increment,&#125;);// 正确this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;));使用另一种 setState() 的形式，它接受一个函数而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数： state(状态)更新会被合并你的状态可能包含几个独立的变量： 12345678constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125; 调用this.setState()修改单个的状态不会影响其他的状态,只会合并当前修改的这一个状态 react-hook函数hook函数的基本概念hook函数参考链接 https://baike.baidu.com/item/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0?fr=aladdin 钩子函数是window消息处理机制的一部分,通过设置”钩子”,应用程序可以在系统级对所有消息,事件进行过滤,访问在正常情况下无法访问的消息 钩子函数的本质是一段用以处理系统消息的程序,通过系统调用,把它挂入系统 react组件的三个状态1.mount123react Components被render解析生成对应的dom节点被插入浏览器的dom结构的一个过程在浏览器上看到组件元素从无到有的过程 2.update 1234一个mounte的react Component被重新render的过程,但是在这个过程中,dom结构并不一定会发生改变在react中,状态的改变会触发update的hook函数 3.unmount 1一个mount的react Component对应的dom节点被从dm中移除的一个过程 react针对以上三种状态都封装了hook函数 生命周期钩子详解mounting 如下这些方法在组件实例被创建和被插入到dom中时被调用。 1.constructor() constructor初始化state的好地方。如果我们不需要初始化state，也不需要bind任何方法，那么在我们的组件中不需要实现constructor函constructor在组件被mounted之前调用，我们的组件继承自React.Component,constructor函数中我们在其他操作前应该先调用super(props)，否则this.props将会是undefined。 constructor初始化state的好地方。如果我们不需要初始化state，也不需要bind任何方法，那么在我们的组件中不需要实现constructor函数。 注意下面这种情况，很容易产生bug，我们通常的做法是提升state到父组件，而不是使劲的同步state和props。 123456constructor(props) &#123; super(props); this.state = &#123; color: props.initialColor &#125;;&#125; componentWillMount() 此方法在mounting之前被立即调用，它在render()之前调用，因此在此方法中setState不会触发重新渲染。此方法是服务器渲染中调用的唯一的生命周期钩子，通常我们建议使用constructor()。 render() render()方法是react组件必须的，它检查this.props和this.state并且返回一个React元素，我们也可以返回null或false，代表我们不想有任何的渲染。 render()方法应该是一个纯方法，即它不会修改组件的state，在每一次调用时返回同样的结果。它不直接和浏览器交互，如果我们想要交互，应该在componentDidMount()或者其他的生命周期函数里面。 componentDidMount() 此方法在组件被mounted之后立即被调用，初始化dom节点应该在此方法中，如果需要从远端健在数据，这里是实例化网络请求的好地方，此方法中setState会触发组件重新渲染。 Updating props和state的改变产生更新。在重新渲染组建时，如下的方法被调用 componentWillReceiveProps() 一个已经mounted的组件接收一个新的props之前componentWillReceiveProps()被调用，如果我们需要更新state来响应prop的更改，我们可以在此方法中比较this.props和nextProps并使用this.setState来更改state。 注意，即使props没有改变，React也可以调用这个方法，因此如果你只想处理改变，请确保比较当前值和下一个值。当父组件导致你的组件重新渲染时，可能会发生这种情况。 React在组件mounting期间不会调用此方法，只有在一些组件的props可能被更新的时候才会调用。调用this.setState通常不会触发componentWillReceiveProps。 shouldComponentUpdate() 使用此方法让React知道组件的输出是否不受当前state或props更改的影响。默认行为是在每次state更改时重新渲染组件，在大多数情况下，我们应该默认改行为。 当接收到新的props或state时，shouldComponentUpdate()在渲染之前被调用。默认返回true，对于初始渲染或使用forceUpdate()时，不调用此方法。返回false不会阻止子组件的state更改时，该子组件重新渲染。 如果shouldComponentUpdate()返回false，那么componentWillUpdate()，render()和componentDidUpdate()将不会被调用。在将来，React可能将shouldComponentUpdate()作为提示而不是strict指令，返回仍然可能导致组件重新渲染。 componentWillUpdate() 当接收新的props或state时，componentWillUpdate()在组件渲染之前被立即调用。使用此函数作为在更新发生之前执行准备的机会。初始渲染不会调用此方法。 注意：这里不能调用this.setState()(如果调用会怎么样？好奇心很重呀，试了一下，会产生死循环，一直更新。 如果我们需要更新state以响应props的更改，我们应该使用componentWillReceiveProps() render() render()方法是react组件必须的，它检查this.props和this.state并且返回一个React元素，我们也可以返回null或false，代表我们不想有任何的渲染。 render()方法应该是一个纯方法，即它不会修改组件的state，在每一次调用时返回同样的结果。它不直接和浏览器交互，如果我们想要交互，应该在componentDidMount()或者其他的生命周期函数里面。 componentDidUpdate() 此函数在更新后立即被调用。初始渲染不调用此方法。 当组件已经更新时，使用此操作作为DOM操作的机会。这也是一个好的地方做网络请求，只要你比较当前的props和以前的props(例如：如果props没有改变，可能不需要网络请求)。 Unmounting 当从dom中移除组件时，这个方法会被调用 componentWillUnmount() 此函数在组件被卸载和销毁之前被立即调用。在此方法中执行一些必要的清理。例如清除计时器，取消网络请求或者清理在componentDidMount中创建的任何DOM元素。 实例演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/babel\"&gt; // 创建一个类组件 class LifeCycle extends React.Component &#123; // 1. mount阶段 constructor(props) &#123; super(props); this.state = &#123;name: 'wlt'&#125;; this.changeState = this.changeState.bind(this); console.log('constructor'); &#125; componentWillMount() &#123; console.log('componentWillMount'); &#125; render() &#123; console.log('render'); return ( &lt;div className=\"life-cycle-bg\"&gt; &lt;p&gt;Hello &#123;this.props.value&#125;&lt;/p&gt; &lt;p&gt;Hello &#123;this.state.name&#125;&lt;/p&gt; &lt;button onClick=&#123;this.changeState&#125;&gt;改变lifeCycle的state&lt;/button&gt; &lt;/div&gt; ); &#125; componentDidMount() &#123; console.log('componentDidMount'); &#125; // 2. update阶段 componentWillReceiveProps(nextProps) &#123; // 只作用于属性的变化,不作用于状态的变化 console.log('componentWillReceiveProps'); &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log('shouldComponentUpdate'); return true; &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('componentWillUpdate'); &#125; // ---- render会重新执行 componentDidUpdate(prevProps, prevState) &#123; console.log('componentDidUpdate'); &#125; // 3. Unmount阶段 componentWillUnmount(prevProps, prevState) &#123; console.log('componentWillUnmount'); &#125; // 修改状态 changeState() &#123; this.setState(&#123;name: 'sxm'&#125;); &#125; &#125; class ParentLifeCycle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: 'World', destroyed: false, rerender: false &#125;; this.handleChange = this.handleChange.bind(this); this.destroyComponent = this.destroyComponent.bind(this); this.handleRerender = this.handleRerender.bind(this); &#125; handleChange() &#123; this.setState((prevState, props) =&gt; (&#123; value: prevState.value + ' wlt' &#125;)); &#125; handleRerender() &#123; this.setState(&#123;rerender: true&#125;); &#125; destroyComponent() &#123; this.setState(&#123;destroyed: true&#125;); &#125; render() &#123; if(this.state.destroyed) return null; return ( &lt;div className=\"parent-life-cycle-bg\"&gt; &lt;p&gt; &lt;button onClick=&#123;this.handleChange&#125;&gt;改变LifeCyle的props&lt;/button&gt; &lt;button onClick=&#123;this.handleRerender&#125;&gt;父组件重新渲染，子组件re-render&lt;/button&gt; &lt;button onClick=&#123;this.destroyComponent&#125;&gt;删除组件&lt;/button&gt; &lt;/p&gt; &lt;LifeCycle value=&#123;this.state.value&#125;/&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;ParentLifeCycle /&gt;, document.getElementById('root') );&lt;/script&gt; state 和 生命周期一个简单的例子 实现一个基本的定时器功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个组件 -- 使用函数式组件 function Clock()&#123; // 创建元素 const element = ( &lt;div&gt; &lt;h1&gt;hello world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) // 使用render函数渲染已经创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &#125; setInterval(Clock,1000)&lt;/script&gt; 存在的问题 完成定时器的功能,使用组件化的形式进行封装的时候,在进行组件调用的时候应该能够直接通过 就能完成一个定时器,而不用再配合外部的js操作 这样做的话能够实现相关的功能,但是不利于复用 改写 使用组件的形式封装一个计时器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 在组件挂载和卸载的时候,会执行对应的生命周期钩子函数 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 使用类的形式对组件进行改写之后,我们可以向类中添加一些内容 class Clock extends React.Component&#123; constructor(props)&#123; // 类组件应始终使用 props 调用基础构造函数。 super(props) // 使用状态进行改写 this.state = &#123; date:new Date() &#125; &#125; // 组件挂载的生命周期钩子函数 componentDidMount()&#123; console.log(&quot;组件挂载了&quot;) this.timer = setInterval(()=&gt;&#123; // 使用this.setState() 更新本地的状态 this.setState(&#123; date:new Date() &#125;) &#125;,1000) &#125; // 组件卸载时会执行的生命周期钩子函数 componentWillUnmount()&#123; console.log(&quot;组件卸载了&quot;) clearInterval(this.timer) &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;hello world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125; &#125; // 使用render函数渲染已经创建的组件 ----- 三个组件互补影响 ReactDOM.render( &lt;div&gt; &lt;Clock&gt;&lt;/Clock&gt; &lt;Clock&gt;&lt;/Clock&gt; &lt;Clock&gt;&lt;/Clock&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"05-state和生命周期","slug":"react/05-state和生命周期","permalink":"http://yoursite.com/categories/react/05-state和生命周期/"}],"tags":[]},{"title":"组件","slug":"react/04-组件基本使用/04-组件基本使用","date":"2018-05-08T00:22:57.901Z","updated":"2018-05-08T00:39:42.075Z","comments":true,"path":"2018/05/08/react/04-组件基本使用/04-组件基本使用/","link":"","permalink":"http://yoursite.com/2018/05/08/react/04-组件基本使用/04-组件基本使用/","excerpt":"","text":"组件什么是组件 组成的部件 组件使你可以将 UI 划分为一个一个独立，可复用的小部件，并可以对每个部件进行单独的设计。 从定义上来说， 组件就像JavaScript的函数。封装内容, 达到重用的目的. 组件可以接收任意输入(称为”props”)， 并返回 React 元素，用以描述屏幕显示内容 为什么使用组件 封装 重用 如何使用组件 在使用组件的时候, 推荐使用类组件的形式 注意事项 组件的名称 首字母必须大写 一个组件只能有一个根元素 两种组件创建的方式函数式组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1. 创建一个基本的组件 function Welcome()&#123; return ( &lt;div&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;/div&gt; ) &#125; // 2. 组件的使用 ReactDOM.render( &lt;Welcome&gt;&lt;/Welcome&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt; &lt;script type=&quot;text/babel&quot;&gt; // 1. 创建一个基本的组件 class Welcome extends React.Component&#123; render ()&#123; return ( &lt;div&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;/div&gt; ) &#125; &#125; // 2. 组件的使用 ReactDOM.render( &lt;Welcome&gt;&lt;/Welcome&gt;, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 补充类组件的事件绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Toggle extends React.Component &#123; constructor(props) &#123; super(props); // 设置状态 this.state = &#123;isToggleOn: true&#125;; // 这个绑定是必要的，使`this`在回调中起作用 this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; ); &#125; &#125; ReactDOM.render( &lt;Toggle /&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"04-组件基本使用","slug":"react/04-组件基本使用","permalink":"http://yoursite.com/categories/react/04-组件基本使用/"}],"tags":[]},{"title":"jsx语法","slug":"react/02-jsx语法/02-jsx语法","date":"2018-05-08T00:22:57.870Z","updated":"2018-05-08T00:39:25.715Z","comments":true,"path":"2018/05/08/react/02-jsx语法/02-jsx语法/","link":"","permalink":"http://yoursite.com/2018/05/08/react/02-jsx语法/02-jsx语法/","excerpt":"","text":"jsx语法什么是jsx语法语法特点 react使用jsx代替常规的javascript 1234567891011 1. 一个很像是XML的js语法扩展 2. 编写模板更加快速-简单 3. 它是类型安全的,在编译的过程中就能发现错误``` ### 使用规则&gt; react jsx的使用 1. 可以创建一个独立的js文件来使用,通过script标签来引入 2. 使用多个标签,使用div包裹 3. 支持表达式, js表达式可以直接被解析 4. 不支持if else 可以使用三元表达式代替 相当于是vue中 的 v-if 5. 直接解析数组 相当于是vue中的v-for 6. 标签中注释使用花括号包裹,区别于原先的js注释 , 否则的话 , 注释会 直接解析成文本 7. 推荐使用内联样式 直接进行样式的绑定 相当于是vue中的 v-bind 123456789101112131415161718## 为什么使用jsx语法&gt; jsx语法允许html和js的混写, 使页面数据和样式的操作变得钢架简单**核心**- 遇到 `HTML` 标签（以 `&lt;` 开头），就用 `HTML` 规则解析；- 遇到 以 `&#123;` 开头的结构，就用 `js` 规则解析；## 如何使用jsx语法### 标签渲染**遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；** &lt;!DOCTYPE html&gt; Hello World // ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( Hello, world!, document.getElementById(‘root’) ); // 如果{} 渲染的变量是一个数组,jsx语法会解析里面的所有成员并添加到模板 var arr = [ Hello world!, React is awesome ]; ReactDOM.render( {arr}, document.getElementById(‘example’) ) 1234### 代码注释&gt; 在jsx语法中, 标签中写代码注释需要放到&#123;&#125; 中&lt;!DOCTYPE html&gt; Hello World // ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( /注释/ Hello, world! {/注释要加上{} 要不然直接解析成文本/} , document.getElementById(‘root’) ); var i=1; ReactDOM.render( {/*如果是多个标签,推荐使用div包裹*/} react jsx的使用 {/*支持使用js表达式*/} {1+1} {/*不能使用if else 语句,可以使用三元表达式代替*/} {i == 1 ? 'True!' : 'False'} , document.getElementById('example') ); 12### 属性值的绑定 v-bind : &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; var obj = { id:1 } // 属性值的绑定 ReactDOM.render( test, document.getElementById(\"root\") ) 1234### 注意事项**模板部分不能有多个根节点** Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; var obj = { id:1, img:\"./img/01.jpg\" } // 属性值的绑定 ReactDOM.render( , document.getElementById(\"root\") ) 12345678### 事件处理 v-on @&gt; 在react中的事件处理和dom操作类似,但是有一点细微的区别**注意事项:** 1. React 事件使用驼峰命名，而不是全部小写 2. 通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串 12#### dom事件绑定 click me function fn(){ alert(1) } 12#### react事件绑定 Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建元素 var element = ( &lt;button onClick={fn}&gt;click me&lt;/button&gt; ) function fn(){ alert(1) } // 使用render渲染已创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 123#### react的html和js混写 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建元素 var element = ( &lt;button onClick={fn}&gt;click me&lt;/button&gt; ) function fn(){ alert(1) } // 使用render渲染已创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 12#### 事件参数传递 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建元素 绑定事件, 添加事件处理函数 var element = ( &lt;button onClick={ function(e){ console.log(e.target) } }&gt;click me&lt;/button&gt; ) // 使用render渲染已创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 12345### 条件渲染 v-if&gt; 在jsx语法中,使用三元表达式可以实现这一项功能 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; ReactDOM.render( { Math.random()*10>5?这是内容1:这是内容2 } , document.getElementById('root') ); 1234### 列表渲染 v-for&gt; 在jsx语法中, 使用map函数完成这一项功能 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--提供react的dom操作的相关功能--&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;!--jsx语法 支持标签和js的混写--&gt; &lt;script type=&quot;text/babel&quot;&gt; var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; ReactDOM.render( &lt;div&gt; { names.map(function(ele,index,arr){ /*Each child in an array or iterator should have a unique &quot;key&quot; prop.*/ return &lt;h1&gt;{ele}&lt;/h1&gt; }) } &lt;/div&gt;, document.getElementById(&apos;example&apos;) ) &lt;/script&gt; &lt;/body&gt; 123456## jsx深入理解### jsx语法的基本实现 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; //内联样式 var myStyle = { color:\"red\" } // 使用jsx语法创建模板 const element1 = ( Hello, world! ); ReactDOM.render( element1, document.getElementById('root') ); 1234### React.createElement()**从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖** Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; // 使用对象表示 法 // 从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖 const element2 = React.createElement( 'div', {className:\"greeting\"}, '哈哈' ) // 类似于这样一种简化的结构 const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, world' } }; ReactDOM.render( element2, document.getElementById('root') ); 12345678## react数据变化检测--元素渲染&gt; 元素(Elements)是 React 应用中最小的构建部件（或者说构建块，building blocks）。&gt; &gt; &gt; &gt; 元素用于描述你在页面上看到的内容### 页面的基本渲染 Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; // 创建元素 var element = Hello, world! //使用render 渲染函数渲染已创建的元素到指定的位置 ReactDOM.render( element, document.getElementById('root') ); 123456### 元素的更新**在React中,元素是不能发生突变的,要进行元素的,一旦创建了元素,就不能修改其子元素或者是相关的属性****元素更新的措施是: 创建一个新的元素并使用render函数重新渲染** Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; function tick() { // 创建元素 const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); //使用render函数进行页面的渲染 ReactDOM.render( element, document.getElementById('root') ); } setInterval(tick, 1000); 12345678910111213### 页面变化检测与更新的实现原理- react维护两个状态——现在的页面DOM、即将要渲染的页面DOM（数据) 两部分进行对比：自动渲染不同部分。- 每次发生事件、动画，都会和之前的状态进行对比。 - 相同：不再次进行渲染。 - 不同：进行渲染界面。 - 适合大量数据操作的框架——react。参考链接 https://zhuanlan.zhihu.com/purerender/2034637 在react中,当元素发生变化的时候,并不会进行所有的元素的更新, 在react内部,执行了一个diff 算法,只对当前变化的节点进行检测更新,而不是更新所有的节点 在react中,使用diff + virtual dom 结合的方式,实现元素的变化检测与更新 `","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"02-jsx语法","slug":"react/02-jsx语法","permalink":"http://yoursite.com/categories/react/02-jsx语法/"}],"tags":[]},{"title":"react入门","slug":"react/01-react入门/01-react入门","date":"2018-05-08T00:22:57.839Z","updated":"2018-05-08T00:42:47.547Z","comments":true,"path":"2018/05/08/react/01-react入门/01-react入门/","link":"","permalink":"http://yoursite.com/2018/05/08/react/01-react入门/01-react入门/","excerpt":"","text":"react入门– 案例驱动—示例 react是什么 React 是一个用于构建用户界面的 JAVASCRIPT 库。 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 起源 React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站 描述12345678由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单这个项目本身也越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案。衍生的 React Native 项目，目标更是宏伟，希望用写 Web App 的方式去写 Native App。如果能够实现，整个互联网行业都会被颠覆，因为同一组人只需要写一次 UI ，就能同时运行在服务器、浏览器和手机 为什么使用reactreact的特点12345671.声明式设计 −React采用声明范式，可以轻松描述应用。2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3.灵活 −React可以与已知的库或框架很好地配合。4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 以下描述仅仅是个人理解 单向数据流12在React中，数据的流向是单向的——从父节点传递到子节点，因为组件是简单而且易于把握的，他们只需从父节点获取props渲染即可，如果顶层组件的某个prop改变饿了，React会递归的向下便利整棵组件树，重新渲染所有使用这个属性的组件。 声明式设计12345678910111213141516171819202122232425262728// 声明式const element1 = React.createElement( &apos;div&apos;, &#123;className:&quot;greeting&quot;&#125;, &apos;哈哈&apos;)// 过程式element2 = document.createElement &apos;div&apos;element2.className = &apos;greeting&apos;element2.innerHTML = &apos;哈哈&apos;// 类似于这样一种简化的结构const element = &#123; type: &apos;h1&apos;, props: &#123; className: &apos;greeting&apos;, children: &apos;Hello, world&apos; &#125;&#125;;ReactDOM.render( element1, document.getElementById(&apos;root&apos;) ); 组件 两大特性 封装 重用 优势虚拟dom 虚拟dom 用于性能的提升 组件化 组件化 , 实现代码的重用 如何使用react hello world 示例 hello world示例js核心库 react的使用离不开三个核心的库 1234567891011// 新版本 &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt;// 久版本 &lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react-dom.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js&quot;&gt;&lt;/script&gt; hello world示例 最小化的 HTML 模板 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;!-- &lt;script&gt; 标签的 type 属性为 text/babel 。 这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。 凡是使用 JSX 的地方，都要加上 type=&quot;text/babel&quot; 。 --&gt; &lt;script type=&quot;text/babel&quot;&gt; // ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- -&gt; CDNReact 和 ReactDOM 的UMD版本可通过 CDN 获得。 开发环境12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 生产环境 相比开发环境进行了压缩和优化 12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.production.min.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; crossorigin如果你从 CDN 引用 React，我们建议保留 crossorigin 属性设置：","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"01-react入门","slug":"react/01-react入门","permalink":"http://yoursite.com/categories/react/01-react入门/"}],"tags":[]},{"title":"react优质学习资源","slug":"react/00-学习资料参考/00-学习资料参考","date":"2018-05-08T00:22:57.823Z","updated":"2018-05-08T00:38:56.423Z","comments":true,"path":"2018/05/08/react/00-学习资料参考/00-学习资料参考/","link":"","permalink":"http://yoursite.com/2018/05/08/react/00-学习资料参考/00-学习资料参考/","excerpt":"","text":"react优质学习资源官方文档fetchfetch CDN https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetchfetch CDN https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API react基本知识点react中文文档 http://www.css88.com/react/docs/portals.html react英文文档 https://reactjs.org/docs/react-api.html react中文网 http://www.reactchina.cn/ react生命周期 https://facebook.github.io/react/docs/react-component.html reduxredux中文文档 http://www.redux.org.cn/docs/react-redux/api.html react路由react路由的官方文档 https://react-guide.github.io/react-router-cn/docs/API.html react web http://reacttraining.cn react v4 中文文档 http://reacttraining.cn/web/guides/quick-start react-router http://reacttraining.cn/web/example/basic 文档博客书籍类阮一峰 也许dom不是答案 http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html react入门实例教程 http://www.ruanyifeng.com/blog/2015/03/react 开源项目类基于webpack、react、react-router 4.0、antd-m的App项目 https://github.com/liwudi/online-educationApp react-native https://github.com/liwudi/qingqi-auto-owner-app.git react https://github.com/liwudi/online-educationApp.git 视频类大众点评项目实战 https://coding.imooc.com/class/package/99.html#Anchor","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"00-学习资料参考","slug":"react/00-学习资料参考","permalink":"http://yoursite.com/categories/react/00-学习资料参考/"}],"tags":[]},{"title":"介绍","slug":"hello-world","date":"2018-05-07T22:30:03.040Z","updated":"2018-05-08T00:58:03.617Z","comments":true,"path":"2018/05/08/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/08/hello-world/","excerpt":"","text":"独白 我只是一小白","categories":[],"tags":[]}]}