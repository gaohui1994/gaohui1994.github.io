{"meta":{"title":"GaoHui","subtitle":"Note","description":"Note","author":"GaoHui","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2018-05-07T22:37:51.189Z","updated":"2018-05-07T22:37:51.189Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-05-07T22:37:51.180Z","updated":"2018-05-07T22:37:51.180Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-07T22:37:51.204Z","updated":"2018-05-07T22:37:51.204Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"203-render","slug":"vue/203-render/203-render","date":"2018-05-10T02:06:33.578Z","updated":"2018-05-10T01:37:40.628Z","comments":true,"path":"2018/05/10/vue/203-render/203-render/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/203-render/203-render/","excerpt":"","text":"render VUE一般使用template来创建HTML，然后在有的时候，我们需要使用javascript来创建html，这时候我们需要使用render函数。 render函数基础dom渲染 比如渲染一下dom元素 可以直接进行元素的添加,document.getElementById(“container”).innerHTML = “” 123&lt;div id=&quot;container&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;Hello world!&lt;/a&gt;&lt;/h1&gt;&lt;/div&gt; vue的dom渲染12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&apos;tb-heading&apos;, &#123; template: ` &lt;a href=&quot;#&quot;&gt;Hello world!&lt;/a&gt; ` &#125;); new Vue(&#123; el: &apos;#container&apos; &#125;);&lt;/script&gt; slot分发1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;container&quot;&gt; &lt;tb-heading :level=&quot;2&quot;&gt; &lt;a href=&quot;#&quot;&gt;Hello world!&lt;/a&gt; &lt;/tb-heading&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&apos;tb-heading&apos;, &#123; template: ` &lt;h1 v-if=&quot;level === 1&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-else-if=&quot;level === 2&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; `, props: &#123; level: &#123; type: Number, required: true &#125; &#125; &#125;); new Vue(&#123; el: &apos;#container&apos; &#125;);&lt;/script&gt; render改写 createElement返回的是包含的信息会告诉VUE页面上需要渲染什么样的节点及其子节点。我们称这样的节点为虚拟DOM，可以简写为VNode， 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;container&quot;&gt; &lt;tb-heading :level=&quot;1&quot;&gt; &lt;a href=&quot;#&quot;&gt;Hello world!&lt;/a&gt; &lt;/tb-heading&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&apos;tb-heading&apos;, &#123; render: function(createElement) &#123; console.log(this.$slots.default) return createElement( &apos;h&apos; + this.level, // tag name 标签名称 this.$slots.default // 组件的子元素 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125; &#125;); new Vue(&#123; el: &apos;#container&apos; &#125;);&lt;/script&gt; createElement参数 12345678910111213141516171819202122232425// @return &#123;VNode&#125;createElement( // &#123;String | Object | Function&#125; // 一个HTML标签字符串，组件选项对象，或者一个返回值类型为String/Object的函数。该参数是必须的 &apos;div&apos;, // &#123;Object&#125; // 一个包含模板相关属性的数据对象，这样我们可以在template中使用这些属性，该参数是可选的。 &#123; &#125;, // &#123;String | Array&#125; // 子节点（VNodes）由 createElement() 构建而成。可选参数 // 或简单的使用字符串来生成的 &quot;文本节点&quot;。 [ &apos;xxxx&apos;, createElement(&apos;h1&apos;, &apos;一则头条&apos;), createElement(MyComponent, &#123; props: &#123; someProp: &apos;xxx&apos; &#125; &#125;) ]) 深入理解createElement的数据对象 在模板语法中，我们可以使用 v-bind:class 和 v-bind:style 来绑定属性，在VNode数据对象中，下面的属性名的字段级别是最高的。该对象允许我们绑定普通的html特性，就像DOM属性一样。如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; // 和`v-bind:class`一样的 API &apos;class&apos;: &#123; foo: true, bar: false &#125;, // 和`v-bind:style`一样的 API style: &#123; color: &apos;red&apos;, fontSize: &apos;14px&apos; &#125;, // 正常的 HTML 特性 attrs: &#123; id: &apos;foo&apos; &#125;, // 组件 props props: &#123; myProp: &apos;bar&apos; &#125;, // DOM 属性 domProps: &#123; innerHTML: &apos;baz&apos; &#125;, // 事件监听器基于 `on` // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅对于组件，用于监听原生事件，而不是组件内部使用 `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意事项：不能对绑定的旧值设值 // Vue 会为您持续追踪 directives: [ &#123; name: &apos;my-custom-directive&apos;, value: &apos;2&apos;, expression: &apos;1 + 1&apos;, arg: &apos;foo&apos;, modifiers: &#123; bar: true &#125; &#125; ], // Scoped slots in the form of // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement(&apos;span&apos;, props.text) &#125;, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: &apos;name-of-slot&apos;, // 其他特殊顶层属性 key: &apos;myKey&apos;, ref: &apos;myRef&apos;&#125; render扩展循环渲染v-modelslot函数式组件 函数式组件我们标记组件为 functional, 意味着它无状态(没有data), 无实列(没有this上下文)。一个函数式组件像下面这样的： 123456789101112Vue.component(&apos;my-component&apos;, &#123; functional: true, // 为了弥补缺少的实列 // 提供第二个参数作为上下文 render: function(createElement, context) &#123; &#125;, // Props 可选 props: &#123; &#125;&#125;) 12345678910组件需要的一切通过上下文传递，包括如下：props: 提供props对象children: VNode子节点的数组slots: slots对象data: 传递给组件的data对象parent： 对父组件的引用listeners: (2.3.0+) 一个包含了组件上所注册的 v-on 侦听器的对象。这只是一个指向 data.on 的别名。injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。在添加 functional: true 之后，组件的 render 函数之间简单更新增加 context 参数，this.$slots.default 更新为 context.children，之后this.level 更新为 context.props.level。 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;演示Vue&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;choice&gt; &lt;item value=&quot;1&quot;&gt;test&lt;/item&gt; &lt;/choice&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component(&apos;choice&apos;, &#123; template: &apos;&lt;div&gt;&lt;ul&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/ul&gt;&lt;/div&gt;&apos; &#125;); Vue.component(&apos;item&apos;, &#123; functional: true, render: function(h, context) &#123; return h(&apos;li&apos;, &#123; on: &#123; click: function() &#123; console.log(context); console.log(context.parent); console.log(context.props) &#125; &#125; &#125;, context.children) &#125;, props: [&apos;value&apos;] &#125;) new Vue(&#123; el: &apos;#container&apos;, data: &#123; msg: &apos;hello&apos; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"203-render","slug":"vue/203-render","permalink":"http://yoursite.com/categories/vue/203-render/"}],"tags":[]},{"title":"201-axios补充","slug":"vue/202-axios扩展/202-axios补充","date":"2018-05-10T02:06:33.557Z","updated":"2018-05-10T01:37:31.607Z","comments":true,"path":"2018/05/10/vue/202-axios扩展/202-axios补充/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/202-axios扩展/202-axios补充/","excerpt":"","text":"","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"202-axios扩展","slug":"vue/202-axios扩展","permalink":"http://yoursite.com/categories/vue/202-axios扩展/"}],"tags":[]},{"title":"16-虚拟dom","slug":"vue/201-虚拟动漫/201-虚拟dom原理","date":"2018-05-10T02:06:33.522Z","updated":"2018-05-10T01:37:08.318Z","comments":true,"path":"2018/05/10/vue/201-虚拟动漫/201-虚拟dom原理/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/201-虚拟动漫/201-虚拟dom原理/","excerpt":"","text":"虚拟dom虚拟dom技术用于提高页面更新的速度 dom操作 之前所学习的dom操作是比较浪费时间和性能的 更新DOM是非常昂贵的操作 123456当我们使用Javascript来修改我们的页面，浏览器已经做了一些工作，以找到DOM节点进行更改，例如：document.getElementById(&apos;myId&apos;).appendChild(myNewNode);在现代的应用中，会有成千上万数量个DOM节点。所以因更新的时候产生的计算非常昂贵。琐碎且频繁的更新会使页面缓慢，同时这也是不可避免的。 虚拟dom技术 使用js对象来替代dom节点 DOM节点在HTML文档中的表现通常是这样的： 1234&lt;ul id=&apos;myId&apos;&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt;&lt;ul&gt; DOM节点也可以表示为一个JavaScript对象，就像这样： 12345678//用Javascript代码表示DOM节点的伪代码Let domNode = &#123; tag: &apos;ul&apos; attributes: &#123; id: &apos;myId&apos; &#125; children: [//这里是 li ]&#125;; 更新虚拟节点 123456789//更新虚拟DOM的代码domNode.children.push(&apos;&lt;ul&gt;Item 3&lt;/ul&gt;&apos;);如果我们用一个虚拟DOM，而不是直接调用像.getElementById的方法，这样只操作JavaScript对象，这样是相当便宜的。然后，再把更改的部分更新到真正的DOM，方法如下：//这个方法是调用DOM API来更改真正DOM的//它会分批执行从而获取更高的效率sync(originalDomNode, domNode); dom和虚拟dom的分析引入虚拟DOM实际上有优点也缺点。 12345678910尺寸 更多的功能意味着更多的代码。幸运的是Vue.js 2.0仍然是相当小的（21.4kb当前版本）。 内存 虚拟DOM需要在内存中的维护一份DOM的副本。在DOM更新速度和使用内存空间之间取得平衡。不是适合所有情况 如果虚拟DOM大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟DOM将会花费更多的时间处理计算的工作。 所以，如果你有一个DOM节点相对较少页面，用虚拟DOM，它实际上有可能会更慢。 但对于大多数单页面应用，这应该都会更快。","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"201-虚拟动漫","slug":"vue/201-虚拟动漫","permalink":"http://yoursite.com/categories/vue/201-虚拟动漫/"}],"tags":[]},{"title":"15-ui","slug":"vue/15-UI库/15-Muse UI","date":"2018-05-10T02:06:33.483Z","updated":"2018-05-10T01:36:53.899Z","comments":true,"path":"2018/05/10/vue/15-UI库/15-Muse UI/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/15-UI库/15-Muse UI/","excerpt":"","text":"第十五部分 UI 框架 在这一单元给大家介绍三种基于vue的UI框架 1.Muse UI Muse UI参考链接 2.Mint UI Mint UI参考链接 3.Element UI Element UI参考链接 三种框架使用的简单对比 Muse UI 上已述及,三种框架在基本使用上没有太大差异,在这里,我们就围绕Muse UI做一个简单讲解 知识点详解Muse UI概述[Muse UI官网](http://www.muse-ui.org) 什么是Muse UI 是一个基于vue2.0和material design的ui组件库 material design: Google推出的一种全新的设计语言 为什么使用Muse UI1.组件丰富 多功能组件，使用无忧 Muse UI 基本实现了 Material Design 设计规范类的所有组件，另外还开发许多的功能性的组件 2.可定制 自定义主题文件，更易扩展 Muse UI 使用less文件，所有的颜色都有一个变量维护，通过编写 less 文件完成自定义主题，另外组件内部也提供一些修改效果的参数 3.基于vue2.0 基于 Vue 2.0，开发更加快速 Muse UI 基于 Vue2.0 开发，Vue2.0是当下最快的前端框架之一，小巧，api友好，可用于开发的复杂单页应用 Muse UI的基本使用Muse UI在正常页面中的使用(以引入的方式)1.引入图标和字体 Muse-UI 使用了 material design 的字体和图标，需要在网页中引入。 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/icon?family=Material+Icons&quot;&gt; 2.使用 script 标签 12&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/muse-ui.css&quot;&gt;&lt;script src=&quot;__dirname/muse-ui.js&quot;&gt;&lt;/script&gt; Muse UI在vue-cli中的安装与使用 在配合我们的vue-cli使用的时候,需要先安装,然后在main.js中导入我们安装的模块才能够使用 在项目目录下打开git或cmd进行安装1npm install --save muse-ui 安装完成后,在main.js中导入模块(模块的加载)1234//使用Muse UIimport MuseUI from &apos;muse-ui&apos;import &apos;muse-ui/dist/muse-ui.css&apos;Vue.use(MuseUI) 图示: Muse UI的主题与颜色的设置 由于接下来的课程中我们主要是配合vue-cli来做项目,Muse UI的使用也是主要学习这方面的相关知识 概述 我们可以通过Muse UI来自定义自己喜欢的主题与颜色 详情请参考: 主题设置: Muse UI Theme 颜色设置: Muse UI Color 配置好需要的环境1.安装: 在webpack-simple这个版本下面需要自己配置less和css环境 npm i –save-dev less less-loader css-loader style-loader 2.配置文件 webpack.config.js,对我们使用到的less和css进行配置 配置自己的主题1.创建自己的主题文件(less文件) 参考: Muse UI Theme 2.在我们需要的样式下引入这个less文件就可以达到修改主题和颜色的目的 基础组件的使用 类似于我们之前学过的bootstrap,Muse UI帮我们预定义好了一些组件,需要的时候直接拿来用就可以了,使用的方式也较为简单 组件参考链接 1.查找组件 找到我们需要的组件,查看那个组件和我们需要的页面结构相似 2.拷贝代码 3.修改样式 4.需要的话再补充js代码 部分Muse UI组件的样式是通过js来控制的 今日知识点总结 ##","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"15-UI库","slug":"vue/15-UI库","permalink":"http://yoursite.com/categories/vue/15-UI库/"}],"tags":[]},{"title":"14-模板","slug":"vue/14-vue-cli/14-vue-cli","date":"2018-05-10T02:06:33.360Z","updated":"2018-05-10T01:36:45.056Z","comments":true,"path":"2018/05/10/vue/14-vue-cli/14-vue-cli/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/14-vue-cli/14-vue-cli/","excerpt":"","text":"第十四部分 vue项目模板项目模板概述Vue.js官方提供了两种类型的模板项目： 基于vue cli和browserify的项目模板 基于vue cli和webpack的项目模板 vue cli是Vue.js官方提供的命令行创建Vue.js项目脚手架的工具。这两种类型的项目模板分别提供了简单模式和完全模式简单模式仅包含基于vue.js开发必要的一些资源和包，使用该模式可以快速地投入到开发。完全模式则还包括ESLink、单元测试等功能。 browserify Browserify是一个CommonJS风格的模块及依赖管理工具，它不仅是一个打包工具，更关键的是其JavaScript的模块及依赖管理能力。 Browserify参照了Node中的模块系统，约定用require()来引入其他模块，用module.exports来引出模块 生成项目模板 browserify-simple1.安装node和npm环境 2.使用npm安装vue-cli 1npm install -g vue-cli 3.使用vue-browserify-simple模板 12//执行以下命令vue init browserify-simple my-browserify-simple-demo 4.生成的项目的文件目录结构 12345678910├─.babelrc // babel配置文件├─.gitignore ├─index.html // 主页├─package.json // 项目配置文件├─README.md ├─dist // 发布目录│ ├─.gitkeep ├─src // 开发目录 │ ├─App.vue // App.vue组件│ ├─main.js // 预编译入口 5.package.json文件是项目配置文件，除了项目的一些基本信息外，有3个重要的节点：123dependencies：项目发布时的依赖devDependencies：项目开发时的依赖scripts：编译项目的一些命令 6..babelrc文件 .babelrc文件定义了ES6的转码规则，基于ES6编写的js代码在编译时都会被babel转码器转换为ES5代码。1234&#123; &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;]&#125; 7.查看目录-安装依赖项 12cd my-browserify-simple-demonpm install 8.运行示例 在执行该命令后，dist目录下会生成一个build.js文件。 1npm run dev 编译过程说明build.js文件是怎么产生的呢？我们把它分为两种情况： 开发时生成build.js发布时生成build.js 开发时成成build.js 在package.json文件的scripts节点下，有3行配置： 12345&quot;scripts&quot;: &#123; &quot;watchify&quot;: &quot;watchify -vd -p browserify-hmr -e src/main.js -o dist/build.js&quot;, &quot;serve&quot;: &quot;http-server -c 1 -a localhost&quot;, &quot;dev&quot;: &quot;npm-run-all --parallel watchify serve&quot;&#125; npm run dev命令执行的是dev节点对应的命令npm-run-all –parallel watchify serve ，这行命令是依赖于watchify的，也就是下面这行命令： watchify -vd -p browserify-hmr -e src/main.js -o dist/build.js你不用纠结这行命令的每个参数是什么意思，只需要理解src/main.js –o dist/build.js的含义： 编译src/main.js文件，然后输出到dist/build.jsserve节点的命令http-server -c 1 -a localhost用于开启http-server，http-server是一个简易的web服务器。 发布时生成build.js 1&quot;build&quot;: &quot;cross-env NODE_ENV=production browserify src/main.js | uglifyjs -c warnings=false -m &gt; dist/build.js&quot; 执行npm run build命令可以生成发布时的build.js。 vue-browserify模板-区别于simple版本 simple-browserify模板用于构筑基于browserify和vueify的开发环境，browserify模板则提供了更多内容： 提供了ESLint：用于格式化JavaScript和检查JavaScript代码风格。 提供了单元测试：使用PhantomJS with Karma + karma-jasmine + karma-browserify的单元测试, 支持ES2015和mock。 1.生成项目 12vue init browserify my-browserify-demo//browserify是项目模板，my-browserify-demo是项目名称。 2.目录结构 1234567891011121314151617├─.babelrc // babel配置文件├─.eslintrc // eslint配置文件├─.gitignore ├─index.html // 主页├─karma.conf.js // karma配置文件├─package.json // 项目配置文件├─README.md ├─dist // 发布目录│ ├─.gitkeep ├─src // 开发目录 │ ├─App.vue // App.vue组件│ ├─main.js // 预编译入口│ ├─components // 组件目录│ ├──Hello.vue // Hello.vue组件├─test // 单元测试目录 │ ├─unit │ ├──Hello.spec.js // Hello.vue单元测试 3.安装项目依赖：12cd my-browserify-demonpm install 4.运行示例1npm run dev webpack简单模式 - webpack-simple vue-cli 的 基本安装步骤 1.Node.js安装 2.安装vue-cli 安装的时间有点长,稍作等待 1npm install -g vue-cli 3.使用vue-cli初始化项目-简单版本 12vue init webpack-simple my-webpack-simple-dem// 版本 项目名称 4、进到目录1cd my-webpack-simple-demo 5、安装依赖 1npm install 6、开始运行1npm run dev 7.打包上线 1npm run build 完全模式安装以及下载步骤 123456789全局安装 vue-cli npm install --global vue-cli创建一个基于 webpack 模板的新项目: vue init webpack my-project安装依赖: cd my-project npm install运行: npm run dev打包上线: npm run build","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"14-vue-cli","slug":"vue/14-vue-cli","permalink":"http://yoursite.com/categories/vue/14-vue-cli/"}],"tags":[]},{"title":"502-笔记","slug":"vue/502-其他/502-笔记","date":"2018-05-10T01:32:35.079Z","updated":"2018-05-10T01:38:56.220Z","comments":true,"path":"2018/05/10/vue/502-其他/502-笔记/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/502-其他/502-笔记/","excerpt":"","text":"复习 1&gt; 框架的代码 1) 核心模块 工具方法( 静态, 实例 ) 框架核心结构( 原型 ) 实现方式不止一种 使得工厂函数 Itcast 函数, 与 构造函数 init 函数共享一个原型对象 核心方法 toArray isArrayLike map each eq first last pushStack end 2) DOM 操作模块 parseHTML appendTo, append prependTo, prepend insertAfter, after insertBefore, before parent next, nextAll prev, prevAll siblings 3) 事件操作模块 on, off 快捷方法( click, mouseover, ... ) 4) 样式操作模块 css addClass, removeClass, hasClass toggleClass 5) 属性操作 attr, prop html, text, val 6) 插件机制 插件就是用来给 jq 对象或构造函数提供新的实例方法或静态方法的 库 Itcast.fn.extend Itcast.extend 2&gt; node 的基本概念 1) node 平台是将 js 脱离浏览器, 允许它在其他环节中原型 2) CommondJS 规范 3) node 的安装( nodejs.org )与包的安装 包是库, js 的库 如何安装: npm install -g 包名 npm install 包名 npm uninstall 包名 另外: 在国内可以使用 淘宝提供的 NPM 镜像 模块与组件的概念( 了解 ) 模块就是按照一定的逻辑组合到一起的代码( 抽象的, 模糊的, 范化的概念 ) 组件是一个独立的具有单独逻辑的功能模块. 但是反过来, 组件又是模块. 反馈 问题1: text, html, val 方法 jq 方法的具体含义 $( ... ).text( &apos;...&apos; ); // 给每一个 DOM 元素, 提供一个子节点( 文本节点 ), 相当于 innerText 属性 $( ... ).html( &apos;...&apos; ); // 给每一个 DOM 元素, 提供一个子节点( 元素或文本等 ), 相当于 innerHTML 属性 $( ... ).val( &apos;...&apos; ); // 给每一个 DOM 元素, 设置其 value, 就是 value 属性. // text // 给每一个 DOM 元素 设置 innerText 属性 ... this.each( function () { this.innerText = value; }); // html // 给每一个 DOM 元素 设置 innerHTML 属性 ... this.each( function () { this.innerHTML = value; }); // val // 给每一个 DOM 元素 设置 value 属性 ... this.each( function () { this.value = value; }); 问题2: 统计图 借助于 echarts 来实现该功能 $( &apos;div&apos; ).charts( options ) // echarts echarts.init( dom ).setOption( options ); // 让 jq 提供 一个 charts 方法, 就是在调用 该方法 的时候 为每一个 dom 元素 提供一个图表 jQuery.fn.charts = function ( options ) { this.each(function () { echarts.init(this).setOption( options ); }); } gulp 的使用 淘宝的 NPM 镜像: –registry=https://registry.npm.taobao.org -&gt; 为什么学习 gulp 1) 为了处理代码( 合并, 压缩 ) 2) 了解构建工具的使用方式( 前端工具都是使用 node 平台 ) 3) 了解一下 node 代码的编写 -&gt; 安装 1) 全局安装 gulp 打开命令行, 键入命令 npm install -g gulp 2) 本地安装 建一个文件夹( 工作目录 ) 进入该目录, 键入命令 npm install gulp --save 3) 使用 gulp 基本步骤 -&gt; 在 工作目录下创建一个文件 gulpfile.js -&gt; 使用 js 编码文件, 创建 task 任务 4) 执行 gulp 定义的任务 在 工作目录下执行命令: gulp 任务名 gulp 的哲学就是拿来主义 要执行什么事情就拿已经做好的工具即可 所以要合并文件就只需要找到可以合并文件的 gulp 包即可 如何去找: http://npmjs.org/plugins 所有的 node 工具包 http://gulpjs.com/plugins 只含有 gulp 的工具包 dependencies 依赖. 描述的含义是该项目中需要使用的包 devDependencies 开发依赖. 项目在开发阶段需要使用的包. 问题 -&gt; 包: 就是 js 库. 回顾 js 中使用库的方式 &lt;script src=&quot;????&quot;&gt;&lt;/script&gt; 路径( url )可以使用 相对路径, 或 直接使用网络上的路径( CDN ) 如果相对路径写错了, 就无法使用这个库. 一般将 库 写在项目所在的目录下( scripts 这样类似的文件夹中 ) 也就是说, 每一个项目都会有一个该目录, 存储该项目需要使用的 js 文件 这就是 局部路径下的 js 文件( 局部文件中的 库 ) node 平台: npm 局部安装: 就是在本地文件夹中会创建一个 node_modules 这样类似的文件夹 并在网络上下载 需要 的 js 库( 不单是一个 js 文件, 是一个 node 项目, 称为 包 ) 放到该文件夹中. 我们在写 node 代码的时候, node 平台会自动的在 node_modules 文件夹中去查找对象的 数据. var gulp = require( &apos;gulp&apos; ) -&gt; 安装 1&gt; 全局安装( 好比是在安装运行时的核心文件, 就是在安装这个命令 ) npm install -g gulp 2&gt; 本地( 局部 )安装( 相当于是在装插件, 这里的插件是由 gulp 所使用的 ) npm install gulp 3&gt; 安装 插件, 安装需要具体实现功能的 代码 npm install gulp-concat gulp-uglify -&gt; 目录的规则 / 正斜线, 斜线; \\ 反斜线, 在不冲突的情况下简称为斜线 unix 操作系统, 其中用于描述路径的 就是 斜线 / / 称为根目录 linux 操作系统( 可以认为: 免费的 unix ) / 根目录 苹果操作系统( MacOS 是 Unix 的衍生版本 ) / 根目录 DOS 一开始就是别人模拟 unix 写的一个系统 采用了新的标注方式, 分了盘符( C:\\, D:\\ 等 ) 采用反斜线来描述目录的路径( 在 win 中如果不冲突, 使用正斜线可以使用 ) 在目录规则中使用 . 表示当前目录, 使用 .. 表示父级目录 因此在描述本地资源的时候可以看到 &lt;script src=&quot;./123.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;123.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../src/123.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/src/123.js&quot;&gt;&lt;/script&gt; gulp 的补充 1&gt; 有时需要在加载文件的时候按照指定的顺序进行加载 就不能使用 gulp.src( &apos;./src/*&apos; ) 可以使用数组, 将文件的名字一一列出 即: gulp.src( [ &apos;Itcast.core.js&apos;, &apos;Itcast.dom.js&apos;, &apos;Itcast.event.js&apos;, &apos;Itcast.style.js&apos;, &apos;Itcast.attr.js&apos; ] ) 如此就可以按照数组的顺序来加载代码了 2&gt; 希望按照一定的顺序依次执行 gulp 中的 任务 需要配置任务依赖 例如: 有三个任务: task1, task2, task3 要求依次执行 task2, task1, task3 要求 先执行 task2, 在 task2 执行完以后再执行 task1, 在 task1 执行完以后再执行 task3 换句话说, 就是 最终要执行的是 task3, 但是在执行 task3 之前应该先执行 task1, 而在执行 task1 之前要先执行 task2. 注: gulp 具有下面的语法 gulp.task( &apos;命令名&apos;, [ &apos;task名字&apos;, &apos;task名字&apos;, ... ] , function () { }); 控制多个 task 的执行顺序. 3&gt; node 是异步的 与 js 中的 setTimeout 一样. 在 浏览器的 js 中有一个称为函数( 事件 )队列 node 是 &apos;单线程&apos; 的异步编程 4&gt; gulp 有一个默认的命令, 就是 default angularjs 三大流行框架: angular( * ) // angularjs, angular vue react 网站的发展流程与运行过程( *** ) 计算机的物理结构与拓扑结构( 逻辑结构 ) 计算机可能放在别的地方, 但是使用网络, 可以使得计算机放在别的地方与放在我们身边一样的使用 互联网: 就是将全世界的很多的局域网连接起来构成了互联网 网站模型 客户机, 服务器 -&gt; 早期的网站, 单纯的文字页面内容( 没有动画, 修饰等内容 ) -&gt; url 的基本格式 协议://主机地址(名):端口号/路径?参数 http:// 地址( ip ) :80 使用 &quot;协议://主机地址(名):端口号/&quot; 可以定位到 一台计算机的一个网站中. 就是一台计算机的一个文件夹中. 路径的含义就是在寻找 网站根目录中的 文件或文件夹( 一般 服务器都会配置默认文件 ) http://www.123.456.com/index.html http://www.123.456.com/ -&gt; http 服务器 npm install -g http-server -&gt; 静态网站 -&gt; 为什么需要动态网站 百度的搜索功能? 每一个人要搜索的东西可能不一样, 自然就表明生成的 html 就不一样? 静态网站能做么? 缺点: 前后台代码混编 artTemplate: datas = [ { name: , age:, gender: } ] &lt;table border=&quot;1&quot; width=&quot;400&quot;&gt; &lt;thead&gt; &lt;% for ( var k in datas[ 0 ] ) {%&gt; &lt;th&gt;&lt;%= k%&gt;&lt;/th&gt; &lt;% } %&gt; &lt;/thead&gt; ... ... &lt;/table&gt; 提出: webApi -&gt; 前端后端分离: webApi","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"502-其他","slug":"vue/502-其他","permalink":"http://yoursite.com/categories/vue/502-其他/"}],"tags":[]},{"title":"501-几种框架 的简单介绍","slug":"vue/501-框架描述/501-几种框架的简单描述","date":"2018-05-10T01:32:35.078Z","updated":"2018-05-10T01:38:42.175Z","comments":true,"path":"2018/05/10/vue/501-框架描述/501-几种框架的简单描述/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/501-框架描述/501-几种框架的简单描述/","excerpt":"","text":"angular 简介angular1 最初的agular版本,称为angularjs,专注于前端开发,在代码的书写方面有着严格的规定, 也就是条条框框较多,但是掌握的话,学起来相对简单,因为学会一个就能够掌握多个 在一些小型的项目中,angularjs过于臃肿,对于一些现有的开发,只是要使用angularjs的双向数据绑定 在完整的引入angularjs的情况下,就不太合适了,所以就有了angular2 angular2 引入了模块化开发思想的概念,与angularjs并没有多大的关联 vue 相比于angular而言,较为轻量,在代码的书写方面也并不是太严格 在新一代的版本vue2.0中,在大部分的内容上都和vue1中相似 react 现在的发展还不是太成熟 cordova phonegap 简单来说,就是使用js做手机移动端的开发 ionic 专注于移动端的开发","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"501-框架描述","slug":"vue/501-框架描述","permalink":"http://yoursite.com/categories/vue/501-框架描述/"}],"tags":[]},{"title":"301-补充","slug":"vue/301-补充/301-补充","date":"2018-05-10T01:32:35.074Z","updated":"2018-05-10T01:38:14.877Z","comments":true,"path":"2018/05/10/vue/301-补充/301-补充/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/301-补充/301-补充/","excerpt":"","text":"移动端项目的开始依赖包123456789101112131415161718191. babel-polyfill es6的补丁 npm install babel-polyfill --save-dev import &quot;babel-polyfil&quot; 需要在main文件的开头引入2. fastclick 解决移动端300ms的延迟 npm install fastclick --save import fastclick from &apos;fastclick&apos; fastclick.attach(document.body)3. jsonp 执行跨域数据请求的一个模块 npm install jsonp --save","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"301-补充","slug":"vue/301-补充","permalink":"http://yoursite.com/categories/vue/301-补充/"}],"tags":[]},{"title":"300-插件","slug":"vue/300-插件系统/300-插件系统","date":"2018-05-10T01:32:35.073Z","updated":"2018-05-10T01:38:04.515Z","comments":true,"path":"2018/05/10/vue/300-插件系统/300-插件系统/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/300-插件系统/300-插件系统/","excerpt":"","text":"vue可以使用的插件系统iscroll–&gt;better-scroll 实现页面滚动特效 项目实战-饿了吗 项目实战-炸鸡音乐 vue-lazyload 实现页面数据的懒加载效果","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"300-插件系统","slug":"vue/300-插件系统","permalink":"http://yoursite.com/categories/vue/300-插件系统/"}],"tags":[]},{"title":"20-总结","slug":"vue/502-其他/20-conclude","date":"2018-05-10T01:32:35.036Z","updated":"2018-05-10T01:37:52.862Z","comments":true,"path":"2018/05/10/vue/502-其他/20-conclude/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/502-其他/20-conclude/","excerpt":"","text":"第二十单元 知识点总结","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"502-其他","slug":"vue/502-其他","permalink":"http://yoursite.com/categories/vue/502-其他/"}],"tags":[]},{"title":"13-es6","slug":"vue/13-singlePage-es6/13-singleFile-es6","date":"2018-05-10T01:32:35.017Z","updated":"2018-05-10T01:36:35.819Z","comments":true,"path":"2018/05/10/vue/13-singlePage-es6/13-singleFile-es6/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/13-singlePage-es6/13-singleFile-es6/","excerpt":"","text":"第十三部分 ES6简单扩展和单文件组件 来自网络收集, 如有雷同,请见谅 es6简介 ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现 还记得数组的 forEach map filter every some方法吗? ECMAScript5 ES5 ECMAScript6 ES6 ES2015:是什么? ECMAScript6/简称ES6是JavaScript语言的下一代标准，已经在2015年6月正式发布 es6在之前版本的基础上增加了一些新的特性 ES6新特性 12345678910多样化的声明方式1. var2. let3. const4. function5. import6. classtemplate string, default, promise, extends...... 兼容性问题: ES6作为新一代标准，各大浏览器支持是需要一段时间的 查看各大浏览器对于ES6的支持情况 (http://kangax.github.io/compat-table/es6/) 即使不支持,我们也有解决的方案,之后会进行详细的讲解 提示学习资料: ES6 不理解的部分可以查看下附源码,也可查找上述链接文档 浏览器不支持es6,需要进行转化才能够正常执行 BabelBabel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); webpack配置 首先创建一个package.json文件 : npm init -y 1.安装webpack npm install webpack --save-dev 2.安装babel 实现 ES6 到 ES5 npm install --save-dev babel-core babel-preset-es2015 3.安装 babel-loader npm install --save-dev babel-loader 4.webpack.config.js完整配置 1234567891011121314var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &apos;./index.js&apos;, output: &#123; path: __dirname, filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [&#123; test: /\\.js$/, exclude: /node_modules/, loader: &apos;babel-loader&apos;, &#125;] &#125; 5.创建一个用于babel调用的文件，名为.babelrc { &quot;presets&quot;: [ &quot;es2015&quot; ] } 6.打开cmd,运行命令 webpack –watch 详细知识点(掌握es6的基本使用) ES6语法知识点太多,课堂上不可能全部详细讲解,有重点的进行学习: 1.let声明变量,const声明常量与var声明变量的区别 2.了解解构赋值,掌握其基本应用,最起码见到解构赋值的代码知道这段代码是做什么用的,不要一脸茫然 在这里不作重点考察 3.了解字符串新增的一些方法,重点掌握模板字符串 4.函数扩展,箭头函数使重点 5.ES6的模块化语法重点掌握,结合之前的commonjs和AMD规范进行学习 6.之后还有数组,数值,对象……作为简单了解,不作为考察的知识点 let ES6新增了let命令，用于声明变量，用let声明的变量，只在let命令所在的代码块内有效。 let其实是为JavaScript新增了块级作用域。在之前的js中没有块级作用域,只有函数能够产生作用域! const 常量：不变的量 什么是不变的量,与变(var/let)的区别 解构赋值 解构:分解、拆解,即分解其构成或者说是分解其组成 解构赋值：以分解/拆解的形式进行赋值 字符串扩展 在原先js的基础上增加了一些新的方法,扩展了一些新的功能 最好用的莫过于模板字符串,大大简化了我们的书写方式 函数扩展 module语法 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块通过export命令显式指定输出的代码，再通过import命令输入。 1一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 数组的扩展 数值的扩展 对象的扩展 Set and Map Promise raceur编译器Google公司的Traceur（http://github.com/google/traceur-compiler）编译器，可以将ES6代码编译为ES5代码。 使用方法：直接插入网页 首先，必须在网页头部加载Traceur库文件 12345678&lt;script src = &quot;http://google.github.io/traceur-compiler/bin/traceur.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://google.github.io/traceur-compiler/src/bootstrap.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script&gt; traceur.options.experimental = true;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; //ES6代码&lt;/script&gt; type属性的值是module，这是Traceur用来辨识ES6代码的标识，编译器会自动将所有标记了type=module的代码编译为ES5代码，然后交给浏览器执行 单文件组件 在讲解单文件组件之前,我们先分析一下之前所学的组件 存在的问题123456在之前的vue.js章节中，我们都是用传统模式引用vue.js以及其他的js文件的，这在开发时会产生一些问题。首先，这限定了我们的开发模式是基于页面的，而不是基于组件的，组件的所有代码都直接写在页面中，这对于一些复杂的页面来说，不是好事情，代码的可读性会较差，也不便于管理。其次，定义在HTML页面中的组件，无法被其他页面重用，我们只能通过复制粘贴的方式将组件代码拷贝到其他页面。 在这里暴露出了一系列的问题 全局定义(Global definitions) 强制要求每个 component 中的命名不得重复 字符串模板(String templates) 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 \\ 不支持CSS(No CSS support) 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏 没有构建步骤(No build step) 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel 为了解决这一问题,提出了单文件组件的概念 单文件组件 单文件组件:就是将我们的组件部分单独抽取到一个.vue文件 通过单文件组件的方式,可以完美的解决上述问题 123456789使用我们的单文件组件,需要配合构建工具使用,使用构建工具,构建我们的项目模板 项目模板的配置在后面一章节会详细介绍,在这里先做一个简单的了解 课程允许的情况下,可以教学生配置自己的项目模板(安装包,配置config文件......) 讲师上课前可以先配置好项目模板,分发给每个学生直接使用,让学生体验一个使用模块分离思想进行项目开发的好处项目模板可以单独构建(较为复杂),也可以使用官方提供的已经构建好的模板,进行快速配置 简单的单文件组件示例 复杂页面的组件化开发 模块分离的思想 将一个个单独的功能模块抽取成一个个单文件组件进行使用 在较大项目中降低文件结构的复杂度 便于页面内容的修改,也就是更新迭代,在修改文件内容的时候直接查找对应的单文件组件,变得更方便 最重要的一点,对于一些多次使用的组件,我们可以单独将其抽取,使用的时候直接调用,实现组件的复用 在这一部分做一个简单的演示 在主页面,将整体的功能结构划分成头部—-主体—-底部三部分,每一部分提取成一个组件,具体实现如下 完整功能的实现,完善App.vue和main.js","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"13-singlePage-es6","slug":"vue/13-singlePage-es6","permalink":"http://yoursite.com/categories/vue/13-singlePage-es6/"}],"tags":[]},{"title":"12-webpack","slug":"vue/12-webpack/12-webpack","date":"2018-05-10T01:32:35.014Z","updated":"2018-05-10T01:36:09.564Z","comments":true,"path":"2018/05/10/vue/12-webpack/12-webpack/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/12-webpack/12-webpack/","excerpt":"","text":"第十二部分 webpack 来自网络收集, 如有雷同,请见谅 Webpack 简介 Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 模块化 介绍前端模块系统的演进历史，以及 Webpack 出现的背景及其特点。 详细信息可以参考下文 模块系统现状伴随着移动互联的大潮，当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用 HTML5、 CSS3、 ES6 等更新的技术来开发丰富的功能，网页已经不仅仅是完成浏览的基本需求，并且webapp通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码，这给前端开发的流程和资源组织带来了巨大的挑战。 前端开发和其他开发工作的主要区别，首先是前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 模块系统的演进模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统。 &lt;script&gt;标签1234&lt;script src=\"module1.js\"&gt;&lt;/script&gt;&lt;script src=\"module2.js\"&gt;&lt;/script&gt;&lt;script src=\"libraryA.js\"&gt;&lt;/script&gt;&lt;script src=\"module3.js\"&gt;&lt;/script&gt; 这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如 YUI 库。 这种原始的加载方式暴露了一些显而易见的弊端： 全局作用域下容易造成变量冲突 文件只能按照 &lt;script&gt; 的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 CommonJS 规范CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。 这个项目最开始是由 Mozilla 的工程师 Kevin Dangoor 在2009年1月创建的，当时的名字是 ServerJS。 我在这里描述的并不是一个技术问题，而是一件重大的事情，让大家走到一起来做决定，迈出第一步，来建立一个更大更酷的东西。 —— Kevin Dangoor’s What Server Side JavaScript needs 2009年8月，这个项目改名为 CommonJS，以显示其 API 的更广泛实用性。CommonJS 是一套规范，它的创建和核准是开放的。这个规范已经有很多版本和具体实现。CommonJS 并不是属于 ECMAScript TC39 小组的工作，但 TC39 中的一些成员参与 CommonJS 的制定。2013年5月，Node.js 的包管理器 NPM 的作者 Isaac Z. Schlueter 说 CommonJS 已经过时，Node.js 的内核开发者已经废弃了该规范。 CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。 一个直观的例子： 1234// moduleA.jsmodule.exports = function( value )&#123; return value * 2;&#125; 123// moduleB.jsvar multiplyBy2 = require('./moduleA');var result = multiplyBy2(4); CommonJS 是同步加载模块，但其实也有浏览器端的实现，其原理是现将所有模块都定义好并通过 id 索引，这样就可以方便的在浏览器环境中解析了，可以参考 require1k 和 tiny-browser-require 的源码来理解其解析（resolve）的过程。 更多关于 CommonJS 规范的内容请查看 http://wiki.commonjs.org/wiki/CommonJS。 AMD 规范AMD（异步模块定义）是为浏览器环境设计的，因为 CommonJS 模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件。 AMD 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。 模块通过 define 函数定义在闭包中，格式如下： 1define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]。 1define(function(require, exports, module) &#123;&#125;） factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 一些用例： 定义一个名为 myModule 的模块，它依赖 jQuery 模块： 123456define('myModule', ['jquery'], function($) &#123; // $ 是 jquery 模块的输出 $('body').text('hello world');&#125;);// 使用require(['myModule'], function(myModule) &#123;&#125;); 注意：在 webpack 中，模块名只有局部作用域，在 Require.js 中模块名是全局作用域，可以在全局引用。 定义一个没有 id 值的匿名模块，通常作为应用的启动函数： 123define(['jquery'], function($) &#123; $('body').text('hello world');&#125;); 依赖多个模块的定义： 1234define(['jquery', './math.js'], function($, math) &#123; // $ 和 math 一次传入 factory $('body').text('hello world');&#125;); 模块输出： 123456789define(['jquery'], function($) &#123; var HelloWorldize = function(selector)&#123; $(selector).text('hello world'); &#125;; // HelloWorldize 是该模块输出的对外接口 return HelloWorldize;&#125;); 在模块定义内部引用依赖： 1234define(function(require) &#123; var $ = require('jquery'); $('body').text('hello world');&#125;); commonjs和AMD的整体分析1.服务器端node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。 假定有一个数学模块math.js，就可以像下面这样加载。123//然后，就可以调用模块提供的方法：var math = require(&apos;math&apos;);math.add(2,3); // 5 2.服务器端模块系统适用于浏览器端吗?有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？ 12var math = require(&apos;math&apos;); math.add(2, 3); 12345第二行math.add(2, 3)，在第一行require(&apos;math&apos;)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于&quot;假死&quot;状态。因此，浏览器端的模块，不能采用&quot;同步加载&quot;（synchronous），只能采用&quot;异步加载&quot;（asynchronous）。这就是AMD规范诞生的背景。 3.浏览器端的模块加载系统 AMD AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：1 require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：123 require([&apos;math&apos;], function (math) &#123; math.add(2, 3); &#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境 目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js 什么是 WebpackWebpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 为什么重复造轮子市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面 Web 应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。 这些已有的模块化工具并不能很好的完成如下的目标： 将依赖树拆分成按需加载的块 初始化加载的耗时尽量少 各种静态资源都可以视作模块 将第三方库整合成模块的能力 可以自定义打包逻辑的能力 适合大项目，无论是单页还是多页的 Web 应用 Webpack 的特点Webpack 和其他模块化工具有什么区别呢？ 代码拆分Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 LoaderWebpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(&quot;./templates/&quot; + name + &quot;.jade&quot;)。 插件系统Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 webpack基本使用(重点)安装 创建项目根目录 初始化 npm init 或 npm init -y 全局安装 npm install webpack -g 局部安装,在项目目录下安装 npm install webpack –save-dev –save: 将安装的包的信息保存在package中–dev:开发版本,只是项目构建的时候使用,项目构建完成后并不依赖的文件 如果使用web开发工具,单独安装 npm install webpack-dev-server –save-dev 基本使用 首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js： 123456789&lt;!-- index.html --&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建entry.js 12// entry.js : 在页面中打印出一句话document.write(&apos;It works.&apos;) 然后编译 entry.js并打包到 bundle.js文件中 12// 使用npm命令 webpack entry.js bundle.js 使用模块1.创建模块module.js,在内部导出内容 1module.exports = 'It works from module.js' 2.在entry.js中使用自定义的模块 123//entry.jsdocument.write('It works.')document.write(require('./module.js')) // 添加模块 加载css模块1.安装css-loader 1npm install css-loader style-loader --save-dev 2.创建css文件 12//style.cssbody &#123; background: yellow; &#125; 3.修改 entry.js： 123require(&quot;!style-loader!css-loader!./style.css&quot;) // 载入 style.cssdocument.write(&apos;It works.&apos;)document.write(require(&apos;./module.js&apos;)) 补充 12345678如果每次 require CSS 文件的时候都要写 loader 前缀，是一件很繁琐的事情。我们可以根据模块类型（扩展名）来自动绑定需要的 loader。将 entry.js 中的 require(&quot;!style!css!./style.css&quot;) 修改为 require(&quot;./style.css&quot;) ，然后执行：$ webpack entry.js bundle.js --module-bind &apos;css=style-loader!css-loader&apos;### 有些环境下可能需要使用双引号$ webpack entry.js bundle.js --module-bind &quot;css=style-loader!css-loader&quot; 创建配置文件webpack.config.js1.创建文件 123456789101112131415var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &apos;./entry.js&apos;, output: &#123; path: __dirname, filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ //同时简化 entry.js 中的 style.css 加载方式：require(&apos;./style.css&apos;) &#123;test: /\\.css$/, loader: &apos;style-loader!css-loader&apos;&#125; ] &#125;&#125; 2.修改 entry.js 中的 style.css 加载方式：require(‘./style.css’) 3.运行webpack 在命令行页面直接输入webpack 插件使用1.插件安装 1234//添加注释的插件npm install --save-devbannerplugin---- 这个插件已经换成了一个内置的插件,不再需要独立安装了 2.配置文件的书写 12345678910111213141516171819202122var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &apos;./entry.js&apos;, output: &#123; path: __dirname, filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ //同时简化 entry.js 中的 style.css 加载方式：require(&apos;./style.css&apos;) &#123; test: /\\.css$/, loader: &apos;style-loader!css-loader&apos; &#125; ], plugins: [ //添加注释的插件 new webpack.BannerPlugin(&apos;This file is created by zhaoda&apos;) ] &#125;&#125; 3.运行webpack 12// 可以在bundle.js的头部看到注释信息/*! This file is created by zhaoda */ 开发环境1234567webpack --progress : 显示编译的进度--colors ： 带颜色显示，美化输出--watch ： 开启监视器，不用每次变化后都手动编译 webpack-dev-server 开启服务,以监听模式自动运行 1.安装包 1npm install webpack-dev-server -g --save-dev 2.启动服务 实时监控页面并自动刷新 1webpack-dev-server --progress --colors 自动编译1.安装插件 1npm install --save-dev html-webpack-plugin 2.在配置文件中导入包 1var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) 3.在配置文件中使用插件 12345678910plugins: [ //添加注释的插件 new webpack.BannerPlugin(&apos;This file is created by zhaoda&apos;), //自动编译 new htmlWebpackPlugin(&#123; title: &quot;index&quot;, filename: &apos;index.html&apos;, //在内存中生成的网页的名称 template: &apos;./index.html&apos; //生成网页名称的依据 &#125;) ] 4.运行项目 1webpack-dev-server 设置快速启动 在package.json文件中完成配置 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --open&quot;&#125; 补充的知识点-作为参考的内容(了解)npm使用补充(了解) 在接下来的课程中涉及到npm的相关知识,在这里给大家作一个简单的补充 这一部分知识点在渗透到项目的构建过程 title: npm命令 淘宝镜像:$ npm install -g cnpm –registry=https://registry.npm.taobao.orgnpm config set registry=https://registry.npm.taobao.org(修改npm配置换源) nrm安装: nrm ls nrm test 升级npm1npm install npm -g 安装包12npm install package_namenpm install package_name -g ---全局安装 卸载包1npm uninstall package -g 查看安装的全局模块1npm ls -g 初始化 package.json 文件1npm init 安装指定包到当前项目12345npm install angular --save 添加--save,可以在package.json的dependencies中添加依赖项--save-dev: 添加开发依赖,开发过程中使用的依赖,项目上线时可以不使用 卸载当前项目中的指定包123npm remove --save angularnpm uninstall --save angular 根据 package.json 文件中的依赖项安装所有包1npm install 安全全局命令行工具1npm install --global http-server 卸载全局命令行工具1npm uninstall --global http-server 前言 介绍前端模块系统的演进历史，以及 Webpack 出现的背景及其特点。 模块系统(暂时是了解,以后是重点)现状伴随着移动互联的大潮，当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用 HTML5、 CSS3、 ES6 等更新的技术来开发丰富的功能，网页已经不仅仅是完成浏览的基本需求，并且webapp通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码，这给前端开发的流程和资源组织带来了巨大的挑战。 前端开发和其他开发工作的主要区别，首先是前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 模块系统的演进模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统。 &lt;script&gt;标签1234&lt;script src=\"module1.js\"&gt;&lt;/script&gt;&lt;script src=\"module2.js\"&gt;&lt;/script&gt;&lt;script src=\"libraryA.js\"&gt;&lt;/script&gt;&lt;script src=\"module3.js\"&gt;&lt;/script&gt; 这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如 YUI 库。 这种原始的加载方式暴露了一些显而易见的弊端： 全局作用域下容易造成变量冲突 文件只能按照 &lt;script&gt; 的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 CommonJS服务器端的 Node.js 遵循 CommonJS规范，该规范的核心思想是允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。 1234require(\"module\");require(\"../file.js\");exports.doStuff = function() &#123;&#125;;module.exports = someValue; 优点： 服务器端模块便于重用 NPM 中已经有将近20万个可以使用模块包 简单并容易使用 缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 实现： 服务器端的 Node.js Browserify，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大 modules-webmake，类似Browserify，还不如 Browserify 灵活 wreq，Browserify 的前身 AMDAsynchronous Module Definition 规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。 1234define(\"module\", [\"dep1\", \"dep2\"], function(d1, d2) &#123; return someExportedValue;&#125;);require([\"module\", \"../file\"], function(module, file) &#123; /* ... */ &#125;); 优点： 适合在浏览器环境中异步加载模块 可以并行加载多个模块 缺点： 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅 不符合通用的模块化思维方式，是一种妥协的实现 实现： RequireJS curl CMDCommon Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。 123456define(function(require, exports, module) &#123; var $ = require('jquery'); var Spinning = require('./spinning'); exports.doSomething = ... module.exports = ...&#125;) 优点： 依赖就近，延迟执行 可以很容易在 Node.js 中运行 缺点： 依赖 SPM 打包，模块的加载逻辑偏重 实现： Sea.js coolie UMDUniversal Module Definition 规范类似于兼容 CommonJS 和 AMD 的语法糖，是模块定义的跨平台解决方案。 ES6 模块ECMAScript6 标准增加了 JavaScript 语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 123import \"jquery\";export function doStuff() &#123;&#125;module \"localModule\" &#123;&#125; 优点： 容易进行静态分析 面向未来的 ECMAScript 标准 缺点： 原生浏览器端还没有实现该标准 全新的命令字，新版的 Node.js才支持 实现： Babel 期望的模块系统可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。 前端模块加载前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。 模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。 分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。 要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程。 所有资源都是模块在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。 如果他们都可以视作模块，并且都可以通过require的方式来加载，将带来优雅的开发体验，比如： 1234require(\"./style.css\");require(\"./style.less\");require(\"./template.jade\");require(\"./image.png\"); 那么如何做到让 require 能加载各种资源呢？ 静态分析在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如一个用 LESS 写的样式模块，可以先用 LESS 加载器将它转成一个CSS 模块，在通过 CSS 模块把他插入到页面的 &lt;style&gt; 标签中执行。Webpack 就是在这样的需求中应运而生。 同时，为了能利用已经存在的各种框架、库和已经写好的文件，我们还需要一个模块加载的兼容策略，来避免重写所有的模块。 那么接下来，让我们开始 Webpack 的神奇之旅吧。 重复的轮子什么是 WebpackWebpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 为什么重复造轮子市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面 Web 应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。 这些已有的模块化工具并不能很好的完成如下的目标： 将依赖树拆分成按需加载的块 初始化加载的耗时尽量少 各种静态资源都可以视作模块 将第三方库整合成模块的能力 可以自定义打包逻辑的能力 适合大项目，无论是单页还是多页的 Web 应用 Webpack 的特点Webpack 和其他模块化工具有什么区别呢？ 代码拆分Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 LoaderWebpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(&quot;./templates/&quot; + name + &quot;.jade&quot;)。 插件系统Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 准备开始(重点)安装首先要安装 Node.js， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。 用 npm 安装 Webpack： 1$ npm install webpack -g 此时 Webpack 已经安装到了全局环境下，可以通过命令行 webpack -h 试试。 通常我们会将 Webpack 安装到项目的依赖中，这样就可以使用项目本地版本的 Webpack。 1234#### 进入项目目录#### 确定已经有 package.json，没有就通过 npm init 创建#### 安装 webpack 依赖$ npm install webpack --save-dev Webpack 目前有两个主版本，一个是在 master 主干的稳定版，一个是在 webpack-2 分支的测试版，测试版拥有一些实验性功能并且和稳定版不兼容，在正式项目中应该使用稳定版。 123456##### 查看 webpack 版本信息$ npm info webpack##### 安装指定版本的 webpack$ npm install webpack@1.12.x --save-dev 如果需要使用 Webpack 开发工具，要单独安装： 1$ npm install webpack-dev-server --save-dev 使用首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js： 123456789&lt;!-- index.html --&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12// entry.jsdocument.write('It works.') 然后编译 entry.js 并打包到 bundle.js： 1$ webpack entry.js bundle.js 打包过程会显示日志： 123456Hash: e964f90ec65eb2c29bb9Version: webpack 1.12.2Time: 54ms Asset Size Chunks Chunk Namesbundle.js 1.42 kB 0 [emitted] main [0] ./entry.js 27 bytes &#123;0&#125; [built] 用浏览器打开 index.html 将会看到 It works. 。 接下来添加一个模块 module.js 并修改入口 entry.js： 12// module.jsmodule.exports = 'It works from module.js.' 123// entry.jsdocument.write('It works.')document.write(require('./module.js')) // 添加模块 重新打包 webpack entry.js bundle.js 后刷新页面看到变化 It works.It works from module.js. 1234567Hash: 279c7601d5d08396e751Version: webpack 1.12.2Time: 63ms Asset Size Chunks Chunk Namesbundle.js 1.57 kB 0 [emitted] main [0] ./entry.js 66 bytes &#123;0&#125; [built] [1] ./module.js 43 bytes &#123;0&#125; [built] Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js 。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。 LoaderWebpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。 先来看看 loader 有哪些特性？ Loader 可以通过管道方式链式调用，每个 loader 可以把资源转换成任意格式并传递给下一个 loader ，但是最后一个 loader 必须返回 JavaScript。 Loader 可以同步或异步执行。 Loader 运行在 node.js 环境中，所以可以做任何可能的事情。 Loader 可以接受参数，以此来传递配置项给 loader。 Loader 可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。 Loader 可以通过 npm 发布和安装。 除了通过 package.json 的 main 指定，通常的模块也可以导出一个 loader 来使用。 Loader 可以访问配置。 插件可以让 loader 拥有更多特性。 Loader 可以分发出附加的任意文件。 Loader 本身也是运行在 node.js 环境中的 JavaScript 模块，它通常会返回一个函数。大多数情况下，我们通过 npm 来管理 loader，但是你也可以在项目中自己写 loader 模块。 按照惯例，而非必须，loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。 在引用 loader 的时候可以使用全名 json-loader，或者使用短名 json。这个命名规则和搜索优先级顺序在 webpack 的 resolveLoader.moduleTemplates api 中定义。 1Default: [&quot;*-webpack-loader&quot;, &quot;*-web-loader&quot;, &quot;*-loader&quot;, &quot;*&quot;] Loader 可以在 require() 引用模块的时候添加，也可以在 webpack 全局配置中进行绑定，还可以通过命令行的方式使用。 接上一节的例子，我们要在页面中引入一个 CSS 文件 style.css，首页将 style.css 也看成是一个模块，然后用 css-loader 来读取它，再用 style-loader 把它插入到页面中。 12/* style.css */body &#123; background: yellow; &#125; 修改 entry.js： 123require(\"!style-loader!css-loader!./style.css\") // 载入 style.cssdocument.write('It works.')document.write(require('./module.js')) 安装 loader： 1npm install css-loader style-loader 重新编译打包，刷新页面，就可以看到黄色的页面背景了。 如果每次 require CSS 文件的时候都要写 loader 前缀，是一件很繁琐的事情。我们可以根据模块类型（扩展名）来自动绑定需要的 loader。 将 entry.js 中的 require(&quot;!style!css!./style.css&quot;) 修改为 require(&quot;./style.css&quot;) ，然后执行： 1234$ webpack entry.js bundle.js --module-bind 'css=style-loader!css-loader'#### 有些环境下可能需要使用双引号$ webpack entry.js bundle.js --module-bind \"css=style-loader!css-loader\" 显然，这两种使用 loader 的方式，效果是一样的。 配置文件Webpack 在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的 webpack.config.js 文件，这个文件是一个 node.js 模块，返回一个 json 格式的配置信息对象，或者通过 --config 选项来指定配置文件。 继续我们的案例，在根目录创建 package.json 来添加 webpack 需要的依赖： 12345678910111213141516171819&#123; \"name\": \"webpack-example\", \"version\": \"1.0.0\", \"description\": \"A simple webpack example.\", \"main\": \"bundle.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"webpack\" ], \"author\": \"zhaoda\", \"license\": \"MIT\", \"devDependencies\": &#123; \"css-loader\": \"^0.21.0\", \"style-loader\": \"^0.13.0\", \"webpack\": \"^1.12.2\" &#125;&#125; 123#### 如果没有写入权限，请尝试如下代码更改权限chflags -R nouchg .sudo chmod 775 package.json 别忘了运行 npm install。 然后创建一个配置文件 webpack.config.js： 1234567891011121314var webpack = require('webpack')module.exports = &#123; entry: './entry.js', output: &#123; path: __dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;&#125; 同时简化 entry.js 中的 style.css 加载方式： 1require('./style.css') 最后运行 webpack，可以看到 webpack 通过配置文件执行的结果和上一章节通过命令行 webpack entry.js bundle.js --module-bind &#39;css=style-loader!css-loader&#39; 执行的结果是一样的。 插件插件可以完成更多 loader 不能完成的功能。 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。 Webpack 本身内置了一些常用的插件，还可以通过 npm 安装第三方插件。 接下来，我们利用一个最简单的 BannerPlugin 内置插件来实践插件的配置和运行，这个插件的作用是给输出的文件头部添加注释信息。 修改 webpack.config.js，添加 plugins： 1234567891011121314151617var webpack = require('webpack')module.exports = &#123; entry: './entry.js', output: &#123; path: __dirname, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: 'style-loader!css-loader'&#125; ] &#125;, plugins: [ new webpack.BannerPlugin('This file is created by zhaoda') ]&#125; 然后运行 webpack，打开 bundle.js，可以看到文件头部出现了我们指定的注释信息： 12345/*! This file is created by zhaoda *//******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;// 后面代码省略 开发环境当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色。 1$ webpack --progress --colors 如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的。 1$ webpack --progress --colors --watch 当然，使用 webpack-dev-server 开发服务是一个更好的选择。它将在 localhost:8080 启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack，在浏览器打开 http://localhost:8080/ 或 http://localhost:8080/webpack-dev-server/ 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面。 12345#### 安装$ npm install webpack-dev-server -g#### 运行$ webpack-dev-server --progress --colors 故障处理Webpack 的配置比较复杂，很容出现错误，下面是一些通常的故障处理手段。 一般情况下，webpack 如果出问题，会打印一些简单的错误信息，比如模块没有找到。我们还可以通过参数 --display-error-details 来打印错误详情。 12345678910111213141516171819202122232425262728$ webpack --display-error-detailsHash: a40fbc6d852c51fceadbVersion: webpack 1.12.2Time: 586ms Asset Size Chunks Chunk Namesbundle.js 12.1 kB 0 [emitted] main [0] ./entry.js 153 bytes &#123;0&#125; [built] [1 error] [5] ./module.js 43 bytes &#123;0&#125; [built] + 4 hidden modulesERROR in ./entry.jsModule not found: Error: Cannot resolve 'file' or 'directory' ./badpathmodule in /Users/zhaoda/data/projects/webpack-handbook/examplesresolve file /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js doesn't exist /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json doesn't existresolve directory /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist (directory default file) /Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule/package.json doesn't exist (directory description file)[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json] @ ./entry.js 3:0-26 Webpack 的配置提供了 resolve 和 resolveLoader 参数来设置模块解析的处理细节，resolve 用来配置应用层的模块（要被打包的模块）解析，resolveLoader 用来配置 loader 模块的解析。 当引入通过 npm 安装的 node.js 模块时，可能出现找不到依赖的错误。Node.js 模块的依赖解析算法很简单，是通过查看模块的每一层父目录中的 node_modules 文件夹来查询依赖的。当出现 Node.js 模块依赖查找失败的时候，可以尝试设置 resolve.fallback 和 resolveLoader.fallback 来解决问题。 1234module.exports = &#123; resolve: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;, resolveLoader: &#123; fallback: path.join(__dirname, \"node_modules\") &#125;&#125;; Webpack 中涉及路径配置最好使用绝对路径，建议通过 path.resolve(__dirname, &quot;app/folder&quot;) 或 path.join(__dirname, &quot;app&quot;, &quot;folder&quot;) 的方式来配置，以兼容 Windows 环境。 参考链接模块规范 CommonJS 规范 Asynchronous Module Definition Common Module Definition CMD 模块定义规范 Universal Module Definition ECMAScript 6 Module 什么是 AMD、 CommonJS、 UMD 关于 CommonJS AMD CMD UMD 为什么我推荐 requirejs 而不是 seajs AMD 和 CMD 的区别有哪些 前端模块化开发的价值 What Server Side JavaScript needs 模块系统 RequireJS curl Sea.js coolie Browserify modules-webmake wreq Webpack Webpack 官方文档 React Webpack cookbook 编译 Babel","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"12-webpack","slug":"vue/12-webpack","permalink":"http://yoursite.com/categories/vue/12-webpack/"}],"tags":[]},{"title":"11-vuex","slug":"vue/11-vuex/11-vuex","date":"2018-05-10T01:32:35.012Z","updated":"2018-05-10T01:35:27.358Z","comments":true,"path":"2018/05/10/vue/11-vuex/11-vuex/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/11-vuex/11-vuex/","excerpt":"","text":"第十一部分 Vuex参考链接 vuex概述背景 在Vue中，多组件的开发给我们带来了很多的方便，但同时当项目规模变大的时候，多个组件间的数据通信和状态管理就显得难以维护。会造成我们的整个项目维护起来非常的困难。能不能把各个组件的逻辑，数据源和方法整合到一个地方？ 而Vuex就此应运而生。 将状态管理单独拎出来，应用统一的方式进行处理，在后期维护的过程中数据的修改和维护就变得简单而清晰了 概述 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 什么情况下我应该使用 Vuex？ 虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。 如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。 vuex的安装基本使用不同的使用方式: 1.直接引入本地下载vuex.js文件 123//快捷下载的方式--------------npm install vuex --save-dev&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt; 2.cdn加速 1https://unpkg.com/vuex 模块化使用 在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex： 12345678910//commonjs规范var Vue = require(&apos;vue&apos;)var Vuex = require(&apos;vuex&apos;)//es6的使用方式import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex) promise vue的实现依赖于 promise , 如果浏览器不支持promise, 可以使用 polyfill 来解决这个问题 polyfill Polyfill你可以理解为“腻子”，就是装修的时候，可以把缺损的地方填充抹平。 举个例子，html5的storage(session,local), 不同浏览器，不同版本，有些支持，有些不支持。 我们又想使用这个特性，怎么办？ 有些人就写对应的Polyfill（Polyfill有很多），帮你把这些差异化抹平，不支持的变得支持了（简单来讲，写些代码判断当前浏览器有没有这个功能，没有的话，就写一些支持的补丁代码）。 你只需要把需要的Polyfill引入到你的程序里，就可以了。 网上有很多polyfill的相关内容 直接引入就可以了 当浏览器不支持promise的时候,我们可以引入polyfill来解决这个问题 使用es6-promise就可以以解决这个问题 你可以通过 CDN 将其引入： &lt;script src=&quot;https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js&quot;&gt;&lt;/script&gt;然后 window.Promise 会自动可用。 如果你喜欢使用诸如 npm 或 Yarn 等包管理器，可以按照下列方式执行安装： npm install es6-promise --save # npm yarn add es6-promise # Yarn 或者更进一步，将下列代码添加到你使用 Vuex 之前的一个地方： import &#39;es6-promise/auto&#39; vuex的基本使用 每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着你的应用中大部分的状态(state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的(数据的双向绑定)。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 state — 单一状态树 可以简单的理解成数据模型这个数据模型在整个应用中是唯一的 它是用一个对象包含了应用的所有的状态 (数据),至此,作为唯一数据源儿存在 每一个应用将仅仅包含一个vuex.store的实例, mutations — 状态更改 通俗来说,也就是进行数据的修改 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于methods和事件 使用vuex进行数据的操作一个简单的例子在vue组件中获取vuex的状态,每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/vue.resource/1.2.1/vue-resource.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vuex&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; const store = new Vuex.Store(&#123; //状态----数据模型 state: &#123; count: 0 &#125;, //改变----数据操作----箭头函数 mutations: &#123; //increment: state =&gt; state.count++, increment: function(state) &#123; state.count++ &#125;, //decrement: state =&gt; state.count-- decrement: function(state) &#123; state.count-- &#125; &#125; &#125;) const app = new Vue(&#123; el: &apos;#app&apos;, computed: &#123; //在vue中获取vuex的状态----状态存储是响应式的(数据的双向绑定) //从store实例中读取数据最简单的方式就是在计算属性中获取某个值 count() &#123; return store.state.count &#125; &#125;, methods: &#123; increment() &#123; store.commit(&apos;increment&apos;) &#125;, decrement() &#123; store.commit(&apos;decrement&apos;) &#125; &#125; &#125;)&lt;/script&gt; mapState 当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/vue.resource/1.2.1/vue-resource.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vuex&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; const store = new Vuex.Store(&#123; //状态----数据模型 state: &#123; count: 0, test:100, &#125;, //改变----数据操作----箭头函数 mutations: &#123; //increment: state =&gt; state.count++, increment: function(state) &#123; state.count++ &#125;, //decrement: state =&gt; state.count-- decrement: function(state) &#123; state.count-- &#125; &#125; &#125;) const app = new Vue(&#123; el: &apos;#app&apos;, store, computed: Vuex.mapState(&#123; //当需要使用多个数据的的时候,使用计算属性就显得不方便,vuex提供了一种新的方式 //为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性 count:function() &#123; return store.state.count + store.state.test &#125; &#125;), methods: &#123; increment() &#123; store.commit(&apos;increment&apos;) &#125;, decrement() &#123; store.commit(&apos;decrement&apos;) &#125; &#125; &#125;)&lt;/script&gt; 组件间数据的共享 类比于之前所学的内容 数据传递的几种方式,在这里简单的回顾 123456781.父组件数据向子组件传递props2.子组件数据向父组件传递$on(v-on) $emit3.非父子组件数据传递$on $emit bus 使用vuex实现组件间数据的传递—-数据共享:(了解) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/vue.resource/1.2.1/vue-resource.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vuex&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;count&#125;&#125; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; &lt;template id=&quot;parent&quot;&gt; &lt;div&gt; &lt;button @click=&apos;parent&apos;&gt;在父组件内操作数据++&lt;/button&gt; &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;child&quot;&gt; &lt;div&gt; &lt;button @click=&apos;child&apos;&gt;在子组件内操作数据--&lt;/button&gt; &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var store = new Vuex.Store(&#123; //状态,共享数据模型 state: &#123; count: 0 &#125;, //变化 //改变----数据操作----箭头函数 mutations: &#123; //increment: state =&gt; state.count++, parent: function(state) &#123; state.count++ &#125;, //decrement: state =&gt; state.count-- child: function(state) &#123; state.count-- &#125; &#125; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, store: store, //我是父组件 computed: &#123; count: function() &#123; return store.state.count &#125; &#125;, components: &#123; &apos;parent&apos;: &#123; template: &quot;#parent&quot;, computed: &#123; count: function() &#123; return store.state.count &#125; &#125;, methods: &#123; parent() &#123; store.commit(&apos;parent&apos;) &#125; &#125;, //我是子组件 components: &#123; &apos;child&apos;: &#123; template: &quot;#child&quot;, computed: &#123; count: function() &#123; return store.state.count &#125; &#125;, methods: &#123; child() &#123; store.commit(&apos;child&apos;) &#125; &#125; &#125; &#125; &#125; &#125;, &#125;)&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"11-vuex","slug":"vue/11-vuex","permalink":"http://yoursite.com/categories/vue/11-vuex/"}],"tags":[]},{"title":"10-axios","slug":"vue/10-http/10-3-axios","date":"2018-05-10T01:32:35.011Z","updated":"2018-05-10T01:35:36.333Z","comments":true,"path":"2018/05/10/vue/10-http/10-3-axios/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/10-http/10-3-axios/","excerpt":"","text":"axiso(有待完善) 用于浏览器和node.js的基于Promise的HTTP客户端 axios(有待完善—-重点)axios具体用来做什么12345678910111213141516从浏览器中创建XMLHttpRequests支持在node.js中发送http请求支持Promise API----------------------截取请求和响应转换请求和响应数据----------------------取消请求自动转换JSON数据----------------------客户端支持防范XSRF 为什么要学习axios vue更新到2.0之后，作者就宣告不再对vue-resource更新，而是推荐的axios axiso的基本使用安装 使用npm安装并引入 1npm install axios 使用cdn 12&lt;script src=&apos;https://unpkg.com/axios/dist/axios.min.js&apos;&gt; &lt;/script&gt; axios的get请求1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;axios.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;sendGet()&quot;&gt;发送get请求&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, methods: &#123; sendGet: function() &#123; //这里的this指代的是 vm对象 var url = &quot;http://127.0.0.1/00-vue/select.php&quot;; axios.get(url).then(function(res) &#123; console.log(res.data) &#125;) &#125; &#125; &#125;)&lt;/script&gt; axios的post请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;axios.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--添加一条数据--&gt; &lt;button v-on:click=&apos;add()&apos;&gt;添加&lt;/button&gt;&lt;br /&gt; &lt;!--定义文本框--&gt; &lt;table class=&quot;text&quot;&gt; &lt;tr&gt; &lt;td&gt;name：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; v-model=&apos;name&apos; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;age：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; v-model=&apos;age&apos; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;sex：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; v-model=&apos;sex&apos; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;classroom：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; v-model=&apos;classroom&apos; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;条数&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;th&gt;sex&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;(data,index) in arr&quot;&gt; &lt;td&gt;第&#123;&#123;index+1&#125;&#125;条&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.sex&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;!--点击按钮的时候删除一条数据--&gt; &lt;button&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &quot;hello vue!&quot;, arr: [], //定义文本框绑定值 name: &quot;&quot;, age: &quot;&quot;, sex: &quot;&quot;, classroom: &quot;&quot; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, //创建生命周期钩子,初始化页面渲染 created: function() &#123; this.query() &#125;, methods: &#123; //将数据查询的操作封装成一个方法------&gt; 封装一个query方法 query() &#123; var url = &quot;http://127.0.0.1/00-vue/select.php&quot;; axios.get(url).then((res) =&gt; &#123; this.arr = res.data &#125;) &#125;, //添加一条动态的数据 add: function() &#123; //1. 定义的url路径,也就是请求的路径 var url = &quot;http://127.0.0.1/00-vue/add1.php&quot; //2. 发送的数据 var bodyData = `name=$&#123;this.name&#125;&amp;age=$&#123;this.age&#125;&amp;sex=$&#123;this.sex&#125;&amp;classroom=$&#123;this.classroom&#125;` //4. 使用vue-resource发送请求 axios.post(url, bodyData).then((res) =&gt; &#123; console.log(res.data) //重新查询 this.query() &#125;) &#125; &#125; &#125;)&lt;/script&gt; 使用post请求的注意事项 12345数据请求的参数有两个 参数1: 请求的路径 参数2: 发送的数据-------发送的数据需要拼接成查询字符串的形式才可以 jsonpaxiso本身不支持jsonp请求 vue提供的的有一个发送跨域请求的插件 vue-jsonp,需要配合项目模板使用, 先作为连接内容,—–后期进行讲解 基本使用1234567891011121314151617181. 安装vue的jsonp模块 npm install vue-jsonp --save2. 使用vue的jsonp模块 import VueJsonp from &apos;vue-jsonp&apos; Vue.use(VueJsonp)3. 发送jsonp请求 var url =&apos;http://api.douban.com/v2/movie/top250&apos; this.$jsonp(url) .then((res)=&gt;&#123; console.log(res.subjects) &#125;) 知识点补充jsonp模块详解,在学习完项目模板之后再做详细讲解 Vue-jsonp A tiny library for handling JSONP request. Usage.Static function:Vue.jsonp(url, dataObj, timeout) In Vue component:this.$jsonp(url, dataObj, timeout) Params. url: Target url for request. dataObj: Object contains datas for querying. timeout: Timeout for jsonp request. URL.1234'/url?&#123;callbackQuery&#125;=&#123;callbackName&#125;&amp;...'// Default:'/url?callback=jsonp_RANDOM_STRING&amp;...' Assign callback query name.12345this.$jsonp('/url', &#123; callbackQuery: 'cb' // Default: callback&#125;)// Then URL will be: '/url?cb=jsonp_aws84739ssu8e3' Assign callback function name.12345this.$jsonp('/url', &#123; callbackName: 'jsonpFunc'&#125;)// Then URL will be: '/url?callback=jsonpFunc' Example.123456789101112131415161718192021222324252627282930import Vue from 'vue'import VueJsonp from 'vue-jsonp'Vue.use(VueJsonp)// If you want to setup the global timeout, just:Vue.use(VueJsonp, 5000)// Now all requests will be expired after 5000ms.// Use it in Vue Component.const SomeComponent = Vue.extend(&#123; methods: &#123; getData () &#123; this.$jsonp('http://www.some-site.com/data', &#123; name: 'MyName', age: 20 &#125;).then(json =&gt; &#123; // Success. &#125;).catch(err =&gt; &#123; // Failed. &#125;) &#125; &#125;&#125;)// Static Function.// Request url will be 'http://www.some-site.com/data?name=MyName&amp;age=20&amp;cb=jsonpFunc'Vue.jsonp('http://www.some-site.com/data', &#123; name: 'MyName', age: 20, callbackQuery: 'cb', callbackName: 'jsonpFunc'&#125;).then(json =&gt; &#123; // Success.&#125;).catch(err =&gt; &#123; // Failed.&#125;) LicenseMIT.","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"10-http","slug":"vue/10-http","permalink":"http://yoursite.com/categories/vue/10-http/"}],"tags":[]},{"title":"10-promise","slug":"vue/10-http/10-2-2-promise","date":"2018-05-10T01:32:35.002Z","updated":"2018-05-10T01:35:09.919Z","comments":true,"path":"2018/05/10/vue/10-http/10-2-2-promise/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/10-http/10-2-2-promise/","excerpt":"","text":"promise-new学习视频参考网址 什么是promise1234567promie用于异步计算一个promise表示一个现在,将来或者是永远不可能可用的值(一个异步的数据)promise可以将一系列异步操作队列化,按照期望的执行,返回预期的结果 为什么会有promise问题解析123456789101112131415161718同步: 代码的同步存在一些问题: 代码的同步执行会造成程序的阻塞异步: 在js中,存在大量异步执行的代码 1. 事件操作 document.getElementById().addEventEstener() 2. ajax 3. 文件操作 nodejs文件读取 ...... 在nodejs推行之后,对于异步的依赖进一步加强 nodejs的特性: 无阻塞,高并发 其异步特性主要是通过异步操作实现 异步操作能够在很大程度上解决代码的阻塞问题,但是一不小心,就会陷入回调地狱 回调地狱 看下面一段nodejs文件读取的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//引入相关模块const fs=require(&quot;fs&quot;);const path=require(&quot;path&quot;);var dirPath=path.resolve(__dirname,&apos;js&apos;);var filePath=path.resolve(dirPath,&apos;test.txt&apos;);var dirExists=fs.existsSync(dirPath);var fileExists=fs.existsSync(filePath);//删除文件if(fileExists)&#123;//如果存在文件先删除文件 fs.unlinkSync(filePath); console.log(&quot;删除文件成功&quot;);&#125;//删除目录if(dirExists)&#123;//如果存在目录先删除目录 fs.rmdirSync(dirPath); console.log(&quot;删除目录成功&quot;);&#125;//创建目录fs.mkdir(dirPath,(err)=&gt;&#123; if(err)&#123; console.log(&quot;创建目录失败&quot;); &#125;else&#123; console.log(&quot;创建目录成功&quot;); //写入文件 fs.writeFile(filePath,&quot;第二周周考&quot;,(err)=&gt;&#123; if(err)&#123; //输出失败 console.log(&quot;创建文件失败&quot;); &#125;else&#123; //创建成功 console.log(&quot;创建文件成功&quot;); //读取文件 fs.readFile(filePath,function(err,data)&#123; if(err)&#123; //读取失败 console.log(&quot;读取文件失败&quot;); &#125;else&#123; //读取文件内容成功 console.log(&quot;读取文件成功，文件内容为：&quot;+data); &#125; &#125;) &#125; &#125;) &#125;&#125;) 问题总结12345678 1. 回调层次很深, 难以维护 2. 在多个回调之间难以简历联系 3. 无法正常检索堆栈信息 4. 无法正常使用return 和 throwpromise的诞生就是解决上述这一类问题 promise基本使用基本示例 使用promise , 可以很有效的解决异步问题(回调地狱) 同时避免了代码深层回调的难易维护的问题 12345678910111213141516171819202122232425console.log(&quot;这是同步执行的代码1&quot;)var p = new Promise(function(resolve, reject) &#123; // 定义一个异步的操作 setTimeout(function() &#123; resolve(&quot;这是异步执行的,与1s之后返回数据&quot;) &#125;, 1000)&#125;)// 通过then方法获取promise 返回的值p.then(function(data)&#123; console.log(data) // 可以在这里再定义一些异步操作&#125;)console.log(&quot;这是同步执行的代码2&quot;) 代码解析 test阿达 使用new Promise() 创建一个promie对象,参数是一个回调函数 回调函数有两个参数 参数1: resolve/fulfilled,表示回调执行成功的状态,当执行成功的时候,使用resolve()定义成功的情况下,promise返回的数据 参数2: reject, 表示回调执行失败的状态,当执行失败的时候,使用reject()定义请求失败的情况下返回的数据 使用promise实例的then方法获取promise对象返回的数据 promise的三种状态 pending : 进行中, 当使用new Promise()创建完promise对象之后,这个异步操作就已经开始在堆栈中执行 在这个过程中确定异步操作的状态,成功或者是失败,而且一旦状态确定之后,是不可改变的 当状态发生改变之后, 就会立即执行then() fulfiled / resolve: 操作成功的状态 reject: 操作失败的状态 执行过程 链式写法 promise支持链式调用 12345678910111213141516171819console.log(&quot;这是同步执行的代码1&quot;)var p = new Promise(function(resolve, reject) &#123; // 定义一个异步的操作 setTimeout(function() &#123; resolve(&quot;这是异步执行的,与1s之后返回数据&quot;) &#125;, 1000)&#125;).then(function(data)&#123; console.log(data) // 可以在这里再定义一些异步操作&#125;)console.log(&quot;这是同步执行的代码2&quot;) 多层promise123456789101112131415161718192021222324console.log(&quot;这是同步执行的代码1&quot;)var p = new Promise(function(resolve, reject) &#123; // 1. 定义第一个异步的操作 setTimeout(function() &#123; resolve(&quot;这是第一个异步执行的操作,与1s之后返回数据&quot;) &#125;, 1000)&#125;).then(function(data) &#123; console.log(data) // 2. 定义第二个异步的操作 ---- 返回一个Promise对象 return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(&quot;这是第二个异步执行的操作,与1s之后返回数据&quot;) &#125;, 1000) &#125;)&#125;).then(function(data) &#123; console.log(data)&#125;)console.log(&quot;这是同步执行的代码2&quot;) promise实例的方法then() then方法的简单解析 then()接收两个函数作为参数,对应promise的两种状态 resolve reject then()返回一个新的promise实例,支持链式调用 then()会根据promise的状态来确定执行的函数 12345678910111213141516171819202122232425262728console.log(&quot;这是同步执行的代码1&quot;)var p = new Promise(function(resolve, reject) &#123; // 1. 定义一个异步的操作 setTimeout(function() &#123; var num = Math.ceil(Math.random() * 10); //生成1-10的随机数 if(num &lt;= 5) &#123; resolve(num); &#125; else &#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 1000); &#125;).then(function(data) &#123; console.log(data)&#125;,function(error)&#123; console.log(error)&#125;)console.log(&quot;这是同步执行的代码2&quot;) 当回调成功的时候,执行then()的第一个回调,失败的时候,执行第二个回调 catch() catch方法用于错误捕获 推荐使用catch捕获错误,而不是直接使用then的第二个参数,使用catch的好处在于可以避免一些遗漏的错误 123456789101112131415161718192021222324252627282930313233console.log(&quot;这是同步执行的代码1&quot;)var p = new Promise(function(resolve, reject) &#123; // 1. 定义一个异步的操作 setTimeout(function() &#123; var num = Math.ceil(Math.random() * 10); //生成1-10的随机数 if(num &lt;= 5) &#123; resolve(num); &#125; else &#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 1000); &#125;).then(function(data) &#123; console.log(data)&#125;).catch(function(error)&#123; console.log(error)&#125;)/* * * 推荐使用链式调用,增强代码可读性的同时 也有利于错误的整体捕获 * * */console.log(&quot;这是同步执行的代码2&quot;) all() 提供了并行执行多个异步操作的能力,技能对个promise实例,包装成一个promise实例 返回的结果根据子promise的状态确定 12345678910111213141516171819202122232425262728293031323334353637383940414243console.log(&quot;这是同步执行的代码1&quot;)function runAsync1() &#123; var p = new Promise(function(resolve, reject) &#123; //做一些异步操作 setTimeout(function() &#123; console.log(&apos;异步任务1执行完成&apos;); resolve(&apos;随便什么数据1&apos;); &#125;, 1000); &#125;); return p;&#125;function runAsync2() &#123; var p = new Promise(function(resolve, reject) &#123; //做一些异步操作 setTimeout(function() &#123; console.log(&apos;异步任务2执行完成&apos;); resolve(&apos;随便什么数据2&apos;); &#125;, 2000); &#125;); return p;&#125;function runAsync3() &#123; var p = new Promise(function(resolve, reject) &#123; //做一些异步操作 setTimeout(function() &#123; console.log(&apos;异步任务3执行完成&apos;); resolve(&apos;随便什么数据3&apos;); &#125;, 2000); &#125;); return p;&#125;//Promise的all方法提供了并行执行多个异步操作的能力，并且在所有异步操作执行完后才执行回调Promise .all([runAsync1(), runAsync2(), runAsync3()]) .then(function(results) &#123; console.log(results); &#125;);console.log(&quot;这是同步执行的代码2&quot;) 注意事项 1231. 所有的promise执行成功,返回的是所有的子promise的结果组成的数组2. 有一个子promise失败,返回的是第一个失败的结果 race() 根据异步执行的事件确定异步执行的次序 123456789101112131415161718192021222324252627282930313233//请求某个图片资源function requestImg() &#123; var p = new Promise(function(resolve, reject) &#123; var img = new Image(); img.onload = function() &#123; resolve(img); &#125; img.src = &apos;xxxxxx&apos;; &#125;); return p;&#125;//延时函数，用于给请求计时function timeout() &#123; var p = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; reject(&apos;图片请求超时&apos;); &#125;, 5000); &#125;); return p;&#125;Promise//all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，//那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」 .race([requestImg(), timeout()]) .then(function(results) &#123; console.log(results); &#125;) .catch(function(reason) &#123; console.log(reason); &#125;); promise的应用12345671. promise.all()和map连用,将一组操作转化成一个promise集合2. 实现队列,有的时候,我们不希望所有的事情一次性发生,而是按照一定的顺序进行 all race3. 将回调包装成promise.......... promise的支持jquery已经实现了promsise 在新版本里面 jquery的ajax已经实现了promise 返回的是一个promise实例 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var url = &apos;./my.json&apos; $.ajax(url).then((res) =&gt; &#123; console.log(res) &#125;)&lt;/script&gt; ie的支持123ie浏览器并不包含原生的promise支持只想实现异步队列 使用jQuery.defered 兼容性类库12promise polyfillblueBird fetch API 是XmlHttpRequest的现代化替代方案 更强大,更友好,直接返回一个promise实例 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var url = &apos;./my.json&apos; fetch(url).then((res) =&gt; &#123; return res.json() &#125;).then((data)=&gt;&#123; console.log(data) // 得到数据使用即可 &#125;)&lt;/script&gt; es2017异步函数.png).png).png)","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"10-http","slug":"vue/10-http","permalink":"http://yoursite.com/categories/vue/10-http/"}],"tags":[]},{"title":"10-promise","slug":"vue/10-http/10-2-1-promise","date":"2018-05-10T01:32:35.000Z","updated":"2018-05-10T01:34:59.987Z","comments":true,"path":"2018/05/10/vue/10-http/10-2-1-promise/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/10-http/10-2-1-promise/","excerpt":"","text":"Promise-old 就是一个对象,用来传递异步操作的消息,是解决异步编程的一种方案 简单理解promise提供了统一的API,各种异步操作都可以使用同样的方法进行处理 有待完善 promise特点（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本使用 简化层层回调 Promise的构造函数接收一个参数，这个参数是一个函数，并且传入两个参数： resolve: 表示异步操作执行成功后的回调函数 reject: 异步操作执行失败后的回调函数 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var p = new Promise(function(resolve, reject) &#123; //resolve:执行成功的回调函数 //reject:执行失败的回调函数 //做一些异步操作 setTimeout(function() &#123; var num = Math.ceil(Math.random() * 10); //生成1-10的随机数 if(num &lt;= 5) &#123; resolve(num); &#125; else &#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 1000); &#125;); p.then( //执行成功的回调 function(data) &#123; console.log(&apos;执行成功-resolve回调执行&apos;); console.log(data); &#125;, //执行失败的回调 function(reason, data) &#123; console.log(&apos;执行失败-reject回调执行&apos;); console.log(reason); &#125; );&lt;/script&gt; 常用的方法自身的方法 all() 提供并行执行异步的能力,也就是说,在所有的异步执行完毕之后才会执行回调 race() 根据程序执行的时间来决定执行的次序 reject() 执行失败的回调 resolve() 执行成功的回调 原型上的方法 then() 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; function getNumber() &#123; var p = new Promise(function(resolve, reject) &#123; //做一些异步操作 setTimeout(function() &#123; var num = Math.ceil(Math.random() * 10); //生成1-10的随机数 if(num &lt;= 5) &#123; resolve(num); &#125; else &#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 2000); &#125;); return p; &#125; getNumber() .then( //执行成功的回调 function(data) &#123; console.log(&apos;resolved&apos;); console.log(data); &#125;, //执行失败的回调 function(reason, data) &#123; console.log(&apos;rejected&apos;); console.log(reason); &#125; );&lt;/script&gt; catch() 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; function getNumber() &#123; var p = new Promise(function(resolve, reject) &#123; //做一些异步操作 setTimeout(function() &#123; var num = Math.ceil(Math.random() * 10); //生成1-10的随机数 if(num &lt;= 5) &#123; resolve(num); &#125; else &#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 1000); &#125;); return p; &#125; getNumber() .then(function(data) &#123; console.log(&apos;resolved&apos;); console.log(data); console.log(text)//test未定义 &#125;) //和then的第二个参数一样,用来指定失败的回调 //与then的第二个参数有区别的是,如果是执行错误的判断 .catch(function(reason) &#123; console.log(&apos;rejected&apos;); console.log(reason); &#125;);&lt;/script&gt; 综合12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; function getNumber() &#123; var p = new Promise(function(resolve, reject) &#123; //做一些异步操作 setTimeout(function() &#123; var num = Math.ceil(Math.random() * 10); //生成1-10的随机数 if(num &lt;= 5) &#123; resolve(num); &#125; else &#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 1000); &#125;); return p; &#125; getNumber() //可以传递两个参数,执行成功的回调和执行失败的回调 .then(function(data) &#123; console.log(&apos;resolved&apos;); console.log(data); console.log(text)//test未定义 &#125;) //和then的第二个参数一样,用来指定失败的回调 //与then的第二个参数有区别的是,如果是执行错误的判断 .catch(function(reason) &#123; console.log(&apos;rejected&apos;); console.log(reason); &#125;);&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"10-http","slug":"vue/10-http","permalink":"http://yoursite.com/categories/vue/10-http/"}],"tags":[]},{"title":"10-http","slug":"vue/10-http/10-1-vue-resource","date":"2018-05-10T01:32:34.999Z","updated":"2018-05-10T01:34:47.152Z","comments":true,"path":"2018/05/10/vue/10-http/10-1-vue-resource/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/10-http/10-1-vue-resource/","excerpt":"","text":"第十部分 vue-resource &amp; axios问题:在vue中如何请求数据? Resource插件简介 Vue.js的插件提供了使用XMLHttpRequest或JSONP 进行Web请求和处理响应的服务。 单来说，vue-resource就像jQuery里的$.ajax，用来进行数据交互 Vue-resource的特点1.体积小 vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。 2.支持主流的浏览器 和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。 3.支持Promise API和URI Templates(了解) Promise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。 URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。 4.支持拦截器(了解) 拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。 拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。 Vue-resource的使用方法详情可参考:Vue-resource Vue-resource的安装 下载 vue-resource.js文件,在本地引入 使用cdn加速服务 123&lt;script src=&quot;https://cdn.jsdelivr.net/vue.resource/1.2.1/vue-resource.min.js&quot;&gt;&lt;/script&gt;&lt; script src = &quot;https://cdn.jsdelivr.net/vue.resource/1.3.1/vue-resource.min.js&quot; &gt; &lt;/ script &gt; 基本使用 引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。 全局使用1.基于全局Vue对象使用http 1234//[]里面的内容表示的是可选的参数Vue.http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);Vue.http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback); 2.代码示例 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue-resource.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;sendGet()&quot;&gt;发送get请求&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //这里的this指代的是 vm对象 var url = &quot;http://127.0.0.1/00-vue/select.php&quot;; Vue.http.get(url).then(function(res) &#123; console.log(res.data) &#125;) var vm = new Vue(&#123; el: &quot;#app&quot; &#125;)&lt;/script&gt; 局部使用—-最常见的形式1.在一个Vue实例内使用$http1234//[]里面的内容表示的是可选的参数this.$http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);this.$http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback); 在发送请求后，使用then方法来处理响应结果， then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。 2.代码示例 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue-resource.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;sendGet()&quot;&gt;发送get请求&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, methods: &#123; sendGet: function() &#123; //这里的this指代的是 vm对象 var url = &quot;http://127.0.0.1/00-vue/select.php&quot;; this.$resource(url).get().then(function(res) &#123; console.log(res.data) &#125;) &#125; &#125; &#125;)&lt;/script&gt; 参考7种请求API get(url, [options]) head(url, [options]) delete(url, [options]) jsonp(url, [options]) post(url, [body], [options]) put(url, [body], [options]) patch(url, [body], [options]) 选项options 参数 类型 描述 url string 发送请求的URL body Object, FormData, string 作为请求主体发送的数据 headers Object 标题对象要作为HTTP请求标头发送 params Object 作为URL参数发送的参数对象 method string HTTP方法（例如GET，POST，…） responseType string 响应体的类型（例如text，blob，json，…） timeout number 请求超时（毫秒）（0意味着无超时） before function(request) 回调函数在发送请求选项之前修改它 progress function(event) 回调函数来处理上传的ProgressEvent ProgressEvent of uploads credentials boolean 指示是否应使用凭据进行跨站点访问控制请求 emulateHTTP boolean 使用HTTP POST发送PUT，PATCH和DELETE请求，并设置X-HTTP-Method-Override头 emulateJSON boolean 发送请求正文作为application/x-www-form-urlencoded内容类型 响应response请求使用以下属性和方法解析为响应对象： 属性 类型 描述 url string 响应URL来源 body Object, Blob, string 响应体 headers Header 响应标题对象 ok boolean HTTP状态码介于200和299之间 status number HTTP状态代码的响应 statusText string HTTP状态文本的响应 Method Type 描述 text() Promise 将body解释为字符串 json() Promise 将body解析为解析的JSON对象 blob() Promise 将身body解析为Blob对象 $http方式数据请求参考资料:$http get1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue-resource.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;sendGet()&quot;&gt;发送get请求&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, methods: &#123; sendGet: function() &#123; //这里的this指代的是 vm对象 var url = &quot;http://127.0.0.1/00-vue/select.php&quot;; this.$resource(url).get().then(function(res) &#123; console.log(res.data) &#125;) &#125; &#125; &#125;)&lt;/script&gt; post123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue-resource.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--添加一条数据--&gt; &lt;button v-on:click=&apos;add()&apos;&gt;添加&lt;/button&gt;&lt;br /&gt; &lt;!--定义文本框--&gt; &lt;table class=&quot;text&quot;&gt; &lt;tr&gt; &lt;td&gt;name：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; v-model=&apos;name&apos; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;age：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; v-model=&apos;age&apos; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;sex：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; v-model=&apos;sex&apos; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;classroom：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; v-model=&apos;classroom&apos; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;条数&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;th&gt;sex&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;(data,index) in arr&quot;&gt; &lt;td&gt;第&#123;&#123;index+1&#125;&#125;条&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.sex&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;!--点击按钮的时候删除一条数据--&gt; &lt;button&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &quot;hello vue!&quot;, arr: [], //定义文本框绑定值 name: &quot;&quot;, age: &quot;&quot;, sex: &quot;&quot;, classroom: &quot;&quot; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, //创建生命周期钩子,初始化页面渲染 created: function() &#123; this.query() &#125;, methods: &#123; //将数据查询的操作封装成一个方法------&gt; 封装一个query方法 query() &#123; var url = &quot;http://127.0.0.1/00-vue/select.php&quot;; this.$http.get(url).then((res) =&gt; &#123; this.arr = res.data &#125;) &#125;, //添加一条动态的数据 add: function() &#123; //1. 定义的url路径,也就是请求的路径 var url = &quot;http://127.0.0.1/00-vue/add.php&quot; //2. 发送的数据 var bodyData = &#123; name: this.name, age: this.age, sex: this.sex, classroom: this.classroom &#125; //3. 选项参数 var options = &#123; emulateJSON: true &#125; //使用vue-resource发送请求 this.$http.post(url, bodyData, options).then((res) =&gt; &#123; console.log(res.data) //重新查询 this.query() &#125;) &#125; &#125; &#125;)&lt;/script&gt; 发送post请求,需要传递三个参数 jsonp1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;vue-resource.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;sendJsonp()&quot;&gt;发送jsonp请求&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, methods: &#123; sendJsonp: function() &#123; //这里的this指代的是 vm对象 var url = &quot;http://api.douban.com/v2/movie/top250&quot;; this.$http.jsonp(url).then(function(res) &#123; console.log(res.data) &#125;) &#125; &#125; &#125;)&lt;/script&gt; $resource方式数据请求(简单了解) vue-resource提供了另外一种方式访问HTTP——resource服务，resource服务包含以下几种默认的action： 123456get: &#123;method: &apos;GET&apos;&#125;,save: &#123;method: &apos;POST&apos;&#125;,query: &#123;method: &apos;GET&apos;&#125;,update: &#123;method: &apos;PUT&apos;&#125;,remove: &#123;method: &apos;DELETE&apos;&#125;,delete: &#123;method: &apos;DELETE&apos;&#125; resource对象也有两种访问方式： 全局访问：Vue.resource 实例访问：this.$resource","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"10-http","slug":"vue/10-http","permalink":"http://yoursite.com/categories/vue/10-http/"}],"tags":[]},{"title":"09-路由","slug":"vue/09-router/09-vue-router","date":"2018-05-10T01:32:34.996Z","updated":"2018-05-10T01:34:34.244Z","comments":true,"path":"2018/05/10/vue/09-router/09-vue-router/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/09-router/09-vue-router/","excerpt":"","text":"第九部分 Vue-router过渡–单页面应用什么是单页面应用 根据不同的链接（也就是不同的路径）， 发送ajax , 请求不同的内容， 显示到页面指定的位置 1234567单页 Web 应用 (single-page application 简称为 SPA) 是一种特殊的 Web 应用。它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。 举例分析 类比于一个容器(杯子),可以存放各种饮品,但是杯子只有那么一个 在页面定义一个容器(div),存放对应的单页面,容器(div)只有一个,但是可以存放不同的页面,并且可以动态切换 单页面优缺点1、优点： 123456789101112131415161).良好的交互体验 用户不需要重新刷新页面，获取数据也是通过Ajax异步获取，页面显示流畅。2).良好的前后端工作分离模式 单页Web应用可以和RESTful规约一起使用，通过REST API提供接口数据，并使用Ajax异步获取， 这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分。3).减轻服务器压力 服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；4).共用一套后端程序代码 不用修改后端程序代码就可以同时用于Web界面、手机、平板等多种客户端； 2、缺点： 12345678910111213141).SEO难度较高 由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重， 且要用单页应用，那么就做些静态页面给搜索引擎用吧。2).前进、后退管理 由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立 堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现。3).初次加载耗时多 为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。 所以必须对JavaScript及CSS代码进行合并压缩处理，如果使用第三方库，建议使用一些大公司的CDN，因此带宽的消耗是必然的。 单页面应用的实现要点: 1.获取a链接中的hash内容 2.根据不同的hash值发送不同的请求 3.将响应回来的html片段渲染到指定的页面部分 小案例 页面的文档结构 页面标签(body)部分 js实现 问题: 可以使用原生的js来实现单页面应用,但是这样做是很繁琐的,有没有更好的方式啦帮助我们实现这样的功能呢? 基于vue的一个插件: vue-router Vue-router路由的概念 路由:简单来说是指根据url分配到对应的处理程序。也就是响应不同的页面内容 Vue-router简介 对于前端来说，其实浏览器配合超级链接就很好的实现了路由功能。但是对于单页面应用来说，浏览器和超级链接的跳转方式已经不能适用，所以各大框架纷纷给出了单页面应用的解决路由跳转的方案。 Vue框架的兼容性非常好，可以很好的跟其他第三方的路由框架进行结合。当然官方也给出了路由的方案： vue-router;建议还是用官方的最好，使用量也是最大，相对来说Vue框架的升级路由组件升级也会及时跟上，所以为了以后的维护和升级方便还是使用Vue自家的东西最好。 注意: vue-router@2.x 只适用于 Vue 2.x 版本。vue-router@1.x 对应于Vue1.x版本。 的Github地址：vue-router 文档地址 基本使用安装 CDN加速连接方式 1https://unpkg.com/vue-router/dist/vue-router.js npm 安装 1npm install vue-router 创建路由的简单案例演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--1. 引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #app&#123; width: 400px; margin: 100px auto; &#125; #app a&#123; text-decoration: blink; &#125; #app div&#123; width: 400px; height: 200px; background: pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--5. 路由导航 就是一个a连接,点击一个a链接,会跳转到指定的路径,也就是to的位置--&gt; &lt;router-link to=&apos;/tab1&apos;&gt;tab1&lt;/router-link&gt; &lt;router-link to=&apos;/tab2&apos;&gt;tab2&lt;/router-link&gt; &lt;!--6. 路由组件渲染的入口--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //2. 定义组件----使用构造器进行全局扩展,创建全局组件 //赋值操作,用一个变量名保存组件中所有的内容 var tab1Component = Vue.extend(&#123; template: &apos;&lt;div&gt;这是tab1 组件&lt;/div&gt;&apos; &#125;) var tab2Component = Vue.extend(&#123; template: &apos;&lt;div&gt;这是tab2 组件&lt;/div&gt;&apos; &#125;) //3. 使用路由接管组件的注册的组件,也就是说将路由(路径)和组件一一关联 // 点击一个路由(路径),显示一个组件 var vueRouter = new VueRouter(&#123; routes: [ &#123;path: &apos;/&apos;,redirect: &apos;tab2&apos;&#125;, &#123;path: &apos;/tab1&apos;,component: tab1Component&#125;, &#123;path: &apos;/tab2&apos;,component: tab2Component&#125; ] &#125;) //4. 创建Vue对象,挂载路由,实现视图和路由的关联 new Vue(&#123; router: vueRouter &#125;).$mount(&apos;#app&apos;)&lt;/script&gt; 路由的使用步骤 六部曲根据上面演示的案例做一个分析 1.引入js文件 12&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; 2.定义(注册)路由跳转的组件—-使用全局扩展的方式,用其他创建组件的方式也可以在这里,进行了一个赋值操作,用一个变量名保存组件中所有的内容 123456var tab1Component = Vue.extend(&#123; template: &apos;&lt;div&gt;这是tab1 组件&lt;/div&gt;&apos;&#125;)var tab2Component = Vue.extend(&#123; template: &apos;&lt;div&gt;这是tab2 组件&lt;/div&gt;&apos;&#125;) 3.使用路由接管我们注册的组件 1234567 var vueRouter = new VueRouter(&#123; routes: [ &#123;path: &apos;/&apos;,redirect: &apos;tab2&apos;&#125;, &#123;path: &apos;/tab1&apos;,component: tab1Component&#125;, &#123;path: &apos;/tab2&apos;,component: tab2Component&#125; ]&#125;) 4.创建router的实例并挂载根节点,将视图和路由进行关联 123new Vue(&#123; router: vueRouter&#125;).$mount(&apos;#app&apos;) 5.指定路由跳转的连接–路由导航,也就相当于一个a链接 12&lt;router-link to=&apos;/tab1&apos;&gt;tab1&lt;/router-link&gt;&lt;router-link to=&apos;/tab2&apos;&gt;tab2&lt;/router-link&gt; 6.路由的出口,将路由指定的组件渲染到页面上,相当于一个占位符号,用来显示路由对应的组件 1&lt;router-view&gt;&lt;/router-view&gt; 图示分析 重点 路由导航钩子『导航』表示路由正在发生改变 变化是一个过程,在变化的过程中执行哪些东西 路由的切换过程，本质上是执行一系列路由钩子函数，钩子函数总体上分为三大类： 全局的钩子函数 : 定义在全局的路由对象中 某个路由独享的钩子: 可以在路由配置上直接定义 beforeEnter 钩子 组件的钩子函数 : 定义在组件的route选项中 全局钩子 全局钩子函数有2个： beforeEach：在路由切换开始时调用 afterEach：在每次路由切换成功进入激活阶段时被调用 beforeEach1234567//ES6语法的箭头函数,尝试着理解一下const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) 12345678910111213141516171819当一个导航触发时，全局的 before 钩子按照创建顺序调用。钩子是异步解析执行，此时导航在所有钩子 resolve 完之前一直处于 等待中。每个钩子方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: 异步执行成功之后的回调函数 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮）， 那么 URL 地址会重置到 from 路由对应的地址。 next(&apos;/&apos;) 或者 next(&#123; path: &apos;/&apos; &#125;): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 确保要调用 next 方法，否则钩子就不会被 resolved。 afterEach 同样可以注册一个全局的 after 钩子，不过它不像 before 钩子那样，after 钩子没有 next 方法，不能改变导航： 123router.afterEach(route =&gt; &#123; // ...&#125;) 某个路由独享的钩子 你可以在路由配置上直接定义 beforeEnter 钩子： 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 这些钩子与全局 before 钩子的方法参数是一样的。 组件内的钩子最后，你可以在路由组件内直接定义以下路由导航钩子： beforeRouteEnter beforeRouteUpdate (2.2 新增) beforeRouteLeave 12345678910111213141516171819const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当钩子执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125;beforeRouteEnter 钩子 不能 访问 this，因为钩子在导航确认前被调用,因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125; 你可以 在 beforeRouteLeave 中直接访问 this。这个 leave 钩子通常用来禁止用户在还未保存修改前突然离开。可以通过 next(false) 来取消导航。 路由参数传递 在进行路由跳转的时候传递参数 , 大致有两种形式 在这两种形式下分别有两种书写形式,一种是标签的形式,一种是js的方式 queryparams 形似 /:id 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--5 添加路由跳转入口--&gt; &lt;router-link to=&quot;/login/9&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;!--6 组件的显示--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //1. 定义组件 var loginComponent = &#123; template: &quot;&lt;h2&gt;登录组件-----------&#123;&#123;$route.params.id&#125;&#125; +1&lt;/h2&gt;&quot; &#125; var registerComponent = &#123; template: &quot;&lt;h2&gt;注册组件&lt;/h2&gt;&quot; &#125; //2. 定义路由规则 var routes = [ //通过name和redirect实现默认路由 &#123; path: &apos;/&apos;, redirect: &apos;login&apos; //默认显示name为login的页面 &#125;, &#123; name: &apos;login&apos;, path: &apos;/login/:id&apos;, component: loginComponent &#125;, &#123; name: &apos;register&apos;, path: &apos;/register&apos;, component: registerComponent &#125; ] //3. 创建路由 var VueRouter = new VueRouter(&#123; routes: routes &#125;) //4. 创建vue对象,并添加路由 var vm = new Vue(&#123; el: &quot;#app&quot;, router: VueRouter &#125;) // this.$route.params 获取参数 &lt;/script&gt; 形似 ?name=1&amp;age=2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--添加路由跳转入口--&gt; &lt;router-link to=&quot;/login/9&quot;&gt;登录&lt;/router-link&gt; &lt;router-link :to=&quot;&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;&quot;&gt; 注册&lt;/router-link&gt; &lt;!--组件的显示--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //1. 定义组件 var loginComponent = &#123; template: &quot;&lt;h2&gt;登录组件-----------&#123;&#123;$route.params.id&#125;&#125; +1&lt;/h2&gt;&quot; &#125; var registerComponent = &#123; template: &quot;&lt;h2&gt;注册组件&#123;&#123;getName&#125;&#125;&lt;/h2&gt;&quot;, //组件中的data是一个方法,并且这个方法要返回一个对象,这个和new &lt;Vue&gt; &lt;/Vue&gt;中的data不一样 data() &#123; return &#123; uname: &apos;&apos; &#125; &#125;, //组件中的created是一个方法,返回一个对象 created() &#123; console.log(this.$route.query); this.uname = this.$route; &#125;, //computed相当于属性的一个实时计算，如果实时计算里关联了对象， //那么当对象的某个值改变的时候，同时会出发实时计算。 computed: &#123; getName: function() &#123; return &quot;hello&quot; + this.$route &#125; &#125;, &#125; //2. 定义路由规则 var routes = [ //通过name和redirect实现默认路由 &#123; path: &apos;/&apos;, redirect: &apos;login&apos; //默认显示name为login的页面 &#125;, &#123; name: &apos;login&apos;, path: &apos;/login/:id&apos;, component: loginComponent &#125;, &#123; name: &apos;register&apos;, path: &apos;/register&apos;, component: registerComponent &#125; ] //3. 创建路由 var VueRouter = new VueRouter(&#123; routes: routes &#125;) //4. 创建vue对象,并添加路由 var vm = new Vue(&#123; el: &quot;#app&quot;, router: VueRouter &#125;)&lt;/script&gt; 高级路由匹配模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 1. 引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Route Matching&lt;/h1&gt; &lt;!--5. 定义路由跳转的链接--&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to=&quot;/&quot;&gt;/&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/params/foo/bar&quot;&gt;/params/foo/bar&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/optional-params&quot;&gt;/optional-params&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/optional-params/foo&quot;&gt;/optional-params/foo&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/params-with-regex/123&quot;&gt;/params-with-regex/123&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/params-with-regex/abc&quot;&gt;/params-with-regex/abc&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/asterisk/foo&quot;&gt;/asterisk/foo&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/asterisk/foo/bar&quot;&gt;/asterisk/foo/bar&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/optional-group/bar&quot;&gt;/optional-group/bar&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/optional-group/foo/bar&quot;&gt;/optional-group/foo/bar&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Route context&lt;/p&gt; &lt;pre&gt;&#123;&#123; JSON.stringify($route, null, 2) &#125;&#125;&lt;/pre&gt; &lt;!--6 路由对应的组件的显示--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //2 定义组件 //3 定义路由表 var vueRouter = new VueRouter(&#123; mode:&apos;history&apos;, routes: [&#123; path: &apos;/&apos; &#125;, // params are denoted with a colon &quot;:&quot; &#123; path: &apos;/params/:foo/:bar&apos; &#125;, // a param can be made optional by adding &quot;?&quot; &#123; path: &apos;/optional-params/:foo?&apos; &#125;, // a param can be followed by a regex pattern in parens // this route will only be matched if :id is all numbers &#123; path: &apos;/params-with-regex/:id(\\\\d+)&apos; &#125;, // asterisk can match anything &#123; path: &apos;/asterisk/*&apos; &#125;, // make part of th path optional by wrapping with parens and add &quot;?&quot; &#123; path: &apos;/optional-group/(foo/)?bar&apos; &#125; ] &#125;) //4 挂载路由 var vm = new Vue(&#123; el: &quot;#app&quot;, router: vueRouter &#125;)&lt;/script&gt; vue-cli 在项目模板中,使用webpack模板 或者是 webpack-simple模板的时候根据以上步骤简单改写即可, 但是在学习的过程中,推荐使用webpack-simple,便于加深理解 这一部分详细的内容不多做介绍 组件懒加载 在文件的体积和请求次数之间做好权衡 打包的文件过大, 请求时间长,影响页面加载, 效果体验差 文件分割, 文件个数多,请求次数增加 …… 按需请求是一种比较理想的状态 123456当打包构建应用时，Javascript 包会变得非常大，影响页面加载。 如果我们能把不同路由对应的组件分割成不同的代码块， 然后当路由被访问的时候才加载对应组件，这样就更加高效了。 路由中配置组件懒加载 平时我们书写的方式,这种方式下,所有的组件都会合并到一个文件中 12345678910111213141516171819202122232425262728293031import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos;Vue.use(Router)import tab1 from &apos;@/components/tab1&apos;import tab2 from &apos;@/components/tab2&apos;import tab3 from &apos;@/components/tab3&apos;export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;HelloWorld&apos;, component: HelloWorld &#125;, &#123; path:&apos;/tab1&apos;, component:tab1 &#125;, &#123; path:&apos;/tab2&apos;, component:tab2 &#125;, &#123; path:&apos;/tab3&apos;, component:tab3 &#125; ]&#125;) 也就是实现异步组件,在异步组件的时候,所有的组件单独分割到一个文件中 123456789101112131415161718192021222324252627import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;HelloWorld&apos;, component: HelloWorld &#125;, &#123; path:&apos;/tab1&apos;, component:resolve =&gt; require([&apos;../components/tab1.vue&apos;], resolve),//懒加载 &#125;, &#123; path:&apos;/tab2&apos;, component:resolve =&gt; require([&apos;../components/tab2.vue&apos;], resolve),//懒加载 &#125;, &#123; path:&apos;/tab3&apos;, component:resolve =&gt; require([&apos;../components/tab3.vue&apos;], resolve),//懒加载 &#125; ]&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"09-router","slug":"vue/09-router","permalink":"http://yoursite.com/categories/vue/09-router/"}],"tags":[]},{"title":"08-组件下","slug":"vue/08-组件下/08-component2","date":"2018-05-10T01:32:34.995Z","updated":"2018-05-10T01:34:25.894Z","comments":true,"path":"2018/05/10/vue/08-组件下/08-component2/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/08-组件下/08-component2/","excerpt":"","text":"第八部分 Vue.js组件（下）自定义事件 之前已经讲解过了父组件数据向子组件数据的传递 子组件要把数据传递回去,应该怎样做？ vue提供的解决的方案: 自定义事件 12345678910每个 Vue 实例都实现了事件接口(Events interface)，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件类似于我们注册(vue中是$on)点击事件,通过鼠标点击触发(vue中是emit) document.onclick = function(event)&#123; console.log(111) &#125; 123Vue的事件系统分离自浏览器的EventTarget API。尽管它们的运行类似，但是$on 和 $emit 不是addEventListener 和 dispatchEvent 的别名。另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。 不能用$on侦听子组件抛出的事件，而必须在模板里直接用v-on绑定 使用v-on绑定自定义事件 非父子组件通信 也就是不相关的组件之间的通信,在这里涉及到不同的实例的组件 这一部分的问题有点复杂,今天先做一个简单的了解,在今后的课程中还会给大家详细的讲解 知识点解读 案例演示 我们先看下面的这个简单的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style&gt; #dv1, #dv2 &#123; width: 500px; height: 100px; &#125; #dv1 &#123; border: 1px solid red; margin: 50px auto; &#125; #dv2 &#123; border: 1px solid green; margin: 50px auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app2&quot;&gt; &lt;component2&gt;&lt;/component2&gt; &lt;/div&gt; &lt;div id=&quot;app1&quot;&gt; &lt;component1&gt;&lt;/component1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建一个空的公共的vue对象 var bus = new Vue(); //2. 在vm1实例中创建组件1,定义$emit来发送数据 var vm1 = new Vue(&#123; el: &apos;#app1&apos;, components: &#123; component1: &#123; template: `&lt;div id=&quot;dv1&quot; v-on:click=&quot;add&quot;&gt; &lt;div&gt;点击我,触发自定义事件,进行数据的传递&lt;/div&gt; &lt;div&gt;当前的数据是:&#123;&#123;num&#125;&#125;&lt;/div&gt; &lt;/div&gt;`, data: function() &#123; return &#123; num: 0 &#125; &#125;, methods: &#123; add: function() &#123; this.num++; bus.$emit(&apos;test&apos;, this.num) &#125; &#125; &#125; &#125; &#125;) //在vm2实例中创建组件2,定义$on来接收传递的数据 var vm2 = new Vue(&#123; el: &apos;#app2&apos;, components: &#123; component2: &#123; template: `&lt;div id=&quot;dv2&quot; v-on:click=&quot;result&quot;&gt; &lt;div&gt;点击我,进行自定义事件的注册&lt;/div&gt; &lt;div&gt;传递过来的数据是&#123;&#123;getData&#125;&#125;&lt;/div&gt; &lt;/div&gt;`, data: function() &#123; return &#123; getData: 0 &#125; &#125;, methods: &#123; result: function() &#123; //this问题 var vm2This = this; bus.$on(&apos;test&apos;, function(num) &#123; vm2This.getData = num; //事件的解绑问题 bus.$off(&quot;test&quot;) &#125;) &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt; 分析 我们对上述的例子做一个分析,大致可以分成下面几个步骤 1.创建一个空的公共的vue对象 1var bus = new Vue(); 2.在vm1实例中创建组件1,定义$emit来发送数据 12345678910111213141516171819202122var vm1 = new Vue(&#123; el: &apos;#app1&apos;, components: &#123; component1: &#123; template: `&lt;div id=&quot;dv1&quot; v-on:click=&quot;add&quot;&gt; &lt;div&gt;点击我,触发自定义事件,进行数据的传递&lt;/div&gt; &lt;div&gt;当前的数据是:&#123;&#123;num&#125;&#125;&lt;/div&gt; &lt;/div&gt;`, data: function() &#123; return &#123; num: 0 &#125; &#125;, methods: &#123; add: function() &#123; this.num++; bus.$emit(&apos;test&apos;, this.num) &#125; &#125; &#125; &#125;&#125;) 3.在vm2实例中创建组件2,定义$on来接收传递的数据1234567891011121314151617181920212223242526272829var vm2 = new Vue(&#123; el: &apos;#app2&apos;, components: &#123; component2: &#123; template: `&lt;div id=&quot;dv2&quot; v-on:click=&quot;result&quot;&gt; &lt;div&gt;点击我,进行自定义事件的注册&lt;/div&gt; &lt;div&gt;传递过来的数据是&#123;&#123;getData&#125;&#125;&lt;/div&gt; &lt;/div&gt;`, data: function() &#123; return &#123; getData: 0 &#125; &#125;, methods: &#123; result: function() &#123; //this问题 var vm2This = this; //事件的解绑问题 bus.$off(&quot;test&quot;) bus.$on(&apos;test&apos;, function(num) &#123; vm2This.getData = num; &#125;) &#125; &#125; &#125; &#125;&#125;) 4.将组件添加到页面中指定的位置1234567&lt;div id=&quot;app2&quot;&gt; &lt;component2&gt;&lt;/component2&gt;&lt;/div&gt;&lt;div id=&quot;app1&quot;&gt; &lt;component1&gt;&lt;/component1&gt;&lt;/div&gt; slot引入:问什么要有slot1234567891011之前我们学习了组件的注册(创建)以及组件之间的通信,这些都是将已经提前封装好的组件拿来使用,都是已经写死的组件,存在的问题: 有时候由于某些原因,我们需要对组件进行局部的改变 如果还是按照之前的观点,我们就需要重新定义组件,这样就会显得有点复杂了!也就是说我们有时候需要的不是固定不变的组件,需要的是可以进行内容修改的组件 --类似于之前讲解的动态的prop和静态的prop--大家可以简单的体味一下针对这样的问题,vue给我们提供了一种解决的方案,也就是使用slot slot简介 有时候,我们需要对组件进行局部的修改, vue提供了一种方式来混合父组件的内容与子组件自己的模板 这个过程被称为 内容分发 也就是slot 如何使用slot slot协助子组件对父容器写入的标签进行管理。 具体可分成几种不同的情况,我们结合下面的例子做一个具体的分析 一个简单的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue入门之extend全局方法&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--父容器输入标签,会将slot标签替换掉--&gt; &lt;my-slot&gt; &lt;h3&gt;这里是父容器写入的&lt;/h3&gt; &lt;/my-slot&gt; &lt;!--父容器绑定数据到子容器的slot,会将slot中的数据替换掉--&gt; &lt;my-slot&gt;&#123;&#123; email &#125;&#125;&lt;/my-slot&gt; &lt;!--父容器什么都不传内容--&gt; &lt;my-slot&gt;&lt;/my-slot&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; // 反引号：可以定义多行字符串。 var temp = ` &lt;div&gt; &lt;h1&gt;这里是子组件&lt;/h1&gt; &lt;hr&gt; &lt;slot&gt;slot标签会被父容器写的额外的内容替换掉，如果父容器没有写入任何东西，此标签将保留！&lt;/slot&gt; &lt;/div&gt; `; Vue.component(&apos;MySlot&apos;, &#123; // 如果定义的组件为MySlot，那么用组件的时候：&lt;my-slot&gt;&lt;/my-slot&gt; template: temp, &#125;); // 初始化一个Vue实例 var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; email: &apos;flydragon@gmail.com&apos; &#125; &#125;); &lt;/script&gt; 具名slot 元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。 具名 slot 将匹配内容片段中有对应 slot 特性的元素 仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。 动态组件 通过使用保留的 元素，动态地绑定到它的 is 特性，我们让多个组件可以使用同一个挂载点，并动态切换 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;动态组件&lt;/h3&gt; &lt;!-- 定义三个temp模板，用于切换 --&gt; &lt;template id=&quot;temp-tab01&quot;&gt; &lt;div&gt;this is tab01&lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;temp-tab02&quot;&gt; &lt;div&gt;this is tab02&lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;temp-tab03&quot;&gt; &lt;div&gt;this is tab03&lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;dr01&quot;&gt; &lt;!-- 导航栏 --&gt; &lt;div class=&quot;border cf&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot; @click=&quot;toggleTabs(tab01Text);&quot;&gt;&#123;&#123;tab01Text&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot; @click=&quot;toggleTabs(tab02Text);&quot;&gt;&#123;&#123;tab02Text&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot; @click=&quot;toggleTabs(tab03Text);&quot;&gt;&#123;&#123;tab03Text&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 点击导航后要切换的内容 --&gt; &lt;div class=&quot;border&quot; style=&quot;height: 100px;&quot;&gt; &lt;!-- 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数 --&gt; &lt;component :is=&quot;currentView&quot; keep-alive&gt;&lt;/component&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;//通过使用保留的 &lt;component&gt; 元素，动态地绑定到它的is属性，我们让多个组件可以使用同一个挂载点，并动态切换： //扩展组件tab01 var tab01 = Vue.extend(&#123; template: &quot;#temp-tab01&quot;, &#125;); //扩展组件tab02 var tab02 = Vue.extend(&#123; template: &quot;#temp-tab02&quot;, &#125;); //扩展组件tab03 var tab03 = Vue.extend(&#123; template: &quot;#temp-tab03&quot;, &#125;); //新建vue实例 var dr01 = new Vue(&#123; el: &quot;#dr01&quot;, data: &#123; tab01Text: &quot;tab01&quot;, //导航栏文本1 tab02Text: &quot;tab02&quot;, //导航栏文本2 tab03Text: &quot;tab03&quot;, //导航栏文本3 currentView: &apos;tab01&apos;, //默认选中的导航栏 &#125;, //局部注册组件 components: &#123; tab01: tab01, tab02: tab02, tab03: tab03, &#125;, methods: &#123; //绑定tab的切换事件 toggleTabs: function(tabText) &#123; this.currentView = tabText; &#125; &#125; &#125;);&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"08-组件下","slug":"vue/08-组件下","permalink":"http://yoursite.com/categories/vue/08-组件下/"}],"tags":[]},{"title":"07-组件上","slug":"vue/07-组件上/07-component1","date":"2018-05-10T01:32:34.994Z","updated":"2018-05-10T01:34:17.658Z","comments":true,"path":"2018/05/10/vue/07-组件上/07-component1/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/07-组件上/07-component1/","excerpt":"","text":"第七部分 Vue.js组件（上）引入123456781. 笔记本电脑的外置鼠标和键盘2. 手机的内存卡, u盘, 耳机3. 女孩子的发卡饰物共性 1. 这些东西都可以看成是整体可缺的一部分(组成部分),但是他们的存在都有其存在的意义, 有着难以替代(相对而言)的好处 2. 复用(重用) 1234组件: 顾名思义, 也就是组成的部件, 即整体的组成部分 这个组成部分是可以缺少的,但是其存在的意义是无可替代的 这个组成部分也是可以复用的 vue组件化又是什么呢? 组件介绍12345678vue组件 1. 是页面组成的一部分 2. 是封装好的可重用的代码 也就是说,我们将页面上的一些元素抽取出来,做成一个组件, 需要的时候直接调用组件就可以了 这样就避免了多次写重复的内容 组件注册 注册的方式有很多种 全局注册1 大致可以分成三步 在我们引入vue.js之后,Vue会被注册为一个全局对象,我们使用对象本身的方法进行组件的创建 使用Vue这个全局对象的component方法进行全局注册一个组件 创建根实例,进行视图的绑定 组件的显示 将组价的名称作为标签写在视图内部,就能够完成组件的显示 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--3. 定义的组件名作为标签存在,将组件显示在页面上--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //1. 使用vue这个全局队形内置的components方法进行组件的创建 //在components这个方法中有两个重要的参数,第一个参数是组件的名称,第二个参数是组件的内容 Vue.component(&apos;my-component&apos;, &#123; //在这里使用一个父标签将组件包裹起来 template: &apos;&lt;div&gt;&lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;/div&gt;&apos; &#125;) //2. 创建根实例,也就是实例化一个vue对象,进行视图的绑定 var vm = new Vue(&#123; el: &apos;#app&apos; &#125;)&lt;/script&gt; 全局注册2 使用全局的Vue.extend()构造器进行注册 Vue.extend()类似于继承,通过这个构造器扩展(继承)之后,相当于Vue对象本身添加了一些这个对象原先没有的东西 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue入门之extend全局方法&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //通过构造器创建一个组件,相当于在vue这个全局对象本身上添加了一些新的内容,作用相当于构造函数 //----继承自vue,但是比vue本身更强大 var myVue = Vue.extend(&#123; template: &apos;&lt;div&gt;这是通过构造器创建出来的组件&lt;/div&gt;&apos; &#125;); var app = new myVue(&#123; el: &apos;#app&apos; &#125;);&lt;/script&gt; 局部注册1 大致分成两个部分 穿件跟实例 在跟实例内部定义组件 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--3. 这是我定义的组件 占位标签--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //1. 创建根实例 var vm = new Vue(&#123; el: &apos;#app&apos;, //2. 在根实例内部创建组件 components:&#123; &apos;my-component&apos;:&#123; template: &apos;&lt;div&gt;&lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;/div&gt;&apos; &#125; &#125; &#125;)&lt;/script&gt; 组件注册的其它方式112345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--这是我定义的组件--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;template id=&quot;my-template&quot;&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;/template&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 注意组件的模板替换了自定义元素，自定义元素的作用只是作为一个挂载点。 ----这可以用实例选项 replace 改变。 --&gt;&lt;script&gt; //1. --定义 + 注册 组件构造器 Vue.component(&apos;my-component&apos;, &#123; //将template的内容提取到一个标签中,通过id来获取 template: &apos;#my-template&apos; &#125;) //2. 创建根实例 var vm = new Vue(&#123; el: &apos;#app&apos; &#125;)&lt;/script&gt; 组件注册的其它方式21234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--这是我定义的组件--&gt; &lt;template&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;/template&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 自定义的标签只是自定义组件的一个挂载点,自定义组件会将其替换掉----直接使用自定义的组件将自定义的标签替换--&gt;&lt;script&gt; //2. 创建根实例 var vm = new Vue(&#123; el: &apos;#app&apos; &#125;)&lt;/script&gt; 组件内部的data 组件内部的data属性必须是一个函数 以全局注册的组件为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--全局的组件--&gt; &lt;ab&gt;&lt;/ab&gt; &lt;!--局部的组件--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //自定义指令 //Vue.directive(&apos;指令名&apos;,&#123;&#125;) //定义组件 参数1:组件的名称 参数2: 对象 Vue.component(&quot;ab&quot;,&#123; template: `&lt;ul&gt; &lt;li&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;age&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;sex&#125;&#125;&lt;/li&gt; &lt;/ul&gt;`, //data属性的属性值是一个函数----函数内部返回一个对象 data:function()&#123; return &#123; name:&quot;首页&quot;, age:&quot;联系我们&quot;, sex:&quot;新闻&quot; &#125; &#125; &#125;) //2. 创建根实例-----并在根实例下面创建一个局部的组件 var vm = new Vue(&#123; el: &apos;#app&apos;, //局部组件 components:&#123; &apos;my-component&apos;:&#123; template: `&lt;ul&gt; &lt;li&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;age&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;sex&#125;&#125;&lt;/li&gt; &lt;/ul&gt;`, data:function()&#123; return &#123; name:1, age:2, sex:3 &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt; 父子组件通信 之前在第四章介绍构造器的时候简单的涉及了一些父子组件的概念 什么是父子组件1&gt; 我们可以把页面当成是一个父组件,里面包含的元素就是子组件,只不过当时的讲解不是太清晰 12345我们已经学习过组件的创建,我们可以创建两个组件,一个组件的内部包含另外一个组件内部的组件称为子组件,外部的组件称为父组件,这就是父子组件可以理解成组建的嵌套 组件的作用域问题 在理解上,可以参考我们js中变量的作用域,但是有些区别 组件会产生独立的作用域,不能在子组件中使用父组件的数据,这个要与变量的作用域区分开来 为了解决这种问题,vue提供了响应的解决方案 我们在这里以简单的父子组件作为演示–直接传值是会报错的 父子组件通信—-解决父子组件传值问题 就是信息的传递,在vue里面指的就是数据的传递 在这里涉及到数据的传递的概念 在上下级组件之间进行数据的传递,也就是父子组件通信 父组件需要将数据传递给子组件 自组件需要将其内部发生的事情通告给父组件 父组件将数据传递给自组件使用prop子组件将其内部发生的事情通告给父组件使用emit Props 与 camelCase使用prop实现父组件上的数据向子组件的传递 数据传输分三步:123451. 进行数据的传输,首先要有数据,也就是要在父组件上定义数据2. 使用props建立数据通信的渠道3. 在子组件中接收父组件通过props传递过来的数据 动态props 上面传递的数据是静态的 写死的数据,不会变化,vue讲究的是数据的双向绑定,是动态的,显然这样并不能够达到我们的要求 在模板中，要动态地绑定父组件的数据到子模板的props，与绑定到任何普通的HTML特性相类似，就是用 v-bind 每当父组件的数据变化时，该变化也会传导给子组件 动态props vs 静态props 降低了数据的灵活性,没有做到视图与数据分离,而导致数据操作的不方便 动态props使用技能提升-列表渲染 复杂的父子组件的props 有能力的同学可以多做尝试,按照自己的想法自定义父子组件,进行值的传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; &lt;template id=&quot;parent&quot;&gt; &lt;div&gt; &lt;div&gt;我是父组件&lt;/div&gt; &lt;child :message=&quot;message&quot;&gt;&lt;/child&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;child&quot;&gt; &lt;div&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, //我是父组件 components:&#123;&apos;parent&apos;:&#123; template:&quot;#parent&quot;, data:function()&#123; return &#123; message:&quot;hello world&quot; &#125; &#125;, //我是子组件 components:&#123;&apos;child&apos;:&#123; props:[&apos;message&apos;], template:&quot;#child&quot; &#125;&#125; &#125;&#125; &#125;)&lt;/script&gt; 字面量语法 vs 动态语法 使用字面量语法传递数字,有时候会出现问题 单向数据流 数据从父组件传递到子组件,但是不会反过来传递 数据传递-注意事项 在 JavaScript 中对象和数组是引用类型，指向同一个内存空间， 如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 prop验证(了解) 我们可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue 会发出警告。当组件给其他人使用时，这很有用。 简单示例 要尝试着去做一些新的东西,不要只是满足于课堂所学 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;prop-ver :prop-a=&quot;num&quot; :prop-b=&quot;num2&quot; :prop-c=&quot;num3&quot; :prop-d=&quot;num4&quot; :prop-e=&quot;num5&quot; :prop-f=&quot;num6&quot;&gt;&lt;/prop-ver&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var propVer = &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组／对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function() &#123; return &#123; message: &apos;hello&apos; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function(value) &#123; return value &gt; 10 &#125; &#125; &#125;, template: &apos;&lt;div&gt;&#123;&#123;propA&#125;&#125;---&#123;&#123;propB&#125;&#125;---&#123;&#123;propC&#125;&#125;---&#123;&#123;propD&#125;&#125;---&#123;&#123;propE&#125;&#125;---&#123;&#123;propF&#125;&#125;&lt;/div&gt;&apos; &#125;; new Vue(&#123; el: &apos;#app&apos;, data: &#123; num: 1, num2: 1, num3: &quot;12&quot;, num4: 222, num5: &#123;&#125;, num6: 11 &#125;, components: &#123; &apos;prop-ver&apos;: propVer &#125; &#125;);&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"07-组件上","slug":"vue/07-组件上","permalink":"http://yoursite.com/categories/vue/07-组件上/"}],"tags":[]},{"title":"06-深入理解- version1","slug":"vue/06-响应原理和过渡/06-vuePro3","date":"2018-05-10T01:32:34.992Z","updated":"2018-05-10T02:20:50.202Z","comments":true,"path":"2018/05/10/vue/06-响应原理和过渡/06-vuePro3/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/06-响应原理和过渡/06-vuePro3/","excerpt":"","text":"迭代3 Vue深入理解 在这一块,我们先讲解数据的响应式的原理,之后会讲解一些vue中过渡(动画)效果的使用 数据响应原理-大致可以分成四个阶段 也就是说,vue的核心特性:双向的数据绑定是如何实现的? js对象转化成vue数据模型 将普通的js对象传给Vue的data选项,并遍历此对象的所有属性,也就是刚开始创建Vue对象 在这一步 完成js对象到vue的数据模型的转化,在转化之后,在数据模型这个对象中会多出get和set两个方法 new Vue(),生命周期的开始阶段 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;input type=&quot;text&quot; v-model=&apos;age&apos; /&gt; &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; age: &apos;1&apos; &#125; //在数据挂载到vm对象上的时候,将普通的js对象转化为vue对象(data属性) var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; 自定义属性转化getter和setter 使用 Object.defineProperty将这些属性(data中的内容)全部转化为getter和setter 自定义对象的属性 Object.defineProperty是ES5中的内容,这也是vue不支持IE9以下版本的原因 在这里对 Object.defineProperty作一下简单的回顾 简单版本: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;input type=&quot;text&quot; v-model=&apos;name&apos; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; name: &apos;1&apos; &#125; //1. 在数据挂载到vm对象上的时候,讲普通的js对象转化为vue对象(data属性)----多了两个方法,get和set var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;) //2. get和set是干什么的? var obj = &#123;&#125;; (function() &#123; Object.defineProperty(obj, &quot;age&quot;, &#123; //给age设置值的时候回自动调用这个方法 set: function() &#123; console.log(&quot;set---设置值&quot;) &#125;, //获取age值的时候,会自动调用这个方法 get: function() &#123; console.log(&quot;get---获取值&quot;); &#125; &#125;); &#125;)() obj.age = 2; //_age:undefined----设置 console.log(obj.age); //0---------获取值&lt;/script&gt; 提升-可以设置并得到相应的内容 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; var obj = &#123;&#125;; (function() &#123; //定义一个变量提前保存设置的值 var _age; Object.defineProperty(obj, &quot;age&quot;, &#123; set: function(value) &#123; _age = value; &#125;, get: function() &#123; //当_age的值为空的时候,给其一个默认的值 return _age === undefined ? 0 : _age; &#125; &#125;); &#125;)() obj.age = 2; //_age:undefined console.log(obj.age); //2 &lt;/script&gt;&lt;/html&gt; 监测数据的变化 watchers 之前我们在计算属性中提到过,通过实例的watch可以监测data属性中数据的变化,在这里使用的就是这一特性 当监测到数据发生变动时,进行组件上数据的更新 在这里,我们再回顾一下之前的例子 数据的变化会自动监测并渲染 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt; &lt;input v-model=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; name: &apos;&apos;, answer: &apos;数据没有变化&apos; &#125; var watchExampleVM = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, watch: &#123; // 如果 question 发生改变，这个函数就会运行 name: function() &#123; this.answer = Math.random() &#125; &#125; &#125;)&lt;/script&gt; 重新渲染虚拟dom树 在第三阶段,完成数据变化监测并更新数据后,会将数据的变动重新渲染到虚拟dom树上 由此四步完成一个循环的过程,只要是数据发生变化,就会自动监测到并渲染 重新渲染DOM树 响应式原理中存在的问题(了解)变化监测问题 之前也给大家演示过,通过普通的方式为已有的实例添加/删除对象属性是存在一些问题的 受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除 由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 我们可以使用Vue.set(object, key, value)或者是this.$set(this.someObject,’b’,2)添加响应式属性 推荐在初始化数据的时候再data对象中声明所有的响应式属性 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;ul&gt; &lt;li v-for=&apos;item in arr&apos;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; arr : [1,2,3] &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;) //读取值 console.log(vm.arr) console.log(vm.$data.arr) //设置值----存在的问题,当数组里面的值使用下标的形式修改的时候,视图和模型数据不会动态更新 vm.arr[0]=4; //使用set方法设置的值,可以动态更新到模型数据和视图上 Vue.set(vm.arr,0,100) //使用vue的实例暴露出来的属性和方法进行操作 vm.$set(vm.arr,1,200)&lt;/script&gt; 异步更新队列(了解) 之前给大家讲解过,计算属性computed,使用计算属性存在的一个优点就是不像传统的方式那样,每执行一次,都会重新执行相关的代码, 在vue中,计算属性做了一个缓存机制,当依赖关系不发生变化时,直接使用缓存的结果,而不是调用getter 这个可以看成是异步更新队列的一个应用 12345678910可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = &apos;new value&apos; ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用 过渡效果简介-old在vue2.0之后,过渡这一部分的内容变动比较大,这一部分的内容暂时作为参考资料 我们在前面的css和js中学习过动画和过渡的相关知识,同样的,在vue中也给我们提供了这样的特性 它能够在元素从dom中绑定或移除的时候出发过渡和动画 也就是说在dom元素发生变化的时候为其添加特定的class,从而产生过渡效果 同样的,vue.js也支持js的过渡,通过暴露出的过渡系统的钩子函数,我们在dom变化 的特定时期对其进行属性的操作,从而产生动画 总之,过渡效果包括css和js两个方面的内容 基本的vue模板 mvvm设计模式 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--1. 视图--&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //2. 数据模型 var dataModel = &#123; message:&quot;hello Vue!&quot; &#125; //3. 实现视图和数据模型的关联 var vm = new Vue(&#123; el:&quot;#app&quot;, data:dataModel &#125;)&lt;/script&gt; Css过渡效果简介 在这里,我们想配合一个简单的例子来体验一下vue的过渡效果的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /*4. 添加过渡的相关的样式*/ /*1 先执行enter,时间特别短暂 再执行enter-active*/ .test-enter &#123; color: green; &#125; /*2*/ .test-enter-active &#123; transition: all 1s; color: red; &#125; /*元素 从页面移除*/ /*1*/ .test-leave &#123; opacity: 1; &#125; /*2*/ .test-leave-active &#123; opacity: 0; transition: all 1s linear; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;!--3. 定义一个按钮,点击的时候修改show的值,进行元素显示和隐藏(进入和离开)的切换--&gt; &lt;button v-on:click=&apos;show=!show&apos;&gt;点击按钮进行元素显示和隐藏的切换&lt;/button&gt; &lt;!-- 1. 定义过渡的组件 transition 所有需要过渡的元素都在其内部定义 给组件定义一个名称,后期用于类样式的添加 --&gt; &lt;transition name=&quot;test&quot;&gt; &lt;!-- 2. 咋transition内部定义过渡的内容 当元素进行显示/隐藏(进入/离开)切换的时候,会自动的添加以name名开头的类样式 --&gt; &lt;p v-show=&apos;show&apos;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var dataModel = &#123; message: &quot;hello Vue!&quot;, show: true &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: dataModel &#125;)&lt;/script&gt; 过渡的css类名 css过渡 也就是使用我们之前学过的css3里面的过渡特性的使用,不同的是设置类名的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /*4. 添加过渡的相关的样式*/ /*1 先执行enter,时间特别短暂 再执行enter-active*/ .test-enter &#123; color: green; &#125; /*2*/ .test-enter-active &#123; transition: all 1s; color: red; &#125; /*元素 从页面移除*/ /*1*/ .test-leave &#123; opacity: 1; &#125; /*2*/ .test-leave-active &#123; opacity: 0; transition: all 1s linear; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;!--3. 定义一个按钮,点击的时候修改show的值,进行元素显示和隐藏(进入和离开)的切换--&gt; &lt;button v-on:click=&apos;show=!show&apos;&gt;点击按钮进行元素显示和隐藏的切换&lt;/button&gt; &lt;!-- 1. 定义过渡的组件 transition 所有需要过渡的元素都在其内部定义 给组件定义一个名称,后期用于类样式的添加 --&gt; &lt;transition name=&quot;test&quot;&gt; &lt;!-- 2. 咋transition内部定义过渡的内容 当元素进行显示/隐藏(进入/离开)切换的时候,会自动的添加以name名开头的类样式 --&gt; &lt;p v-show=&apos;show&apos;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var dataModel = &#123; message: &quot;hello Vue!&quot;, show: true &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: dataModel &#125;)&lt;/script&gt; css动画 也就是使用我们之前学过的css3里面动画的特性的使用,不同的是设置类名的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /*4. 定义过渡的样式*/ .bounce-enter-active &#123; animation: bounce-in 1s; &#125; .bounce-leave-active &#123; animation: bounce-out 1s; &#125; @keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125; @keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-2&quot;&gt; &lt;!--3. 进行元素显示和隐藏的切换--&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;!--1. 定义过渡组件 添加名称(必须)--&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;!--2. 添加需要过渡的内容--&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125; &#125;)&lt;/script&gt; 自定义过渡属性类名 使用动画库 代码实现 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;点击按钮,进行元素显示和隐藏的切换&lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message:&quot;hello Vue!&quot;, show:true &#125; var vm = new Vue(&#123; el:&quot;#app&quot;, data:dataModel &#125;)&lt;/script&gt; 自定义过渡类名 使用自己定义的类样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .transition1 &#123; transition: all .3s ease; color: red; &#125; .transition2 &#123; transition: all .8s; transform: translateX(10px); opacity: 0.5; color: green; &#125; .transition3 &#123; transition: all .8s; transform: translateX(10px); opacity: 0.5; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle render&lt;/button&gt; &lt;transition name=&quot;&quot; enter-active-class=&quot;transition1&quot; leave-active-class=&quot;transition2&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &quot;hello Vue!&quot;, show: true &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: dataModel &#125;)&lt;/script&gt; 事件监听 动画结束事件 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .bounce-enter-active &#123; animation: bounce-in .5s infinite; &#125; .bounce-leave-active &#123; animation: bounce-out .5s; &#125; @keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125; @keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;// Vue.directive(&quot;&quot;,&#123;&#125;) new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125; &#125;) // 监听动画结束事件 document.getElementsByTagName(&apos;p&apos;)[0].addEventListener(&quot;animationend&quot;, function() &#123; console.log(1111); &#125;)&lt;/script&gt; 过渡结束事件 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--4. 样式添加--&gt; &lt;style type=&quot;text/css&quot;&gt; .slide-fade-enter-active &#123; transition: all .3s ease; color: red; &#125; .slide-fade-leave-active &#123; transition: all .8s; transform: translateX(10px); opacity: 0.5; color: green; &#125; .slide-fade-enter&#123; transform: translateX(10px); opacity: 0.5; color: green; &#125; .slide-fade-enter&#123; transform: translateX(10px); opacity: 0.5; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-1&quot;&gt; &lt;!--3. 点击进行切换--&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle render&lt;/button&gt; &lt;!--1 过渡组件 必须添加name属性--&gt; &lt;transition name=&quot;slide-fade&quot;&gt; &lt;!--2. 过渡的内容--&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; show: true &#125; &#125;)//监听过渡结束事件 document.getElementsByTagName(&apos;p&apos;)[0].addEventListener(&quot;transitionend&quot;, function() &#123; console.log(1111); &#125;)&lt;/script&gt; 过渡效果简介-new 我们在前面的css和js中学习过动画和过渡的相关知识,同样的,在vue中也给我们提供了这样的特性 它能够在元素从dom中绑定或移除的时候出发过渡和动画 也就是说在dom元素发生变化的时候为其添加特定的class,从而产生过渡效果 同样的,vue.js也支持js的过渡,通过暴露出的过渡系统的钩子函数,我们在dom变化 的特定时期对其进行属性的操作,从而产生动画 总之,过渡效果包括css和js两个方面的内容 基本的vue模板 mvvm设计模式 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--1. 视图--&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //2. 数据模型 var dataModel = &#123; message:&quot;hello Vue!&quot; &#125; //3. 实现视图和数据模型的关联 var vm = new Vue(&#123; el:&quot;#app&quot;, data:dataModel &#125;)&lt;/script&gt; Css过渡效果简介 在这里,我们想配合一个简单的例子来体验一下vue的过渡效果的实现 在代码的书写方面,可以参照以下思路 1234561. 过渡的内容 通过 &lt;transition&gt; &lt;/transition&gt; 定义,内容添加在这个标签内部2. 什么时候开始过渡 v-if v-show 显示隐藏切换的时候进行元素的过渡3. 过渡的样式 每一个样式需要给一个名称,也就是标识的名称 简单示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /*进入开始*/ .opacity-enter &#123; opacity: 0; color: red; &#125; /*进入过程中 经过 激活状态*/ .opacity-enter-active &#123; transition: all 2s; &#125; /*进入结束*/ .opacity-enter-to &#123; color: green; font-size: 100px; &#125; /*离开开始*/ .opacity-leave &#123; color: pink; &#125; /*离开中*/ .opacity-leave-active &#123; transition: all 2s; &#125; /*离开结束*/ .opacity-leave-to &#123; opacity: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;!--点击的时候进行true false 的切换--&gt; &lt;button v-on:click=&quot;bool = !bool&quot;&gt;点击按钮进行显示隐藏&lt;/button&gt; &lt;!--1.--&gt; &lt;transition name=&quot;opacity&quot;&gt; &lt;ul v-if=&quot;bool&quot;&gt; &lt;li&gt;这个ul参与过渡&lt;/li&gt; &lt;li&gt;这个ul参与过渡&lt;/li&gt; &lt;li&gt;这个ul参与过渡&lt;/li&gt; &lt;/ul&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var dataModel = &#123; message: &quot;hello Vue!&quot;, bool: true &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: dataModel &#125;)&lt;/script&gt; 过渡的css类名 css过渡 也就是使用我们之前学过的css3里面的过渡特性的使用,不同的是设置类名的方式 代码的实现可以参考上面的例子 css动画 也就是使用我们之前学过的css3里面动画的特性的使用,不同的是设置类名的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /*4. 定义过渡的样式*/ .bounce-enter-active &#123; animation: bounce-in 1s; &#125; .bounce-leave-active &#123; animation: bounce-out 1s; &#125; @keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125; @keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-2&quot;&gt; &lt;!--3. 进行元素显示和隐藏的切换--&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;!--1. 定义过渡组件 添加名称(必须)--&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;!--2. 添加需要过渡的内容--&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125; &#125;)&lt;/script&gt; 自定义过渡属性类名 使用动画库 代码实现 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;点击按钮,进行元素显示和隐藏的切换&lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message:&quot;hello Vue!&quot;, show:true &#125; var vm = new Vue(&#123; el:&quot;#app&quot;, data:dataModel &#125;)&lt;/script&gt; 自定义过渡类名 使用自己定义的类样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .transition1 &#123; transition: all .3s ease; color: red; &#125; .transition2 &#123; transition: all .8s; transform: translateX(10px); opacity: 0.5; color: green; &#125; .transition3 &#123; transition: all .8s; transform: translateX(10px); opacity: 0.5; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle render&lt;/button&gt; &lt;transition name=&quot;&quot; enter-active-class=&quot;transition1&quot; leave-active-class=&quot;transition2&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &quot;hello Vue!&quot;, show: true &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: dataModel &#125;)&lt;/script&gt; 事件监听 动画结束事件 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .bounce-enter-active &#123; animation: bounce-in .5s infinite; &#125; .bounce-leave-active &#123; animation: bounce-out .5s; &#125; @keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125; @keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;// Vue.directive(&quot;&quot;,&#123;&#125;) new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125; &#125;) // 监听动画结束事件 document.getElementsByTagName(&apos;p&apos;)[0].addEventListener(&quot;animationend&quot;, function() &#123; console.log(1111); &#125;)&lt;/script&gt; 过渡结束事件 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--4. 样式添加--&gt; &lt;style type=&quot;text/css&quot;&gt; .slide-fade-enter-active &#123; transition: all .3s ease; color: red; &#125; .slide-fade-leave-active &#123; transition: all .8s; transform: translateX(10px); opacity: 0.5; color: green; &#125; .slide-fade-enter&#123; transform: translateX(10px); opacity: 0.5; color: green; &#125; .slide-fade-enter&#123; transform: translateX(10px); opacity: 0.5; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-1&quot;&gt; &lt;!--3. 点击进行切换--&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle render&lt;/button&gt; &lt;!--1 过渡组件 必须添加name属性--&gt; &lt;transition name=&quot;slide-fade&quot;&gt; &lt;!--2. 过渡的内容--&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; show: true &#125; &#125;)//监听过渡结束事件 document.getElementsByTagName(&apos;p&apos;)[0].addEventListener(&quot;transitionend&quot;, function() &#123; console.log(1111); &#125;)&lt;/script&gt; 补充 除此之外,在过渡部分还有一些其他的知识点 1234567891. 过渡的钩子函数2. 组件的过渡 3. 双元素过渡4. 多组件过渡5. 过渡状态......... 这些相关的知识点可以参考官方文档进行深入学习","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"06-响应原理和过渡","slug":"vue/06-响应原理和过渡","permalink":"http://yoursite.com/categories/vue/06-响应原理和过渡/"}],"tags":[]},{"title":"06-深入理解- version1","slug":"vue/06-响应原理和过渡/06-vuePro2-内容完整版","date":"2018-05-10T01:32:34.957Z","updated":"2018-05-10T02:20:46.598Z","comments":true,"path":"2018/05/10/vue/06-响应原理和过渡/06-vuePro2-内容完整版/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/06-响应原理和过渡/06-vuePro2-内容完整版/","excerpt":"","text":"第六部分 – 迭代2 在这一块,我们先讲解数据的响应式的原理,之后会讲解一些vue中过渡(动画)效果的使用 数据响应原理-大致可以分成四个阶段 也就是说,vue的核心特性:双向的数据绑定是如何实现的? js对象转化成vue数据模型 将普通的js对象传给Vue的data选项,并遍历此对象的所有属性,也就是刚开始创建Vue对象 new Vue(),生命周期的开始阶段 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;input type=&quot;text&quot; v-model=&apos;age&apos; /&gt; &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; age: &apos;1&apos; &#125; //在数据挂载到vm对象上的时候,讲普通的js对象转化为vue对象(data属性) var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; 自定义属性转化getter和setter 使用 Object.defineProperty将这些属性(data中的内容)全部转化为getter和setter 自定义对象的属性 Object.defineProperty是ES5中的内容,这也是vue不支持IE9以下版本的原因 在这里对 Object.defineProperty作一下简单的回顾 简单版本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;!--&lt;input type=&quot;text&quot; v-model=&apos;age&apos; /&gt;--&gt; &lt;!--&lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;--&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; age: &apos;1&apos; &#125;; //在数据挂载到vm对象上的时候,讲普通的js对象转化为vue对象(data属性) //var vm= new Vue(&#123; // el:&apos;#app&apos;, // data:dataModel //&#125;) //限定了obj对象的age属性的值的范围：0-200之间 (function()&#123; Object.defineProperty(dataModel,&quot;age&quot;,&#123; set:function()&#123; console.log(&quot;set&quot;) &#125;, get:function()&#123; //return _age===undefined?0:_age; console.log(&quot;get&quot;) return &quot;get&quot; &#125; &#125;); &#125;)() dataModel.age = 2; //_age:undefined console.log(dataModel.age); //0&lt;/script&gt; 复杂版本: 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; var obj=&#123; &#125;; //限定了obj对象的age属性的值的范围：0-200之间 (function()&#123; var _age; Object.defineProperty(obj,&quot;age&quot;,&#123; set:function(value)&#123; if(value&gt;=0 &amp;&amp; value&lt;=200)&#123; _age=value; &#125; &#125;, get:function()&#123; return _age===undefined?0:_age; &#125; &#125;); &#125;)() obj.age=2;//_age:undefined console.log(obj.age);//0 obj.age=10;//_age:10 console.log(obj.age);//10&lt;/script&gt;&lt;/html&gt; 监测数据的变化 watchers 之前我们在计算属性中提到过,通过实例的watch可以监测data属性中数据的变化,在这里使用的就是这一特性 当监测到数据发生变动时,进行组件上数据的更新 在这里,我们再回顾一下之前的例子 数据的变化会自动监测并渲染 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt; &lt;input v-model=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; name: &apos;&apos;, answer: &apos;数据没有变化&apos; &#125; var watchExampleVM = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, watch: &#123; // 如果 question 发生改变，这个函数就会运行 name: function() &#123; this.answer = Math.random() &#125; &#125; &#125;)&lt;/script&gt; 重新渲染虚拟dom树 在第三阶段,完成数据变化监测并更新数据后,会将数据的变动重新渲染到虚拟dom树上 由此四步完成一个循环的过程,只要是数据发生变化,就会自动监测到并渲染 响应式原理中存在的问题变化监测问题 之前也给大家演示过,通过普通的方式为已有的实例添加/删除对象属性是存在一些问题的 受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除 由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 我们可以使用Vue.set(object, key, value)或者是this.$set(this.someObject,’b’,2)添加响应式属性 推荐在初始化数据的时候再data对象中声明所有的响应式属性 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;ul&gt; &lt;li v-for=&apos;item in arr&apos;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; arr : [1,2,3] &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;) //读取值 console.log(vm.arr) console.log(vm.$data.arr) //设置值----存在的问题,当数组里面的值使用下标的形式修改的时候,视图和模型数据不会动态更新 vm.arr[0]=4; //使用set方法设置的值,可以动态更新到模型数据和视图上 Vue.set(vm.arr,0,100) //使用vue的实例暴露出来的属性和方法进行操作 vm.$set(vm.arr,1,200)&lt;/script&gt; 异步更新队列(了解) 之前给大家讲解过,计算属性computed,使用计算属性存在的一个优点就是不像传统的方式那样,每执行一次,都会重新执行相关的代码, 在vue中,计算属性做了一个缓存机制,当依赖关系不发生变化时,直接使用缓存的结果,而不是调用getter 这个可以看成是异步更新队列的一个应用 12345678910可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = &apos;new value&apos; ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用 过渡效果简介 我们在前面的css和js中学习过动画和过渡的相关知识,同样的,在vue中也给我们提供了这样的特性 它能够在元素从dom中绑定或移除的时候出发过渡和动画 也就是说在dom元素发生变化的时候为其添加特定的class,从而产生过渡效果 同样的,vue.js也支持js的过渡,通过宝露出过渡系统的钩子函数,我们在dom变化 的特定时期对其进行属性的操作,从而产生动画 总之,过渡效果包括css和js两个方面的内容 Css过渡效果 在这里,我们想配合一个简单的例子来体验一下vue的过渡效果的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .fade-enter &#123; opacity: 0 &#125; .fade-enter-active &#123; transition: opacity .5s &#125; .fade-leave-active &#123; opacity: 0; font-size: 30px; transition: all .5s; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;!--点击按钮,切换show的值--&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt;Toggle&lt;/button&gt; &lt;!--定义过渡的名称--&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#demo&apos;, data: &#123; show: true &#125; &#125;)&lt;/script&gt; 过渡的css类名 css过渡 也就是使用我们之前学过的css3里面的过渡特性的使用,不同的是设置类名的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .slide-fade-enter-active &#123; transition: all .3s ease; color: red; &#125; .slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0); &#125; .slide-fade-enter, .slide-fade-leave-active &#123; transform: translateX(10px); opacity: 0.5; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-1&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle render&lt;/button&gt; &lt;transition name=&quot;slide-fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; show: true &#125; &#125;)&lt;/script&gt; css动画 也就是使用我们之前学过的css3里面动画的特性的使用,不同的是设置类名的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .bounce-enter-active &#123; animation: bounce-in .5s; &#125; .bounce-leave-active &#123; animation: bounce-out .5s; &#125; @keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125; @keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125; &#125;)&lt;/script&gt; 自定义过渡属性类名 事件监听 JS过渡 类似于我们之前学过的js的过渡,通过js操作实现过渡 钩子函数 和我们之前讲解过的vue的生命周期钩子差不多,在过渡的各个阶段调用 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用 配合使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle render&lt;/button&gt; &lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot; name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; show: &apos;hello world!&apos; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, methods: &#123; // -------- // 进入中 // -------- beforeEnter: function(el) &#123; console.log(&apos;beforeEnter&apos;) &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function(el, done) &#123; console.log(&apos;enter&apos;) done() &#125;, afterEnter: function(el) &#123; console.log(&apos;afterEnter&apos;) &#125;, enterCancelled: function(el) &#123; console.log(&apos;enterCancelled&apos;) &#125;, // -------- // 离开时 // -------- beforeLeave: function(el) &#123; console.log(&apos;beforeLeave&apos;) &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function(el, done) &#123; console.log(&apos;leave&apos;) done() &#125;, afterLeave: function(el) &#123; console.log(&apos;afterLeave&apos;) &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function(el) &#123; console.log(&apos;leaveCancelled&apos;) &#125; &#125; &#125;)&lt;/script&gt; 单独使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;!--使用Velocity.js这个动画库--&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-4&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot; v-bind:css=&quot;false&quot;&gt; &lt;p v-if=&quot;show&quot;&gt; Demo &lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#example-4&apos;, data: &#123; show: false &#125;, methods: &#123; beforeEnter: function(el) &#123; el.style.opacity = 0 el.style.transformOrigin = &apos;left&apos; &#125;, enter: function(el, done) &#123; Velocity(el, &#123; opacity: 1, fontSize: &apos;1.4em&apos; &#125;, &#123; duration: 300 &#125;) Velocity(el, &#123; fontSize: &apos;1em&apos; &#125;, &#123; complete: done &#125;) &#125;, leave: function(el, done) &#123; Velocity(el, &#123; translateX: &apos;15px&apos;, rotateZ: &apos;50deg&apos; &#125;, &#123; duration: 600 &#125;) Velocity(el, &#123; rotateZ: &apos;100deg&apos; &#125;, &#123; loop: 2 &#125;) Velocity(el, &#123; rotateZ: &apos;45deg&apos;, translateY: &apos;30px&apos;, translateX: &apos;30px&apos;, opacity: 0 &#125;, &#123; complete: done &#125;) &#125; &#125; &#125;)&lt;/script&gt; 初始化渲染 可以通过appear设置初始化渲染的过渡,包括初始化渲染的过渡样式,初始化渲染钩子 初始化渲染的过渡 初始化渲染钩子 也就是初始化渲染appear的声明周期函数 知识点有待补充 这部分知识点可以对照自定义过渡类名和js钩子来学习 多个元素的过渡 知识点有待补充 存在的问题 显示效果的差异 过渡模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .slide-fade-enter-active &#123; transition: all .3s ease; color: red; &#125; .slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0); &#125; .slide-fade-enter, .slide-fade-leave-active &#123; opacity: 0.5; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show=!show&quot;&gt;toggle&lt;/button&gt; &lt;div id=&quot;transition&quot;&gt; &lt;!--设置过渡模式--&gt; &lt;transition name=&apos;slide-fade&apos; mode=&apos;out-in&apos;&gt; &lt;span v-if=&apos;show&apos; key=&apos;if&apos;&gt;p1&lt;/span&gt; &lt;span v-else key=&apos;else&apos;&gt;p2&lt;/span&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#demo&apos;, data: &#123; show: true &#125; &#125;)&lt;/script&gt; 多个组件的过渡 多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease; &#125; .component-fade-enter, .component-fade-leave-active &#123; opacity: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;demo&quot;&gt; A:&lt;input type=&quot;radio&quot; name=&quot;sele&quot; v-model=&quot;view&quot; value=&quot;v-a&quot;/&gt; B:&lt;input type=&quot;radio&quot; name=&quot;sele&quot; v-model=&quot;view&quot; value=&quot;v-b&quot;/&gt; &lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#demo&apos;, data: &#123; view: &apos;v-a&apos; &#125;, components: &#123; &apos;v-a&apos;: &#123; template: &apos;&lt;div&gt;Component A&lt;/div&gt;&apos; &#125;, &apos;v-b&apos;: &#123; template: &apos;&lt;div&gt;Component B&lt;/div&gt;&apos; &#125; &#125; &#125;)&lt;/script&gt; 列表过渡 使用v-for进行列表的渲染 列表渲染的都是相同的标签,会存在一些问题,之前已经提到过,我们可以给每一个标签设置一个键值 key 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--js插件--&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .flip-list-move &#123; transition: transform 1s; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;flip-list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;shuffle&quot;&gt;Shuffle&lt;/button&gt; &lt;transition-group name=&quot;flip-list&quot; tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &apos;#flip-list-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9] &#125;, methods: &#123; shuffle: function() &#123; this.items = _.shuffle(this.items) &#125; &#125; &#125;)&lt;/script&gt; 列表渲染之进入和离开过渡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .list-item &#123; display: inline-block; margin-right: 10px; &#125; .list-enter-active, .list-leave-active &#123; transition: all 1s; &#125; .list-enter, .list-leave-active &#123; opacity: 0; transform: translateY(30px); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt; &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &apos;#list-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9], nextNum: 10 &#125;, methods: &#123; randomIndex: function() &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function() &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function() &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125; &#125;)&lt;/script&gt; 存在的问题:当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡 列表渲染之位移过渡1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--js插件--&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .flip-list-move &#123; transition: transform 1s; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;flip-list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;shuffle&quot;&gt;Shuffle&lt;/button&gt; &lt;transition-group name=&quot;flip-list&quot; tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &apos;#flip-list-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9] &#125;, methods: &#123; shuffle: function() &#123; this.items = _.shuffle(this.items) &#125; &#125; &#125;)&lt;/script&gt; 这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。 完善版本的列表过渡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--js插件--&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .list-complete-item &#123; transition: all 1s; display: inline-block; margin-right: 10px; &#125; /* * * 需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。 * * 作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中 * * */ .list-complete-enter, .list-complete-leave-active &#123; opacity: 0; transform: translateY(30px); &#125; .list-complete-leave-active &#123; position: absolute; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;list-complete-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;shuffle&quot;&gt;Shuffle&lt;/button&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt; &lt;transition-group name=&quot;list-complete&quot; tag=&quot;p&quot;&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-complete-item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &apos;#list-complete-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9], nextNum: 10 &#125;, methods: &#123; randomIndex: function() &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function() &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function() &#123; this.items.splice(this.randomIndex(), 1) &#125;, shuffle: function() &#123; this.items = _.shuffle(this.items) &#125; &#125; &#125;)&lt;/script&gt; 多维网格12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--js插件--&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .container &#123; display: flex; flex-wrap: wrap; width: 238px; margin-top: 10px; &#125; .cell &#123; display: flex; justify-content: space-around; align-items: center; width: 25px; height: 25px; border: 1px solid #aaa; margin-right: -1px; margin-bottom: -1px; &#125; .cell:nth-child(3n) &#123; margin-right: 0; &#125; .cell:nth-child(27n) &#123; margin-bottom: 0; &#125; .cell-move &#123; transition: transform 1s; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sudoku-demo&quot; class=&quot;demo&quot;&gt; &lt;h1&gt;Lazy Sudoku&lt;/h1&gt; &lt;p&gt;Keep hitting the shuffle button until you win.&lt;/p&gt; &lt;button @click=&quot;shuffle&quot;&gt;Shuffle&lt;/button&gt; &lt;transition-group name=&quot;cell&quot; tag=&quot;div&quot; class=&quot;container&quot;&gt; &lt;div v-for=&quot;cell in cells&quot; :key=&quot;cell.id&quot; class=&quot;cell&quot;&gt; &#123;&#123; cell.number &#125;&#125; &lt;/div&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &apos;#sudoku-demo&apos;, data: &#123; cells: Array.apply(null, &#123; length: 81 &#125;) .map(function(_, index) &#123; return &#123; id: index, number: index % 9 + 1 &#125; &#125;) &#125;, methods: &#123; shuffle: function() &#123; this.cells = _.shuffle(this.cells) &#125; &#125; &#125;)&lt;/script&gt; 列表的渐进过渡 通过 data 属性与 JavaScript 通信 ，就可以实现列表的渐进过渡： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--js插件--&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .container &#123; display: flex; flex-wrap: wrap; width: 238px; margin-top: 10px; &#125; .cell &#123; display: flex; justify-content: space-around; align-items: center; width: 25px; height: 25px; border: 1px solid #aaa; margin-right: -1px; margin-bottom: -1px; &#125; .cell:nth-child(3n) &#123; margin-right: 0; &#125; .cell:nth-child(27n) &#123; margin-bottom: 0; &#125; .cell-move &#123; transition: transform 1s; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;div id=&quot;staggered-list-demo&quot;&gt; &lt;input v-model=&quot;query&quot;&gt; &lt;transition-group name=&quot;staggered-fade&quot; tag=&quot;ul&quot; v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot; &gt; &lt;li v-for=&quot;(item, index) in computedList&quot; v-bind:key=&quot;item.msg&quot; v-bind:data-index=&quot;index&quot; &gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;new Vue(&#123; el: &apos;#staggered-list-demo&apos;, data: &#123; query: &apos;&apos;, list: [ &#123; msg: &apos;Bruce Lee&apos; &#125;, &#123; msg: &apos;Jackie Chan&apos; &#125;, &#123; msg: &apos;Chuck Norris&apos; &#125;, &#123; msg: &apos;Jet Li&apos; &#125;, &#123; msg: &apos;Kung Fury&apos; &#125; ] &#125;, computed: &#123; computedList: function () &#123; var vm = this return this.list.filter(function (item) &#123; return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 &#125;) &#125; &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 el.style.height = 0 &#125;, enter: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 1, height: &apos;1.6em&apos; &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125;, leave: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 0, height: 0 &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125; &#125;&#125;)&lt;/script&gt; 可复用的过渡(了解) 通过vue的组件实现复用的过渡 将 或者 作为根组件，然后将任何子组件放置在其中就可以了。 动态过渡(了解) 在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 name 特性来绑定动态值。 当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用。 所有的过渡特性都是动态绑定。它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。 最后，创建动态过渡的最终方案是组件通过接受 props 来动态修改之前的过渡。一句老话，唯一的限制是你的想象力。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--js插件--&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;dynamic-fade-demo&quot;&gt; Fade In: &lt;input type=&quot;range&quot; v-model=&quot;fadeInDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; Fade Out: &lt;input type=&quot;range&quot; v-model=&quot;fadeOutDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; &lt;transition v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;button v-on:click=&quot;stop = true&quot;&gt;Stop it!&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &apos;#dynamic-fade-demo&apos;, data: &#123; show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: false &#125;, mounted: function() &#123; this.show = false &#125;, methods: &#123; beforeEnter: function(el) &#123; el.style.opacity = 0 &#125;, enter: function(el, done) &#123; var vm = this Velocity(el, &#123; opacity: 1 &#125;, &#123; duration: this.fadeInDuration, complete: function() &#123; done() if(!vm.stop) vm.show = false &#125; &#125;) &#125;, leave: function(el, done) &#123; var vm = this Velocity(el, &#123; opacity: 0 &#125;, &#123; duration: this.fadeOutDuration, complete: function() &#123; done() vm.show = true &#125; &#125;) &#125; &#125; &#125;)&lt;/script&gt; 过渡状态12345678Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如： 数字和运算 颜色的显示 sVG 节点的位置 元素的大小和其他的属性 所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。 状态动画和watcher–number 通过 watcher 我们能监听到任何数值属性的数值更新。可能听起来很抽象，所以让我们先来看看使用Tweenjs一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/tween.js@16.3.4&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;animated-number-demo&quot;&gt; &lt;input v-model.number=&quot;number&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--更新数值,触发动画--&gt;&lt;script&gt; new Vue(&#123; el: &apos;#animated-number-demo&apos;, data: &#123; number: 0, animatedNumber: 0 &#125;, watch: &#123; number: function(newValue, oldValue) &#123; var vm = this function animate(time) &#123; requestAnimationFrame(animate) TWEEN.update(time) &#125; new TWEEN.Tween(&#123; tweeningNumber: oldValue &#125;) .easing(TWEEN.Easing.Quadratic.Out) .to(&#123; tweeningNumber: newValue &#125;, 500) .onUpdate(function() &#123; vm.animatedNumber = this.tweeningNumber.toFixed(0) &#125;) .start() animate() &#125; &#125; &#125;)&lt;/script&gt; 状态动画和watcher–color 当你把数值更新时，就会触发动画。这个是一个不错的演示，但是对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 Color.js 实现一个例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/tween.js@16.3.4&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/color-js@1.0.3/color.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .example-7-color-preview &#123; display: inline-block; width: 50px; height: 50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-7&quot;&gt; &lt;input v-model=&quot;colorQuery&quot; v-on:keyup.enter=&quot;updateColor&quot; placeholder=&quot;Enter a color&quot;&gt; &lt;button v-on:click=&quot;updateColor&quot;&gt;Update&lt;/button&gt; &lt;p&gt;Preview:&lt;/p&gt; &lt;span v-bind:style=&quot;&#123; backgroundColor: tweenedCSSColor &#125;&quot; class=&quot;example-7-color-preview&quot;&gt;&lt;/span&gt; &lt;p&gt;&#123;&#123; tweenedCSSColor &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--更新颜色,触发动画--&gt;&lt;script&gt; var Color = net.brehaut.Color new Vue(&#123; el: &apos;#example-7&apos;, data: &#123; colorQuery: &apos;&apos;, color: &#123; red: 0, green: 0, blue: 0, alpha: 1 &#125;, tweenedColor: &#123;&#125; &#125;, created: function() &#123; this.tweenedColor = Object.assign(&#123;&#125;, this.color) &#125;, watch: &#123; color: function() &#123; function animate(time) &#123; requestAnimationFrame(animate) TWEEN.update(time) &#125; new TWEEN.Tween(this.tweenedColor) .to(this.color, 750) .start() animate() &#125; &#125;, computed: &#123; tweenedCSSColor: function() &#123; return new Color(&#123; red: this.tweenedColor.red, green: this.tweenedColor.green, blue: this.tweenedColor.blue, alpha: this.tweenedColor.alpha &#125;).toCSS() &#125; &#125;, methods: &#123; updateColor: function() &#123; this.color = new Color(this.colorQuery).toRGB() this.colorQuery = &apos;&apos; &#125; &#125; &#125;)&lt;/script&gt; 动态状态转化 就像 Vue 的过渡组件一样，数据背后状态转换会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可是实现很多难以想象的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenLite.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdnjs.cloudflare.com/ajax/libs/gsap/latest/plugins/CSSPlugin.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; svg &#123; display: block; &#125; polygon &#123; fill: #41B883; &#125; circle &#123; fill: transparent; stroke: #35495E; &#125; input[type=&quot;range&quot;] &#123; display: block; width: 100%; margin-bottom: 15px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;svg width=&quot;200&quot; height=&quot;200&quot;&gt; &lt;polygon :points=&quot;points&quot;&gt;&lt;/polygon&gt; &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;90&quot;&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;label&gt;Sides: &#123;&#123; sides &#125;&#125;&lt;/label&gt; &lt;input type=&quot;range&quot; min=&quot;3&quot; max=&quot;500&quot; v-model.number=&quot;sides&quot;&gt; &lt;label&gt;Minimum Radius: &#123;&#123; minRadius &#125;&#125;%&lt;/label&gt; &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;90&quot; v-model.number=&quot;minRadius&quot;&gt; &lt;label&gt;Update Interval: &#123;&#123; updateInterval &#125;&#125; milliseconds&lt;/label&gt; &lt;input type=&quot;range&quot; min=&quot;10&quot; max=&quot;2000&quot; v-model.number=&quot;updateInterval&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#app&apos;, data: function() &#123; var defaultSides = 10 var stats = Array.apply(null, &#123; length: defaultSides &#125;) .map(function() &#123; return 100 &#125;) return &#123; stats: stats, points: generatePoints(stats), sides: defaultSides, minRadius: 50, interval: null, updateInterval: 500 &#125; &#125;, watch: &#123; sides: function(newSides, oldSides) &#123; var sidesDifference = newSides - oldSides if(sidesDifference &gt; 0) &#123; for(var i = 1; i &lt;= sidesDifference; i++) &#123; this.stats.push(this.newRandomValue()) &#125; &#125; else &#123; var absoluteSidesDifference = Math.abs(sidesDifference) for(var i = 1; i &lt;= absoluteSidesDifference; i++) &#123; this.stats.shift() &#125; &#125; &#125;, stats: function(newStats) &#123; TweenLite.to( this.$data, this.updateInterval / 1000, &#123; points: generatePoints(newStats) &#125; ) &#125;, updateInterval: function() &#123; this.resetInterval() &#125; &#125;, mounted: function() &#123; this.resetInterval() &#125;, methods: &#123; randomizeStats: function() &#123; var vm = this this.stats = this.stats.map(function() &#123; return vm.newRandomValue() &#125;) &#125;, newRandomValue: function() &#123; return Math.ceil(this.minRadius + Math.random() * (100 - this.minRadius)) &#125;, resetInterval: function() &#123; var vm = this clearInterval(this.interval) this.randomizeStats() this.interval = setInterval(function() &#123; vm.randomizeStats() &#125;, this.updateInterval) &#125; &#125; &#125;) function valueToPoint(value, index, total) &#123; var x = 0 var y = -value * 0.9 var angle = Math.PI * 2 / total * index var cos = Math.cos(angle) var sin = Math.sin(angle) var tx = x * cos - y * sin + 100 var ty = x * sin + y * cos + 100 return &#123; x: tx, y: ty &#125; &#125; function generatePoints(stats) &#123; var total = stats.length return stats.map(function(stat, index) &#123; var point = valueToPoint(stat, index, total) return point.x + &apos;,&apos; + point.y &#125;).join(&apos; &apos;) &#125;&lt;/script&gt; 通过组件组织过渡 管理太多的状态转换会很快的增加 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。我们来将之前的示例改写一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenLite.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdnjs.cloudflare.com/ajax/libs/gsap/latest/plugins/CSSPlugin.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/tween.js@16.3.4&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; svg &#123; display: block; &#125; polygon &#123; fill: #41B883; &#125; circle &#123; fill: transparent; stroke: #35495E; &#125; input[type=&quot;range&quot;] &#123; display: block; width: 100%; margin-bottom: 15px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;!-- 就像 Vue 的过渡组件一样，数据背后状态转换会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可是实现很多难以想象的效果。 --&gt; &lt;body&gt; &lt;div id=&quot;example-8&quot;&gt; &lt;input v-model.number=&quot;firstNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; + &lt;input v-model.number=&quot;secondNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; = &#123;&#123; result &#125;&#125; &lt;p&gt; &lt;animated-integer v-bind:value=&quot;firstNumber&quot;&gt;&lt;/animated-integer&gt; + &lt;animated-integer v-bind:value=&quot;secondNumber&quot;&gt;&lt;/animated-integer&gt; = &lt;animated-integer v-bind:value=&quot;result&quot;&gt;&lt;/animated-integer&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; // 这种复杂的补间动画逻辑可以被复用 // 任何整数都可以执行动画 // 组件化使我们的界面十分清晰 // 可以支持更多更复杂的动态过渡 // strategies. Vue.component(&apos;animated-integer&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;&apos;, props: &#123; value: &#123; type: Number, required: true &#125; &#125;, data: function() &#123; return &#123; tweeningValue: 0 &#125; &#125;, watch: &#123; value: function(newValue, oldValue) &#123; this.tween(oldValue, newValue) &#125; &#125;, mounted: function() &#123; this.tween(0, this.value) &#125;, methods: &#123; tween: function(startValue, endValue) &#123; var vm = this function animate(time) &#123; requestAnimationFrame(animate) TWEEN.update(time) &#125; new TWEEN.Tween(&#123; tweeningValue: startValue &#125;) .to(&#123; tweeningValue: endValue &#125;, 500) .onUpdate(function() &#123; vm.tweeningValue = this.tweeningValue.toFixed(0) &#125;) .start() animate() &#125; &#125; &#125;) // All complexity has now been removed from the main Vue instance! new Vue(&#123; el: &apos;#example-8&apos;, data: &#123; firstNumber: 20, secondNumber: 40 &#125;, computed: &#123; result: function() &#123; return this.firstNumber + this.secondNumber &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"06-响应原理和过渡","slug":"vue/06-响应原理和过渡","permalink":"http://yoursite.com/categories/vue/06-响应原理和过渡/"}],"tags":[]},{"title":"06-深入理解- version1","slug":"vue/06-响应原理和过渡/06-vuePro1","date":"2018-05-10T01:32:34.956Z","updated":"2018-05-10T02:20:41.654Z","comments":true,"path":"2018/05/10/vue/06-响应原理和过渡/06-vuePro1/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/06-响应原理和过渡/06-vuePro1/","excerpt":"","text":"第六部分 vue深入理解迭代1 Vue深入理解 在这一块,我们先讲解数据的响应式的原理,之后会讲解一些vue中过渡(动画)效果的使用 数据响应原理-大致可以分成四个阶段 也就是说,vue的核心特性:双向的数据绑定是如何实现的? js对象转化成vue数据模型 将普通的js对象传给Vue的data选项,并遍历此对象的所有属性,也就是刚开始创建Vue对象 在这一步 完成js对象到vue的数据模型的转化,在转化之后,在数据模型这个对象中会多出get和set两个方法 new Vue(),生命周期的开始阶段 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;input type=&quot;text&quot; v-model=&apos;age&apos; /&gt; &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; age: &apos;1&apos; &#125; //在数据挂载到vm对象上的时候,将普通的js对象转化为vue对象(data属性) var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; 自定义属性转化getter和setter 使用 Object.defineProperty将这些属性(data中的内容)全部转化为getter和setter 自定义对象的属性 Object.defineProperty是ES5中的内容,这也是vue不支持IE9以下版本的原因 在这里对 Object.defineProperty作一下简单的回顾 简单版本: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;input type=&quot;text&quot; v-model=&apos;name&apos; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; name: &apos;1&apos; &#125; //1. 在数据挂载到vm对象上的时候,讲普通的js对象转化为vue对象(data属性)----多了两个方法,get和set var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;) //2. get和set是干什么的? var obj = &#123;&#125;; (function() &#123; Object.defineProperty(obj, &quot;age&quot;, &#123; //给age设置值的时候回自动调用这个方法 set: function() &#123; console.log(&quot;set---设置值&quot;) &#125;, //获取age值的时候,会自动调用这个方法 get: function() &#123; console.log(&quot;get---获取值&quot;); &#125; &#125;); &#125;)() obj.age = 2; //_age:undefined----设置 console.log(obj.age); //0---------获取值&lt;/script&gt; 提升-可以设置并得到相应的内容 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; var obj = &#123;&#125;; (function() &#123; //定义一个变量提前保存设置的值 var _age; Object.defineProperty(obj, &quot;age&quot;, &#123; set: function(value) &#123; _age = value; &#125;, get: function() &#123; //当_age的值为空的时候,给其一个默认的值 return _age === undefined ? 0 : _age; &#125; &#125;); &#125;)() obj.age = 2; //_age:undefined console.log(obj.age); //2 &lt;/script&gt;&lt;/html&gt; 监测数据的变化 watchers 之前我们在计算属性中提到过,通过实例的watch可以监测data属性中数据的变化,在这里使用的就是这一特性 当监测到数据发生变动时,进行组件上数据的更新 在这里,我们再回顾一下之前的例子 数据的变化会自动监测并渲染 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt; &lt;input v-model=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; name: &apos;&apos;, answer: &apos;数据没有变化&apos; &#125; var watchExampleVM = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, watch: &#123; // 如果 question 发生改变，这个函数就会运行 name: function() &#123; this.answer = Math.random() &#125; &#125; &#125;)&lt;/script&gt; 重新渲染虚拟dom树 在第三阶段,完成数据变化监测并更新数据后,会将数据的变动重新渲染到虚拟dom树上 由此四步完成一个循环的过程,只要是数据发生变化,就会自动监测到并渲染 重新渲染DOM树 响应式原理中存在的问题(了解)变化监测问题 之前也给大家演示过,通过普通的方式为已有的实例添加/删除对象属性是存在一些问题的 受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除 由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 我们可以使用Vue.set(object, key, value)或者是this.$set(this.someObject,’b’,2)添加响应式属性 推荐在初始化数据的时候再data对象中声明所有的响应式属性 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;ul&gt; &lt;li v-for=&apos;item in arr&apos;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; arr : [1,2,3] &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;) //读取值 console.log(vm.arr) console.log(vm.$data.arr) //设置值----存在的问题,当数组里面的值使用下标的形式修改的时候,视图和模型数据不会动态更新 vm.arr[0]=4; //使用set方法设置的值,可以动态更新到模型数据和视图上 Vue.set(vm.arr,0,100) //使用vue的实例暴露出来的属性和方法进行操作 vm.$set(vm.arr,1,200)&lt;/script&gt; 异步更新队列(了解) 之前给大家讲解过,计算属性computed,使用计算属性存在的一个优点就是不像传统的方式那样,每执行一次,都会重新执行相关的代码, 在vue中,计算属性做了一个缓存机制,当依赖关系不发生变化时,直接使用缓存的结果,而不是调用getter 这个可以看成是异步更新队列的一个应用 12345678910可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = &apos;new value&apos; ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用 过渡效果简介 我们在前面的css和js中学习过动画和过渡的相关知识,同样的,在vue中也给我们提供了这样的特性 它能够在元素从dom中绑定或移除的时候出发过渡和动画 也就是说在dom元素发生变化的时候为其添加特定的class,从而产生过渡效果 同样的,vue.js也支持js的过渡,通过暴露出的过渡系统的钩子函数,我们在dom变化 的特定时期对其进行属性的操作,从而产生动画 总之,过渡效果包括css和js两个方面的内容 综上所述: 过渡的实现可以大致分为以下几个部分 1.过渡的内容 过渡的时机 过渡的样式 基本的vue模板 mvvm设计模式 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--1. 视图--&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //2. 数据模型 var dataModel = &#123; message:&quot;hello Vue!&quot; &#125; //3. 实现视图和数据模型的关联 var vm = new Vue(&#123; el:&quot;#app&quot;, data:dataModel &#125;)&lt;/script&gt; Css过渡效果简介 在这里,我们想配合一个简单的例子来体验一下vue的过渡效果的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /*4. 添加过渡的相关的样式*/ /*1 先执行enter,时间特别短暂 再执行enter-active*/ .test-enter &#123; color: green; &#125; /*2*/ .test-enter-active &#123; transition: all 1s; color: red; &#125; /*元素 从页面移除*/ /*1*/ .test-leave &#123; opacity: 1; &#125; /*2*/ .test-leave-active &#123; opacity: 0; transition: all 1s linear; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;!--3. 定义一个按钮,点击的时候修改show的值,进行元素显示和隐藏(进入和离开)的切换--&gt; &lt;button v-on:click=&apos;show=!show&apos;&gt;点击按钮进行元素显示和隐藏的切换&lt;/button&gt; &lt;!-- 1. 定义过渡的组件 transition 所有需要过渡的元素都在其内部定义 给组件定义一个名称,后期用于类样式的添加 --&gt; &lt;transition name=&quot;test&quot;&gt; &lt;!-- 2. 咋transition内部定义过渡的内容 当元素进行显示/隐藏(进入/离开)切换的时候,会自动的添加以name名开头的类样式 --&gt; &lt;p v-show=&apos;show&apos;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var dataModel = &#123; message: &quot;hello Vue!&quot;, show: true &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: dataModel &#125;)&lt;/script&gt; 过渡的css类名 css过渡 也就是使用我们之前学过的css3里面的过渡特性的使用,不同的是设置类名的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /*4. 添加过渡的相关的样式*/ /*1 先执行enter,时间特别短暂 再执行enter-active*/ .test-enter &#123; color: green; &#125; /*2*/ .test-enter-active &#123; transition: all 1s; color: red; &#125; /*元素 从页面移除*/ /*1*/ .test-leave &#123; opacity: 1; &#125; /*2*/ .test-leave-active &#123; opacity: 0; transition: all 1s linear; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;!--3. 定义一个按钮,点击的时候修改show的值,进行元素显示和隐藏(进入和离开)的切换--&gt; &lt;button v-on:click=&apos;show=!show&apos;&gt;点击按钮进行元素显示和隐藏的切换&lt;/button&gt; &lt;!-- 1. 定义过渡的组件 transition 所有需要过渡的元素都在其内部定义 给组件定义一个名称,后期用于类样式的添加 --&gt; &lt;transition name=&quot;test&quot;&gt; &lt;!-- 2. 咋transition内部定义过渡的内容 当元素进行显示/隐藏(进入/离开)切换的时候,会自动的添加以name名开头的类样式 --&gt; &lt;p v-show=&apos;show&apos;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var dataModel = &#123; message: &quot;hello Vue!&quot;, show: true &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: dataModel &#125;)&lt;/script&gt; css动画 也就是使用我们之前学过的css3里面动画的特性的使用,不同的是设置类名的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /*4. 定义过渡的样式*/ .bounce-enter-active &#123; animation: bounce-in 1s; &#125; .bounce-leave-active &#123; animation: bounce-out 1s; &#125; @keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125; @keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-2&quot;&gt; &lt;!--3. 进行元素显示和隐藏的切换--&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;!--1. 定义过渡组件 添加名称(必须)--&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;!--2. 添加需要过渡的内容--&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125; &#125;)&lt;/script&gt; 自定义过渡属性类名 使用动画库 代码实现 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;点击按钮,进行元素显示和隐藏的切换&lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message:&quot;hello Vue!&quot;, show:true &#125; var vm = new Vue(&#123; el:&quot;#app&quot;, data:dataModel &#125;)&lt;/script&gt; 自定义过渡类名 使用自己定义的类样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .transition1 &#123; transition: all .3s ease; color: red; &#125; .transition2 &#123; transition: all .8s; transform: translateX(10px); opacity: 0.5; color: green; &#125; .transition3 &#123; transition: all .8s; transform: translateX(10px); opacity: 0.5; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle render&lt;/button&gt; &lt;transition name=&quot;&quot; enter-active-class=&quot;transition1&quot; leave-active-class=&quot;transition2&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &quot;hello Vue!&quot;, show: true &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: dataModel &#125;)&lt;/script&gt; 事件监听 动画结束事件 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .bounce-enter-active &#123; animation: bounce-in .5s infinite; &#125; .bounce-leave-active &#123; animation: bounce-out .5s; &#125; @keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125; @keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;// Vue.directive(&quot;&quot;,&#123;&#125;) new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125; &#125;) // 监听动画结束事件 document.getElementsByTagName(&apos;p&apos;)[0].addEventListener(&quot;animationend&quot;, function() &#123; console.log(1111); &#125;)&lt;/script&gt; 过渡结束事件 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--4. 样式添加--&gt; &lt;style type=&quot;text/css&quot;&gt; .slide-fade-enter-active &#123; transition: all .3s ease; color: red; &#125; .slide-fade-leave-active &#123; transition: all .8s; transform: translateX(10px); opacity: 0.5; color: green; &#125; .slide-fade-enter&#123; transform: translateX(10px); opacity: 0.5; color: green; &#125; .slide-fade-enter&#123; transform: translateX(10px); opacity: 0.5; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example-1&quot;&gt; &lt;!--3. 点击进行切换--&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle render&lt;/button&gt; &lt;!--1 过渡组件 必须添加name属性--&gt; &lt;transition name=&quot;slide-fade&quot;&gt; &lt;!--2. 过渡的内容--&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; show: true &#125; &#125;)//监听过渡结束事件 document.getElementsByTagName(&apos;p&apos;)[0].addEventListener(&quot;transitionend&quot;, function() &#123; console.log(1111); &#125;)&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"06-响应原理和过渡","slug":"vue/06-响应原理和过渡","permalink":"http://yoursite.com/categories/vue/06-响应原理和过渡/"}],"tags":[]},{"title":"05-filter","slug":"vue/05-filter/05-filter","date":"2018-05-10T01:32:34.954Z","updated":"2018-05-10T02:11:58.536Z","comments":true,"path":"2018/05/10/vue/05-filter/05-filter/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/05-filter/05-filter/","excerpt":"","text":"第五部分 过滤器 顾名思义,就是一个过滤的容器 简单回顾在ES5中,数组的filter方法123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var arr = [1,2,3,4,5]; var returnArr = arr.filter(function(ele,index,arr)&#123; if(ele%2===0)&#123; return true; &#125; else&#123; return false; &#125; &#125;) console.log(returnArr);&lt;/script&gt; 在jquery 1.8中的选择器过滤$(this).parent().children().filter(“p”) 在vue中也存在过滤这一概念,实现的功能都是类似的,不过在用法上有点区别 在这里我们先学习2.0里面的过滤器,这是由于1.0里面的很多内容都已废弃,我们先做简单的了解 过滤器注册 大致的过程可以分成两步 进行过滤器的注册 过滤器的使用,在表达式的后面添加管道符号(|) 过滤器可以分成两大类 私有过滤器 注册的时候使用filters属性,只能在当前vue组件(实例)下使用 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; message | toUC&#125;&#125; &lt;br /&gt; &#123;&#123; message | toUC(message)&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var viewModel = &#123; message: &apos;hello world!&apos;, message1: &apos;HELLO WORLD!&apos; &#125; //1. 私有过滤器 var vm1 = new Vue(&#123; el: &apos;#app&apos;, data: viewModel, filters: &#123; toUC: function(input) &#123; return input.toUpperCase() &#125; &#125; &#125;)&lt;/script&gt; 全局过滤器 注册的时候使用Vue.filter()全局api,可以在所有的vue组件(实例)中使用 全局api: 也就是全局方法,接口 (简单了解) 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;全局过滤器&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app1&quot;&gt; &lt;!-- 写法1 --&gt; &lt;!-- &#123;&#123;msg1 | toLC(msg1)&#125;&#125; --&gt; &lt;!-- 写法2 --&gt; &#123;&#123;msg1 | toLc&#125;&#125; &lt;/div&gt; &lt;div id=&quot;app2&quot;&gt; &#123;&#123;msg2 | toLc&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.filter(&apos;toLc&apos;, (input) =&gt; &#123; return input.toLowerCase(); &#125;); var vm1 = new Vue(&#123; el: &quot;#app1&quot;, data: &#123; msg1: &quot;I AM GOOD MAN&quot; &#125; &#125;); var vm2 = new Vue(&#123; el: &apos;#app2&apos;, data: &#123; msg2: &quot;YOU ARE A GOOD Girl&quot; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 双向过滤器(了解) 之前讲解的过滤器都是在数据渲染到页面之前进行数据的转化,并不会修改数据模型, 也就是说,没有实现数据的双向的绑定,称其为单向过滤器 双向过滤器就是: 通过过滤器实现双向的数据过滤 在修改视图的同时,也修改数据模型 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;私有过滤器&lt;/title&gt; &lt;!--在这里引入1.0的js文件--&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;price | cents&quot; /&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.filter(&apos;cents&apos;, &#123; read:function(value)&#123; return (value/100).toFixed(2); &#125;, write:function(value)&#123; return value*100; &#125; &#125;); var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; price:150 &#125; &#125;)&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"05-filter","slug":"vue/05-filter","permalink":"http://yoursite.com/categories/vue/05-filter/"}],"tags":[]},{"title":"04-计算属性","slug":"vue/04-base2/04-base2","date":"2018-05-10T01:32:34.952Z","updated":"2018-05-10T02:12:47.173Z","comments":true,"path":"2018/05/10/vue/04-base2/04-base2/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/04-base2/04-base2/","excerpt":"","text":"第四部分 Vue.js基础特性（下）计算属性 computed data,el,methods属性一样,都是vm实例的属性(选项) 理解其大致意思即可 绑定表达式 一段绑定表达式可以由一个简单的js表达式和可选的一个或多个过滤器组成 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--字符串拼接--&gt; &lt;p&gt;&#123;&#123; message + &quot;----&quot; + name &#125;&#125;&lt;/p&gt; &lt;!--三元运算符--&gt; &lt;p&gt;&#123;&#123; bool ? 1 : 0 &#125;&#125;&lt;/p&gt; &lt;!--四则运算--&gt; &lt;p&gt;&#123;&#123; num * 2 &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //创建Vue对象 var app =new Vue (&#123; el:&apos;#app&apos;,//将Vue对象绑定到指定的选择器 data:&#123; message: &apos;hello world &apos;, name:&apos;高辉&apos;, bool: true, num:10 &#125; &#125;)&lt;/script&gt; 上面已经讲解过绑定表达式的相关知识点,即在 内部支持js表达式 内的表达式是非常便利的，但是它们实际上只用于简单的运算,并且只能够支持单个js表达式,多个就会报错。 在模板中放入太多的逻辑会让模板过重且难以维护。 123&lt;div id=&quot;example&quot;&gt; &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/div&gt; 在这种情况下，模板不再简单和清晰。在意识到这是反向显示 message 之前，你不得不再次确认第二遍。当你想要在模板中多次反向显示 message 的时候，问题会变得更糟糕。 computed针对这些复杂的逻辑,提出了计算属性这一要求 也就是说,将我们复杂的计算逻辑提取出来 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;h2&gt;正常情况下的结果:&#123;&#123; message &#125;&#125;&lt;/h2&gt; &lt;!--正常情况下,模板结构变得复杂,特别是在多次使用复杂逻辑的时候--&gt; &lt;h2&gt;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/h2&gt; &lt;!--使用计算属性,使模板更简洁--&gt; &lt;h2&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, //我们可以像绑定普通属性那样绑定计算属性:计算属性定义在computed内部,和data类似 computed: &#123; //在这里,我们将计算的逻辑提取出来,封装成一个函数,在函数的内部分使用return来定义返回值,返回计算的结构 reverseMessage: function() &#123; return this.message.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125; &#125; &#125;)&lt;/script&gt; 大家是否还记得 v-on 和 methods呢? 要勤于复习哦! 你可能已经注意到我们可以通过调用表达式中的 method 来达到同样的效果： 在这里存在一些区别,涉及到缓存和性能的问题,下面我们将进行详细的讨论 12345methods: &#123; reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 计算缓存 methods vs computed 使用methods: 每次使用都会执行一次函数,不存在像计算属性那样的缓存,会浪费性能 计算属性的优点: 不同的计算属性是会基于他们的依赖进行缓存的,只有在依赖关系发生变化时,才会重新求值 当依赖关系没有发生变化时,不会重新求值,会使用上一次计算缓存的结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;h2&gt;正常情况下的结果:&#123;&#123; message &#125;&#125;&lt;/h2&gt; &lt;h2&gt;使用计算属性得出的结果:&#123;&#123; reverseMessageComputed &#125;&#125;&lt;/h2&gt; &lt;h2&gt;使用methods方法得出的结果:&#123;&#123; reverseMessageMethods() &#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, //计算属性的优点: 不同的计算属性是会基于他们的依赖进行缓存的,只有在依赖关系发生变化时,才会重新求值 //当依赖关系没有发生变化时,不会重新求值,会使用上一次计算缓存的结果 computed: &#123; reverseMessageComputed: function() &#123; return this.message.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125; &#125;, //使用methods: 每次使用都会执行一次函数,不存在像计算属性那样的缓存,会浪费性能 methods: &#123; reverseMessageMethods: function() &#123; return this.message.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125; &#125; &#125;)&lt;/script&gt; computed vs methods的缓存效果演示通过这个演示,你需要知道,对于一些单只需要纯的计算获取结果的内容,使用计算属性,能够提高性能,尤其是一些性能耗费比较严重的问题 一次增加绑定的数据的个数,根据渲染的时间来判定不同的效果 computed: 在增加绑定数据的个数的时候,渲染的时间基本不会变化(依赖关系没有发生变化) methods: 在增加绑定数据的个数的时候,渲染的时间会随着渲染的次数的增加而递增(依赖关系没有发生变化) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var startTime = Date.now() var str = &apos;&#123;&#123; reverseMessageMethods() &#125;&#125;&#123;&#123; reverseMessageMethods() &#125;&#125;&apos; + &apos;&#123;&#123; reverseMessageMethods() &#125;&#125;&#123;&#123; reverseMessageMethods() &#125;&#125;&apos; + &apos;&#123;&#123; reverseMessageMethods() &#125;&#125;&#123;&#123; reverseMessageMethods() &#125;&#125;&apos; + &apos;&#123;&#123; reverseMessageMethods() &#125;&#125;&#123;&#123; reverseMessageMethods() &#125;&#125;&apos; + &apos;&#123;&#123; reverseMessageMethods() &#125;&#125;&#123;&#123; reverseMessageMethods() &#125;&#125;&apos;; document.getElementById(&quot;app&quot;).innerHTML = str; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, //使用methods: 每次使用都会执行一次函数,不存在像计算属性那样的缓存,会浪费性能 methods: &#123; reverseMessageMethods: function() &#123; function fn(n) &#123; if(n === 1) &#123; return 1; &#125; if(n === 2) &#123; return 1; &#125; else &#123; return fn(n - 1) + fn(n - 2); &#125; &#125; var num = fn(35) return num; &#125; &#125; &#125;) //-----------------计算属性-----缓存演示 var endTime = Date.now() console.log(endTime - startTime) var startTime = Date.now() var str1 = &apos;&#123;&#123; reverseMessageComputed &#125;&#125;&#123;&#123; reverseMessageComputed &#125;&#125;&apos; + &apos;&#123;&#123; reverseMessageComputed &#125;&#125;&#123;&#123; reverseMessageComputed &#125;&#125;&apos; + &apos;&#123;&#123; reverseMessageComputed &#125;&#125;&#123;&#123; reverseMessageComputed &#125;&#125;&apos; + &apos;&#123;&#123; reverseMessageComputed &#125;&#125;&#123;&#123; reverseMessageComputed &#125;&#125;&apos; + &apos;&#123;&#123; reverseMessageComputed &#125;&#125;&#123;&#123; reverseMessageComputed &#125;&#125;&apos;; document.getElementById(&quot;app&quot;).innerHTML = str1; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm1 = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, //计算属性的优点: 不同的计算属性是会基于他们的依赖进行缓存的,只有在依赖关系发生变化时,才会重新求值 //当依赖关系没有发生变化时,不会重新求值,会使用上一次计算缓存的结果 computed: &#123; reverseMessageComputed: function() &#123; function fn(n) &#123; if(n === 1) &#123; return 1; &#125; if(n === 2) &#123; return 1; &#125; else &#123; return fn(n - 1) + fn(n - 2); &#125; &#125; var num = fn(35) return num; &#125; &#125; &#125;) var endTime = Date.now() console.log(endTime - startTime)&lt;/script&gt; watch属性 vue提供的一种更通用的方式来观察和响应 Vue 实例上的数据变动的方式 当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch 通常更好的想法是使用 computed 属性而不是命令式的 watch 回调 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;watch监视:&#123;&#123; fullName &#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt;&lt;br /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; firstName: &quot;firstName&quot;, lastName: &quot;lastName&quot;, fullName: &quot;firstName lastName&quot; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, watch: &#123; //在变量变化的时候,会自动执行这个函数 参数val就是绑定的值 firstName: function(val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, //在这里:val获取的是执行该函数的元素的内容 参数val就是绑定的值 lastName: function(val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125; &#125;)&lt;/script&gt; getter 和 setter属性 (了解) 计算属性默认只有getter ,我们可以在需要的时候提供一个setter 也就是进行数据的读取和设置的操作 定义get和set方法,需要的时候直接调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; a: 1 &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, computed: &#123; //默认情况下,只会进行值的读取 aDouble: function() &#123; return this.a * 2 &#125;, //在需要的时候进行值的读取和设置 aPlus: &#123; get: function() &#123; return this.a + 1; &#125;, set: function(v) &#123; this.a = v - 1; &#125; &#125; &#125; &#125;) console.log(vm.aPlus) //2---------执行的是值的读取,也就是默认进行值的读取getter vm.aPlus = 100 //------------执行的是值的设置,也就是setter console.log(vm.a) //99 //调用computed方法,在没有参数的时候,不需要添加参数,否则的话,会报错 console.log(vm.aDouble) //4 --------------执行的是值的读取&lt;/script&gt; 观察者 watchers(了解) 当然啦,一项技术或者是理念的提出都是有其依据的 虽然我们提到watch是有弊端的,但是其存在还有其具体的意义 我们配合下面这个例子做作一个简单的介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;watch-example&quot;&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=&quot;question&quot;&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var watchExampleVM = new Vue(&#123; el: &apos;#watch-example&apos;, data: &#123; question: &apos;&apos;, answer: &apos;I cannot give you an answer until you ask a question!&apos; &#125;, watch: &#123; // 如果 question 发生改变，这个函数就会运行 question: function(newQuestion) &#123; this.answer = &apos;Waiting for you to stop typing...&apos; this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce 是一个通过 lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问yesno.wtf/api的频率 // ajax请求直到用户输入完毕才会发出 // 学习更多关于 _.debounce function (and its cousin // _.throttle), 参考: https://lodash.com/docs#debounce getAnswer: _.debounce( function() &#123; var vm = this if(this.question.indexOf(&apos;?&apos;) === -1) &#123; vm.answer = &apos;Questions usually contain a question mark. ;-)&apos; return &#125; vm.answer = &apos;Thinking...&apos; axios.get(&apos;https://yesno.wtf/api&apos;) .then(function(response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function(error) &#123; vm.answer = &apos;Error! Could not reach the API. &apos; + error &#125;) &#125;, // 这是我们为用户停止输入等待的毫秒数 500 ) &#125; &#125;)&lt;/script&gt; 在这个示例中，使用 watch 选项允许我们执行异步操作（访问一个 API），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这是计算属性无法做到的。 事件绑定与监听 之前我们已经讲解过v-on这个指令,可以监听dom,触发js代码,在这里我们先做一个简单的回顾 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;ul&gt; &lt;button v-on:click=&quot;clickNum = clickNum + 1&quot;&gt;click me!&lt;/button&gt; &lt;li&gt;这个按钮呗点击了 &#123;&#123;clickNum&#125;&#125; 次&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos;, clickNum: 0 &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; 方法和事件处理器 通过v-on可以绑定方法,方法支持传参 有时候,我们需要访问原生的dom事件,需要使用特殊变量$event将它传入方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!--不带参数--&gt; &lt;button v-on:click=&quot;sayHi1&quot;&gt;不带参数&lt;/button&gt; &lt;!--带参数--&gt; &lt;button v-on:click=&quot;sayHi2(&apos;say what&apos;)&quot;&gt;带参数&lt;/button&gt; &lt;!--使用原生dom事件,传递$event这个特殊参数--&gt; &lt;button v-on:click=&quot;sayHi3(&apos;say what&apos;,$event)&quot;&gt;特殊参数&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel, methods:&#123; sayHi1:function()&#123; console.log(&quot;hello&quot;) &#125;, sayHi2:function(msg)&#123; console.log(msg) &#125;, sayHi3:function(msg,event)&#123; console.log(msg,event.target) &#125; &#125; &#125;) //通过js调用处理,和上面得到的结果是相同的 //区别是: 点击执行(事件处理函数)与直接执行 vm.sayHi1(&quot;test&quot;)&lt;/script&gt; 修饰符 之前我们提到过一些指令的修饰符,和这里的修饰符都是类似的东西,帮助我们解决一些实际的问题 事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题， Vue.js 为 v-on 提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!-- 阻止单击事件冒泡 --&gt; &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt; &lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt; &lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt; &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; &lt;!-- 点击事件将只会触发一次 --&gt; &lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- .stop: event.stopPropagation().prevent event.preventDefault().capture : 捕获.self : 只有当该元素是事件本身时触发回调.once : 只会触发一次 --&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; 按键修饰符 同样的,在按键事件中也给我们提供了一些较为便利的操作(修饰符) 12345678910111213141516.enter.tab.delete (捕获 “删除” 和 “退格” 键).esc.space.up.down.left.right -------------------------------------------------支持链式写法 2.1.0新增 .ctrl.alt.shift.meta: 对应的是window键 简单演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!-- 只有在keyCode的值是13时 调用vm.submit 13:回车键/enter键--&gt; &lt;input v-on:keyup.13=&quot;submit&quot;&gt;&lt;/input&gt; &lt;!-- 同上 支持链式写法--&gt; &lt;input v-on:keyup.enter=&quot;submit&quot;&gt; &lt;!-- 缩写语法 --&gt; &lt;input @keyup.enter=&quot;submit&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel, methods: &#123; submit: function() &#123; console.log(&quot;submit&quot;) &#125; &#125; &#125;) /** * *可以通过全局 config.keyCodes 对象自定义按键修饰符别名： * * */ Vue.config.keyCodes.f1 =112;&lt;/script&gt; 与传统事件绑定的区别 你可能注意到这种事件监听的方式违背了关注点分离（separation of concern）传统理念。 不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。 实际上，使用 v-on 有几个好处： 123451. 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。2. 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。3. 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。 new Vue()和Vue.extend() 之前我们讲解到,vue的两大特性: 数据的 双向绑定和组件化 在这里,我们对组件化进行更深一步的了解 new Vue() new Vue()创建的是vue的一个实例,之前我们提到过,vue是只关注视图层 我们可以将页面看成是一个大的根组件,里面包含的元素就是子组件,子组件可以在不同的根组件中被调用 那么,如何创建子组件呢,这个是我们需要关注的主题 Vue.extend() 在vue中给我们提供的创建组价的方式, 在这里,我们先了解一下这个方法,之后再做详细的讲解 两者的共性 构造器 每个 Vue.js 应用的起步都是通过构造函数 Vue 创建一个 Vue 的根实例(根组件) 可以扩展 Vue 构造器，从而用预定义选项创建可复用的组件构造器 我们配合下面这个简单的例子做一下简单的分析 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- vue这个对象可以进行扩展 相当于在原先的vue的基础上添加新的内容,形成我们自己的,别具一格的vue --&gt;&lt;script&gt; //1. 扩展vue对象 var vueExtend = Vue.extend(&#123; //----定义扩展的vue的对象的内容 template:&apos;&lt;div&gt;&lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;/div&gt;&apos; &#125;) //3. 创建根实例 var vm = new vueExtend(&#123; el:&apos;#app&apos; &#125;)&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"04-base2","slug":"vue/04-base2","permalink":"http://yoursite.com/categories/vue/04-base2/"}],"tags":[]},{"title":"03-vue指令","slug":"vue/03-directive/03-directive","date":"2018-05-10T01:32:34.951Z","updated":"2018-05-10T01:33:22.032Z","comments":true,"path":"2018/05/10/vue/03-directive/03-directive/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/03-directive/03-directive/","excerpt":"","text":"第三部分 指令内置指令总结v-bind 可以绑定属性,包括class style,而已省略,使用:替代 在1vue.0中有三种修饰符,.sync,.once,.camel,在2.0中能够废弃了前面两个 .camel将绑定的特性的名称转化为驼峰法则命名 v-model 随着表单控件的不同而有所不同 可以添加修饰符 1.lazy .number .trim v-if v-else-if v-else v-show 可以配合模板使用 v-if和v-show两者都可以实现元素的状态切换,但是两者存在一些区别 v-if根据判断条件决定是否渲染,如果条件为假,不进行任何操作 v-show无论如何都会进行模块的渲染,只是简单的基于css 的切换 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 v-for 可以配合模板使用,也可以单独进行列表和表格的渲染 v-on 进行事件的绑定,可以省略,使用@替代 1234567类似于原生js的事件绑定的方式1. 获取dom元素2. 进行事件的添加3. 添加事件处理函数 v-text 绑定文本 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!--上下两种书写形式的 效果是一样的--&gt; &lt;p v-text=&quot;message&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var viewModel = &#123; //模型数据的初始化 message: &apos;hello world!&apos; &#125; // viewModel 连接模型和数据库 var vm= new Vue(&#123; el:&apos;#app&apos;, data:viewModel &#125;)&lt;/script&gt; v-html 绑定html标签 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!--上下两种书写形式的 效果是一样的--&gt; &lt;p v-text=&quot;message&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var viewModel = &#123; //模型数据的初始化 message: &apos;hello world!&apos; &#125; // viewModel 连接模型和数据库 var vm= new Vue(&#123; el:&apos;#app&apos;, data:viewModel &#125;)&lt;/script&gt; v-once 不需要表达式 只绑定一次,数据修改时,模型上面的数据不会再动态渲染到页面上 2.0版本新增 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;message&quot; id=&quot;&quot; value=&quot;&quot; /&gt; &lt;h2 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; v-pre 不需要表达式 跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 v-cloak 这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; [v-cloak] &#123; display: none; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;div v-cloak&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 这段 CSS 的含义是，包含 v-cloak (cloak n. 披风，斗篷；vt. 遮盖，掩盖) 属性的 html 标签在页面初始化时会被隐藏。在 vuejs instance ready 之后，v-cloak 属性会被自动去除，也就是对应的标签会变为可见 --&gt;&lt;script&gt; var dataModel = &#123; //模型数据的初始化 message: &apos;hello world!&apos;, &#125; // viewModel 连接模型和数据库 var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; 自定义指令 除了内置指令，Vue.js 也允许注册自定义指令。自定义指令提供一种机制将数据的变化映射为 DOM 行为。可以用 Vue.directive(id, definition) 方法注册一个全局自定义指令，它接收两个参数指令 ID 与定义对象。 也可以用组件的 directives 选项注册一个局部自定义指令。 全局自定义指令1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //注册一个全局自动以的指令 v-focus Vue.directive(&apos;focus&apos;, &#123; //绑定的元素插入到父节点时调用 inserted: function(el) &#123; //聚焦元素 el.focus() &#125; &#125;) //创建vue的实例 var vm = new Vue(&#123; el: &quot;#app&quot; &#125;)&lt;/script&gt; 局部自定义指令123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; // 创建根实例 new Vue(&#123; el: &apos;#app&apos;, directives: &#123; // 注册一个局部的自定义指令 v-focus focus: &#123; // 指令的定义,当指定的元素绑定到父元素时调用 inserted: function(el) &#123; // 聚焦元素 el.focus() &#125; &#125; &#125; &#125;)&lt;/script&gt; 钩子函数及其参数指令定义函数提供了几个钩子函数（可选）： 1234567891.0版本中的钩子函数 bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新 unbind: 只调用一次， 指令与元素解绑时调用。2.0新增的钩子函数 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 接下来我们来看一下钩子函数的参数 :(包括 el，binding，vnode，oldVnode) el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=&quot;1 + 1&quot;, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=&quot;1 + 1&quot; ， expression 的值是 &quot;1 + 1&quot;。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 &quot;foo&quot;。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 钩子函数 五个钩子函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--视图--&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&apos;message&apos;&gt; &lt;input type=&quot;text&quot; v-my-directive=&quot;message&quot; v-model=&apos;message&apos; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //指令名称 有了指令 能干什么 Vue.directive(&apos;my-directive&apos;, &#123; //第一次绑定的时候调用 只调用一次 bind: function(el, binding, vnode, oldnode) &#123; console.log(&apos;bind &apos;, arguments) &#125;, //被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） inserted: function(el) &#123; console.log(&quot;inserted&quot;) &#125;, //更新的时候调用 update: function() &#123; console.log(&apos;updata&apos;) &#125;, //解绑定的时候调用 unbind: function() &#123; console.log(&apos;unbind &apos;, arguments) &#125;, //组件完成一个周期调用 componentUpdated: function() &#123; console.log(&quot;componentUpdated&quot;) &#125; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &quot;hello&quot; &#125; &#125;) vm.$data.message = 1000;&lt;/script&gt; 钩子函数的参数和binding参数的属性 钩子函数的四个参数和binding参数的六个个属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--视图--&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&apos;message&apos;&gt; &lt;input type=&quot;text&quot; v-my-directive=&quot;message&quot; v-model=&apos;message&apos; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //指令名称 有了指令 能干什么 五个钩子函数 Vue.directive(&apos;my-directive&apos;, &#123; //第一次绑定的时候调用 只调用一次 bind: function(el, binding, vnode, oldnode) &#123; console.log(&apos;bind &apos;, arguments) &#125;, //被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） inserted: function(el) &#123; console.log(&quot;inserted&quot;) &#125;, //更新的时候调用 update: function() &#123; console.log(&apos;updata&apos;) &#125;, //解绑定的时候调用 unbind: function() &#123; console.log(&apos;unbind &apos;, arguments) &#125;, //组件完成一个周期调用 componentUpdated: function() &#123; console.log(&quot;componentUpdated&quot;) &#125; &#125;) var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &quot;hello&quot; &#125; &#125;) vm.message = 1000;&lt;/script&gt; 补充自定义指令子简写 大多数情况下，我们可能想在 bind 和 update 钩子上做重复动作，并且不想关心其它的钩子函数 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-color-swatch=&quot;&#123; color: &apos;green&apos;, text: &apos;菜鸟教程!&apos; &#125;&quot;&gt; test &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //大多数情况下，我们可能想在 bind 和 update 钩子上做重复动作，并且不想关心其它的钩子函数。可以这样写: Vue.directive(&apos;color-swatch&apos;, function(el, binding) &#123; //el: 可以直接通过el操作dom el.style.backgroundColor = binding.value.color; &#125;) new Vue(&#123; el: &apos;#app&apos; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 自定义指令之对象字面量 如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法类型的 JavaScript 表达式。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!--自定义指令--&gt; &lt;div v-runoob=&quot;&#123; color: &apos;green&apos;, text: &apos;菜鸟教程!&apos; &#125;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; Vue.directive(&apos;runoob&apos;, function(el, binding) &#123; //el: 可以直接通过el操作dom el.innerHTML = binding.value.text; el.style.backgroundColor = binding.value.color; &#125;) var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; 指令的高级选项(了解) 该部分在2.0中已经不做详细的讲解 vue2.0中的变化变化主要体现在以下两个方面 钩子函数123451.0中 bind：只调用一次，在指令第一次绑定到元素上时调用。 update： 在 bind 之后立即以初始值为参数第一次调用，之后每当绑定值变化时调用，参数为新值与旧值。 unbind：只调用一次，在指令从元素上解绑时调用。 函数的参数/实例属性123456789101.0中 所有的钩子函数将被复制到实际的指令对象中，钩子内 this 指向这个指令对象。这个对象暴露了一些有用的属性： el: 指令绑定的元素。 vm: 拥有该指令的上下文 ViewModel。 expression: 指令的表达式，不包括参数和过滤器。 arg: 指令的参数。 name: 指令的名字，不包含前缀。 modifiers: 一个对象，包含指令的修饰符。 descriptor: 一个对象，包含指令的解析结果。","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"03-directive","slug":"vue/03-directive","permalink":"http://yoursite.com/categories/vue/03-directive/"}],"tags":[]},{"title":"02-vue基础","slug":"vue/02-vueBase/02-base1","date":"2018-05-10T01:32:34.949Z","updated":"2018-05-10T01:33:12.903Z","comments":true,"path":"2018/05/10/vue/02-vueBase/02-base1/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/02-vueBase/02-base1/","excerpt":"","text":"第二部分 vue的基础特性(上) 在这一章我们主要是讲解一些vue实例的属性和一些基础的指令 vue实例属性:其实和我们之前所学的对象的属性是相似的东西 vue的基础指令: 对于指令,大家可能之前么有接触过相关的概念,其实大家可以这样理解 指令:可以看做是命令,在vue中我们可以通过指令来完成相关的操作 指令: 在vue中以v-开头,后面紧跟具体的操作命令 一些基本的指令,具体的用法下面会进行介绍 12345678910v-once: 只绑定一次v-bind: 绑定数据v-model: 绑定模型v-on: 绑定事件v-if v-show: 条件渲染 实例和选项 也就是vue实例化后的对象的一些属性相关的内容 123el data methods$el $data $mount 代理/数据 我们之前提到过,vue是mvvm模型,其中的m指的是数据模型,在这里我们对数据模型这一块做一个简单的讲解 vue的代理/数据 每个vue的实例都会代理其data对象中的所有的属性 通过vue的实例,可以直接访问data对象中属性 通过vue的实例,可以设置data对象里面的内容,设置属性也会影响到原始的数据 在代理中存在的问题 在实例创建之后添加新的属性到实例上,不会触发视图的更新 关于这一部分的内容在响应系统中再做详细的讲解 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;) //直接访问 console.log(vm.message)//hello world //设置属性也会影响到数据 vm.message = 10; console.log(dataModel.message)//10 //在vue实例创建之后,再添加新的属性到实例上,不会触发视图的更新 vm.a = 100; console.log(dataModel.a)//undefined&lt;/script&gt; vue 的 $ Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的数据属性区分 了解 : $set 的使用存在一些问题,在vue2.0中作了简单修改 对于 Vue 实例，可以使用 $set(key, value) 实例方法：这样使用会报错,以下两种方式是可以使用的(存在疑问) Vue.set(object, key, value) this.$set(this.someObject,’b’,2) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;ul&gt; &lt;li v-for=&apos;item in arr&apos;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; arr : [1,2,3] &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;) //读取值 console.log(vm.arr) console.log(vm.$data.arr) //设置值----存在的问题,当数组里面的值使用下标的形式修改的时候,视图和模型数据不会动态更新 vm.arr[0]=4; //使用set方法设置的值,可以动态更新到模型数据和视图上 Vue.set(vm.arr,0,100) //使用vue的实例暴露出来的属性和方法进行操作 vm.$set(vm.arr,1,200)&lt;/script&gt; 方法 使用methods来定义方法,使用v-on监听事件,绑定事件处理函数 1234567关于事件处理这一块,在这里做一点补充1. 在vue1中,支持自定义事件,vue2中废弃了2. vue2中推荐使用全局的$on和$emit来进行全局的方法的定义和触发3. vue2中,也可以使用插件vuex来处理 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里使用v-on来绑定事件处理的方法(函数)--&gt; &lt;button v-on:click=&apos;fn&apos;&gt;click&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel, //在这里使用methods对象来定义方法(点击事件处理函数) methods:&#123; fn: function()&#123; console.log(&quot;这个方法被调用了&quot;) &#125; &#125; &#125;)&lt;/script&gt; 生命周期简介 vue在创建的时候会有一系列初始化的步骤 实例需要配置数据监测(data observe),模板编译,挂载到dom,然后在变化时更新dom 实例也会调用一些生命周期钩子,为我们提供了自定义逻辑的机会 所有的生命周期钩子自动绑定this上下文到实例中,箭头函数绑定 生命周期钩子函数 其实指的也就是生命周期方法,只不过是挂载到执行的各个阶段,所以叫钩子函数 演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue入门之生命周期&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; name=&quot;btnSetNumber&quot; v-model=&quot;number&quot;&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; number: 1 &#125;, //在创建对象之前,监控数据变化和初始化事件之前调用 beforeCreate: function() &#123; console.log(&apos;beforeCreate 钩子执行...&apos;); console.log(this.number) //数据监测还没有开始 &#125;, //实例创建完成之后调用,挂载阶段还没有开始 created: function() &#123; console.log(&apos;cteated 钩子执行...&apos;); console.log(this.number) &#125;, //开始挂载的时候执行,这时html还没有渲染到页面上 beforeMount: function() &#123; console.log(&apos;beforeMount 钩子执行...&apos;); console.log(this.number) &#125;, //挂载完成,也就是模板中的heml渲染到了页面中,此时可以做一些ajax的操作,这个钩子函数只会执行一次 mounted: function() &#123; console.log(&apos;mounted 钩子执行...&apos;); console.log(this.number) &#125;, //数据更新之前调用 beforeUpdate: function() &#123; console.log(&apos;beforeUpdate 钩子执行...&apos;); console.log(this.number) &#125;, //数据更新之后调用 updated: function() &#123; console.log(&apos;updated 钩子执行...&apos;); console.log(this.number) &#125;, //数据销毁之前 beforeDestroy: function() &#123; console.log(&apos;beforeDestroy 钩子执行...&apos;); console.log(this.number) &#125;, //数据销毁之后 destroyed: function() &#123; console.log(&apos;destroyed 钩子执行...&apos;); console.log(this.number) &#125;, &#125;); //实现数据的更新 // vm.$set(dataModel, &apos;number&apos;, 123) //销毁钩子的执行 // vm.$destroy(true) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 补充 在vue2.0之后 , 也就是后续的版本中, 生命周期钩子已经发生的变化 , 在原先的基础上新增了两个生命周期钩子函数 1.activated keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。 2.deactivated keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。 数据绑定 vue的核心特性之一是双向的数据绑定,关于如何进行数据的绑定,下面我们结合具体的例子来作讲解 数据绑定的语法文本插值 直接填坑,进行数据的绑定 v-once:只绑定一次,首次赋值后更改vm实例的属性值不会引起dom元素绑定的值的变化 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; v-model=&quot;message&quot; id=&quot;&quot; value=&quot;&quot; /&gt; &lt;h2 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; html属性的绑定 v-bind: 为html标签绑定属性值 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;div v-bind:id=&quot;mainID&quot; v-html=&quot;main&quot;&gt; &lt;/div&gt; &lt;img v-bind:src=&quot;imgUrl&quot;/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 绑定属性 v-bind:prop_name=&quot;prop_value&quot; 输出html v-html=&quot;content&quot; 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。 --&gt;&lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data:&#123; message:&quot;hello world&quot;, mainID:&quot;dv&quot;, main:&quot;&lt;p&gt;这是v-html绑定的内容&lt;/p&gt;&quot;, imgUrl:&apos;http://img2.imgtn.bdimg.com/it/u=2204211808,2775991232&amp;fm=23&amp;gp=0.jpg&apos; &#125; &#125;)&lt;/script&gt; 绑定表达式 一段绑定表达式可以由一个简单的js表达式和可选的一个或多个过滤器组成 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--字符串拼接--&gt; &lt;p&gt;&#123;&#123; message + &quot;----&quot; + name &#125;&#125;&lt;/p&gt; &lt;!--三元运算符--&gt; &lt;p&gt;&#123;&#123; bool ? 1 : 0 &#125;&#125;&lt;/p&gt; &lt;!--四则运算--&gt; &lt;p&gt;&#123;&#123; num * 2 &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 使用的限制是只能包含单个表达式--&gt;&lt;script&gt; //创建Vue对象 var app =new Vue (&#123; el:&apos;#app&apos;,//将Vue对象绑定到指定的选择器 data:&#123; message: &apos;hello world &apos;, name:&apos;高辉&apos;, bool: true, num:10 &#125; &#125;)&lt;/script&gt; 表单控件 vue中使用v-model指令对表单元素进行双向的数据绑定 text 绑定的值就是value值 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&apos;message&apos; /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; textarea 绑定的值也是value值 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;p&gt;multiline message is&lt;/p&gt; &lt;p style=&quot;white-space: pre&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;textarea v-model=&quot;message&quot; placeholder=&quot;mulpiline message&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; radio 绑定的值就是选中单选框的value值 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; value=&quot;male&quot; v-model=&apos;gender&apos; /&gt;男 &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; value=&quot;female&quot; v-model=&apos;gender&apos; /&gt;女 &lt;/label&gt; &lt;p&gt;&#123;&#123;gender&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos;, gender:&quot;male&quot; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; checkbox - 1 单选: 绑定的值是bool值,决定是否选中 多选: 绑定的值是一个数组类型,value值为数组里面的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &lt;h2&gt;&#123;&#123; message1 &#125;&#125;&lt;/h2&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked1&quot; /&gt; &lt;h2&gt;&#123;&#123;message2&#125;&#125;&lt;/h2&gt; &lt;br /&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked2&quot; value=&quot;1&quot; /&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;hr /&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked2&quot; value=&quot;2&quot; /&gt; &lt;label for=&quot;jack&quot;&gt;rose&lt;/label&gt; &lt;hr /&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked2&quot; value=&quot;3&quot; /&gt; &lt;label for=&quot;jack&quot;&gt;mack&lt;/label&gt; &lt;hr /&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked2&quot; value=&quot;4&quot; /&gt; &lt;label for=&quot;jack&quot;&gt;july&lt;/label&gt; &lt;hr /&gt; &lt;label for=&quot;checkbox&quot;&gt;&#123;&#123;checked&#125;&#125;&lt;/label&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message1: &apos;单选&apos;, message2: &apos;多选&apos;, checked1: false, checked2:[1,2] &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; checkedbox - 212345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt; &lt;p&gt;&#123;&#123; picked &#125;&#125;&lt;/p&gt; &lt;hr/&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt; &lt;p&gt;&#123;&#123; toggle &#125;&#125;&lt;/p&gt; &lt;hr/&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt; &lt;/select&gt; &lt;hr/&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; picked: &apos;&apos;, toggle: true, selected: &apos;abc&apos;, a: &apos;1&apos;, b: &apos;2&apos; &#125; var em = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; select 单选: 根据option的value值设置选中 多选: 根据value值的数组设置选中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;单选&lt;/h2&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;/select&gt; &lt;p&gt;单选选中项是: &#123;&#123;selected&#125;&#125;&lt;/p&gt; &lt;h2&gt;多选&lt;/h2&gt; &lt;select v-model=&quot;selecteds&quot; multiple&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;/select&gt; &lt;p&gt;多选选中项是: &#123;&#123;selecteds&#125;&#125;&lt;/p&gt; &lt;h2&gt;动态的select--循环渲染-设置单选&lt;/h2&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123;option.text&#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;p&gt;多选选中项是: &#123;&#123;selecteds&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; message1: &apos;单选&apos;, message2: &apos;多选&apos;, selected: &apos;B&apos;, selecteds: [&apos;A&apos;, &apos;B&apos;], options: [&#123; text: &apos;One&apos;, value: &apos;A&apos; &#125;, &#123; text: &apos;Two&apos;, value: &apos;B&apos; &#125;, &#123; text: &apos;Three&apos;, value: &apos;C&apos; &#125;] &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; 绑定value 对于单选按钮，勾选框及选择列表选项， v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值） 复选框 选择列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--对于单选按钮，勾选框及选择列表选项， v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：--&gt; &lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt; &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt; &lt;!-- `toggle` 为 true 或 false --&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt; &lt;!-- 当选中时，`selected` 为字符串 &quot;abc&quot; --&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt; &lt;/select&gt; &lt;!--复选框--&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt; &lt;!--选择列表--&gt; &lt;select v-model=&quot;selected1&quot;&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var dataModel = &#123; picked: &apos;a&apos;, toggle: true, selected: &apos;abc&apos;, a: true, b: false, selected1: &#123; number: 123 &#125; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;) // 选中 console.log(vm.toggle === vm.a) //true // 取消选中 console.log(vm.toggle === vm.b) //false // 选择列表的设置 console.log(vm.selected1) console.log(vm.selected1.number)&lt;/script&gt; 修饰符.lazy 在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分) 但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&apos;message&apos; /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 禁用数据的双向绑定 --&gt;&lt;script&gt; var dataModel = &#123; message: &apos;hello world!&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; .number 如果想自动将用户的输入值转为 Number 类型 如果原值的转换结果为 NaN 则返回原值 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model.number=&apos;message&apos; /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 用户输入的数据可以转化W为number类型 进行输入的转化 不能转化问number类型(NaN),会保持当前的输入 --&gt;&lt;script&gt; var dataModel = &#123; message: &apos;11&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; .trim 过滤用户输入的首尾空格 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model.trim=&apos;message&apos; /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--过滤用户输入的首尾空格--&gt;&lt;script&gt; var dataModel = &#123; message: &apos;&apos; &#125; var vm= new Vue(&#123; el:&apos;#app&apos;, data:dataModel &#125;)&lt;/script&gt; class 与 styleclass的绑定 对象语法 数组语法 style的绑定 对象语法 使用对象的形式绑定样式 数组语法 绑定多个对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .active &#123; background: pink; width: 200px; height: 200px; float: left; margin-left: 30px; &#125; .bd &#123; border: 1px solid red; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--绑定单个类样式--&gt; &lt;div v-bind:class=&quot;&#123;active:isActive&#125;&quot;&gt;&lt;/div&gt; &lt;!--绑定多个类样式--&gt; &lt;div v-bind:class=&quot;&#123;active:isActive,bd:hasBorder&#125;&quot;&gt;&lt;/div&gt; &lt;!--使用对象的方式绑定类样式--&gt; &lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; &lt;!--使用数组绑定--&gt; &lt;div v-bind:class=&quot;[classA,classB]&quot;&gt;&lt;/div&gt; &lt;!--三元表达式--&gt; &lt;div v-bind:class=&quot;[classA, isB ? classB : &apos;&apos;]&quot;&gt;&lt;/div&gt; &lt;!--内联样式的绑定--&gt; &lt;div v-bind:style=&quot;&#123;fontSize: size + &apos;px&apos;, backgroundColor: bgcolor, width: width&#125;&quot;&gt; vue 内联样式的绑定 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 样式的绑定 1. v-bind:class=&quot;&#123;active:isActive&#125; 当绑定的数据isActive的值为true时,就会为该元素添加类样式 2. v-bind:class=&quot;&#123;active:isActive,bd:hasBorder&#125;&quot; 支持混合类样式绑定,即同时绑定多个类样式 3. v-bind:class=&quot;classObject&quot; 支持使用对象绑定类样式 4. v-bind:class=&quot;[classA,classB]&quot; 5. &lt;div v-bind:class=&quot;[classA, isB ? classB : &apos;&apos;]&quot;&gt; 当 v-bind:style 使用需要厂商前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 --&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isActive: true, hasBorder: true, classObject: &#123; active: true, bd: true &#125;, //内联样式 size: 19, width: 200, bgcolor: &apos;red&apos;, //数组形式 classA: &quot;a&quot;, classB: &apos;b&apos;, isB: true &#125; &#125;)&lt;/script&gt; 模板渲染条件渲染 v-if v-else-if v-else v-show 支持模板语法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--在这里加入模型数据--&gt; &#123;&#123; message &#125;&#125; &lt;!--这里 v-if 指令将根据表达式 greeting 值的真假删除/插入 &lt;p&gt; 元素。--&gt; &lt;p v-if=&quot;greeting&quot;&gt;Hello!&lt;/p&gt; &lt;!--bool值可以使条件表达式--&gt; &lt;p v-if=&quot;Math.random()&gt;0.5&quot;&gt;根据随机值判断是否显示&lt;/p&gt; &lt;!--使用v-if配合template可以实现模板渲染--&gt; &lt;template v-if=&apos;bool&apos;&gt; &lt;h1&gt;&#123;&#123;header&#125;&#125;&lt;/h1&gt; &lt;p&gt;&#123;&#123;paragraph&#125;&#125; 1&lt;/p&gt; &lt;p&gt;&#123;&#123;paragraph&#125;&#125; 2&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;data in array&quot;&gt;&#123;&#123;data&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; var viewModel = &#123; //模型数据的初始化 message: &apos;hello world!&apos;, greeting:true, bool:true, header:&quot;这是一个标题&quot;, paragraph:&quot;这是一个段落&quot;, array:[1,2,3,4] &#125; // viewModel 连接模型和数据库 var vm = new Vue(&#123; el: &apos;#app&apos;, data: viewModel, &#125;)&lt;/script&gt; 列表渲染 v-for 支持模板语法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--view--&gt; &lt;ul&gt; &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt; &lt;/ul&gt; &lt;ul&gt; &lt;!--简单的列表渲染--&gt; &lt;li v-for=&apos;data in liData1&apos;&gt; &#123;&#123;data&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;!--复杂的列表渲染--&gt; &lt;li v-for=&apos;data in liData2&apos;&gt; &#123;&#123;data.text&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;!--添加index--&gt; &lt;li v-for=&quot;(data,index) in liData2&quot;&gt; &#123;&#123;data.text&#125;&#125;=======index====&#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!--模板语法--&gt; &lt;ul&gt; &lt;h2&gt;模板渲染&lt;/h2&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&#123;&#123;item.age&#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; // model var dataModel = &#123; num: 10, liData1: [1, 2, 3], liData2: [&#123; text: &quot;这是一段文本&quot; &#125;, &#123; text: &quot;这是一段文本&quot; &#125;, &#123; text: &quot;这是一段文本&quot; &#125;, &#123; text: &quot;这是一段文本&quot; &#125;], items: [&#123; name: 1, age: 1 &#125;, &#123; name: 2, age: 2 &#125;] &#125; // viewModel var app = new Vue(&#123; el: &apos;#app&apos;, data: dataModel &#125;)&lt;/script&gt; template模板用法(简单了解) template标签用法 vue实例的 el 和 template 选项 配合使用,完成页面的渲染 组件/模板内部的元素一定要有一个根元素包裹 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--引入js--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--视图的入口--&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;script id=&quot;tp1&quot; type=&quot;x-template&quot;&gt; &lt;div class=&quot;tp1&quot;&gt; &lt;p&gt;this is a tp1 from script tag&lt;/p&gt; &lt;/div&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; //在这里,将template对应的script内部的元素挂载到对应的el所指定的位置 var vm= new Vue(&#123; el:&apos;#app&apos;, template:&quot;#tp1&quot; &#125;)&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"02-vueBase","slug":"vue/02-vueBase","permalink":"http://yoursite.com/categories/vue/02-vueBase/"}],"tags":[]},{"title":"vue入门","slug":"vue/01-vue入门/01-vueStart","date":"2018-05-10T01:32:34.667Z","updated":"2018-05-10T02:19:54.886Z","comments":true,"path":"2018/05/10/vue/01-vue入门/01-vueStart/","link":"","permalink":"http://yoursite.com/2018/05/10/vue/01-vue入门/01-vueStart/","excerpt":"","text":"第一部分: vue入门/简介嘻嘻嘻 vue的引入 先看下面这样一个简单的例子,实现了这样一个功能 数据的双向绑定:也就是数据的同步修改 12345逻辑分析: 1. 我们需要一个UI元素和属性相互绑定的方法 2. 我们需要监视属性和UI元素的变化 3. 我们需要让所有绑定的对象和元素都能感知到变化 vue与js的对比js的实现(了解)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h4&gt;数据的双向绑定----js的实现&lt;/h4&gt; &lt;input type=&quot;text&quot; data-bind-1=&quot;name&quot; /&gt; &lt;input type=&quot;text&quot; data-bind-1=&quot;name&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; function DataBinder(object_id) &#123; // Create a simple PubSub object var pubSub = &#123; callbacks: &#123;&#125;, on: function(msg, callback) &#123; this.callbacks[msg] = this.callbacks[msg] || []; this.callbacks[msg].push(callback); &#125;, publish: function(msg) &#123; this.callbacks[msg] = this.callbacks[msg] || []; for(var i = 0, len = this.callbacks[msg].length; i &lt; len; i++) &#123; this.callbacks[msg][i].apply(this, arguments); &#125; &#125; &#125;, data_attr = &quot;data-bind-&quot; + object_id, message = object_id + &quot;:input&quot;, timeIn; changeHandler = function(evt) &#123; var target = evt.target || evt.srcElement, // IE8 compatibility prop_name = target.getAttribute(data_attr); if(prop_name &amp;&amp; prop_name !== &quot;&quot;) &#123; clearTimeout(timeIn); timeIn = setTimeout(function() &#123; pubSub.publish(message, prop_name, target.value); &#125;, 50); &#125; &#125;; // Listen to change events and proxy to PubSub if(document.addEventListener) &#123; document.addEventListener(&quot;input&quot;, changeHandler, false); &#125; else &#123; // IE8 uses attachEvent instead of addEventListener document.attachEvent(&quot;oninput&quot;, changeHandler); &#125; // PubSub propagates changes to all bound elements pubSub.on(message, function(evt, prop_name, new_val) &#123; var elements = document.querySelectorAll(&quot;[&quot; + data_attr + &quot;=&quot; + prop_name + &quot;]&quot;), tag_name; for(var i = 0, len = elements.length; i &lt; len; i++) &#123; tag_name = elements[i].tagName.toLowerCase(); if(tag_name === &quot;input&quot; || tag_name === &quot;textarea&quot; || tag_name === &quot;select&quot;) &#123; elements[i].value = new_val; &#125; else &#123; elements[i].innerHTML = new_val; &#125; &#125; &#125;); return pubSub; &#125; function DBind(uid) &#123; var binder = new DataBinder(uid), user = &#123; // ... attributes: &#123;&#125;, set: function(attr_name, val) &#123; this.attributes[attr_name] = val; // Use the `publish` method binder.publish(uid + &quot;:input&quot;, attr_name, val, this); &#125;, get: function(attr_name) &#123; return this.attributes[attr_name]; &#125;, _binder: binder &#125;; // Subscribe to the PubSub binder.on(uid + &quot;:input&quot;, function(evt, attr_name, new_val, initiator) &#123; if(initiator !== user) &#123; user.set(attr_name, new_val); &#125; &#125;); return user; &#125; var DBind = new DBind(1); DBind.set(&quot;name&quot;, &quot;黄奇&quot;);&lt;/script&gt; vue的实现1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!--1. 引入js文件--&gt; &lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--2. 视图 view--&gt; &lt;div id=&quot;app&quot;&gt; &lt;h4&gt;数据双向绑定----vue&lt;/h4&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;message&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;message&quot; /&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;//数据模型var dataModel = &#123; message: &quot;hello&quot;&#125;//viewModel ----连接视图和数据模型var app = new Vue(&#123; el: &quot;#app&quot;, data: dataModel&#125;)&lt;/script&gt; Vue是什么描述(vue的发展史) 概念123456vue是一个构建用户界面的框架(库),它的目标是通过尽可能简单的api实现响应的数据绑定和组合的视图集合vue自身不是一个全能框架的核心是只关注视图层,因此它非常容易学习，非常容易与其它库或已有项目整合vue在与相关工具和支持库一起使用时, 也能完美地驱动复杂的单页应用,在之后的课程中,我们会配合webpack来使用 特点响应的数据绑定/响应式编程 保持状态和数据的同步 1234567891011Vue.js 的核心是一个响应的数据绑定系统，它让数据与 DOM 保持同步非常简单。在使用 jQuery 手工操作 DOM时，我们的代码常常是命令式的、重复的与易错的。Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM“绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM更新搅在一起。这让我们的代码更容易撰写、理解与维护。 组件化123组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 为什么要用Vue.js优点轻量级的框架1只关注视图层,是一个构建数据驱动的视图集合,大小只有几十kb 简单易学1国人开发,中文文档,不存在语言障碍,易于理解与学习 双向数据绑定12保留了angular的优点在数据操作方面变得更为简单,极大的解放了dom操作(通过属性绑定的形式来实现) 组件化12保留了 react框架的优点实现html的封装,重用,在构建单页面应用方面有独特的优势 视图,数据,结构分离1使得数据的更改变得非常简单,不需要进行逻辑代码的修改,只需要操作数据就能够完成相关的操作 虚拟DOM12dom操作是非常耗费性能的不再使用原生的dom操作节点,极大解放dom操作,但具体操作的还是dom,只不过是换了另外一种方式 运行速度更快1相比较react而言,同样都是操作虚拟dom,就性能而言,vue存在很大的优势(了解) 缺点/了解支持特性 作为一个新兴的前端框架,在支持特性方面存在一些问题 123浏览器端: 抛弃了对IE9以下版本的支持android: 4.2 + ios: ios 7+ 前后端混合受限 在使用后端的 模板引擎渲染的项目中,vue会受到一定的限制 vue只能和后端的模板文件混合在一起,获取的后端数据也依赖于后端的渲染,在处理json对象和数组的时候会很麻烦 MVVM模式简介概述123456789大致可以分为三个部分:1. M: model,模型,在这里指的是数据模型2. V: view,视图,在这里指的就是我们写的页面3. VM ViewModel,是数据模型和视图连接的纽带(桥梁) 我们要把数据模型上面的数据绑定到视图上,要通过这个纽带(桥梁)来实现 图解 第一个vue案例vue的安装兼容1兼容性提示： Vue.js 不支持 IE8 及其以下版本。 版本12341. 开发版本: 包含完整的警告和调试2. 生产版本: 删除了警告 使用 使用本地的vue.js 存在的缺点 需要提前进行下载使用的时候受本地路径的限制,如果路径引入错误,会报错 也可以使用cdn加速服务,在有网络的情况下,直接引入12&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&gt; 存在的缺点 没有网络的时候没法使用 还有另外一种使用的方式,就是在项目模板中使用,关于这一部分内容,稍后进行讲解 实例12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue入门之Helloworld&lt;/title&gt; &lt;!--第1步：引入Vue库--&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--第2步: 通过id属性设置视图的入口--&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--Vue的模板的绑定数据的方法， 类似于很多其他前端的模板，可以用两对花括号进行绑定Vue中的数据对象的属性 --&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;script&gt; //第3步：创建模型数据 var modelData = &#123; message: &apos;Hello Vue!&apos; &#125; //第4步: 创建vue对象 var app = new Vue(&#123; // 创建Vue对象。Vue的核心对象。 el: &apos;#app&apos;, // el属性：把当前Vue对象挂载到 div标签上，#app是id选择器 data: modelData// data: 是Vue对象中绑定的数据模型 &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"01-vue入门","slug":"vue/01-vue入门","permalink":"http://yoursite.com/categories/vue/01-vue入门/"}],"tags":[]},{"title":"WebSocket","slug":"杂项/99-2-websocket","date":"2018-05-10T00:36:28.979Z","updated":"2018-05-10T01:06:30.397Z","comments":true,"path":"2018/05/10/杂项/99-2-websocket/","link":"","permalink":"http://yoursite.com/2018/05/10/杂项/99-2-websocket/","excerpt":"","text":"WebSocket详情查看链接","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[]},{"title":"跨域问题解决方案","slug":"杂项/99-1-cros-proxy-jsonp","date":"2018-05-10T00:36:28.970Z","updated":"2018-05-10T01:06:08.914Z","comments":true,"path":"2018/05/10/杂项/99-1-cros-proxy-jsonp/","link":"","permalink":"http://yoursite.com/2018/05/10/杂项/99-1-cros-proxy-jsonp/","excerpt":"","text":"跨域问题解决方案反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 基本使用1.在项目的根目录下创建一个proxy.config.json文件 内容如下: 12345&#123; &quot;**&quot;:&#123; &quot;target&quot;:&quot;http://127.0.0.1:8800&quot; &#125;&#125; 2.修改package.json文件 更改启动项 1ng serve --proxy-config proxy.config.json 3.配置根模块 12345import &#123;HttpModule&#125; from &quot;@angular/http&quot;imports: [ HttpModule] 4.使用http 三步操作 12345678910111213141. 导入http import &#123;Http&#125; from &quot;@angular/http&quot;2. 注入到构造函数 constructor(public http:Http) &#123;&#125;3. 调用方法 ngOnInit()&#123; var url = &quot;/test&quot; this.http.get(url) .subscribe((res)=&gt;&#123; console.log(res.json()) &#125;) &#125; 5.使用express框架,配置node服务,提供接口 123456789101112131415161718const express = require(&quot;express&quot;);const app = express();let dataSet = [ &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;pengsuo&quot;,&quot;age&quot;:20&#125;, &#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;chenqian&quot;,&quot;age&quot;:34&#125;, &#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;mahao&quot;,&quot;age&quot;:30&#125;, &#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;chenbo&quot;,&quot;age&quot;:50&#125;];app.get(&quot;/test&quot;,(req,res)=&gt;&#123; res.json(dataSet);&#125;);app.listen(8800)console.log(&quot;http://127.0.0.1:8800&quot;) jsonpangular的jsonp模块1.配置根模块 123456import &#123;JsonpModule&#125; from &quot;@angular/http&quot;imports: [ JsonpModule] 2.使用jsonp 三步操作 12345678910111213141. 导入jsonp import &#123;Jsonp&#125; from &quot;@angular/http&quot;2. 注入到构造函数 constructor(public jsonp:Jsonp) &#123;&#125;3. 调用方法 ngOnInit()&#123; var url = &quot;http://127.0.0.1:8800/test?callback=JSONP_CALLBACK&quot; this.jsonp.get(url) .subscribe((res)=&gt;&#123; console.log(res.json()) &#125;) &#125; 3.服务器端代码书写 基于nodejs的express框架 12345678910111213141516171819const express = require(&quot;express&quot;);const app = express();let dataSet = [ &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;pengsuo&quot;,&quot;age&quot;:20&#125;, &#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;chenqian&quot;,&quot;age&quot;:34&#125;, &#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;mahao&quot;,&quot;age&quot;:30&#125;, &#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;chenbo&quot;,&quot;age&quot;:50&#125;];app.get(&quot;/test&quot;,(req,res)=&gt;&#123; res.jsonp(dataSet);&#125;);app.listen(8800)console.log(&quot;http://127.0.0.1:8800&quot;) jquery的ajax跨域12345678910111213$.ajax(&#123; type: &quot;get&quot;, url: &quot;http://127.0.0.1:8800/test?callback=?&quot;, async: true, success(data) &#123; console.log(data) &#125;, error(error)&#123; console.log(error) &#125;, //jsonpCallback: &quot;fn&quot;, dataType: &quot;jsonp&quot;&#125;); cros 服务器端设置跨域资源共享 详情参考此链接 nodejs 基于express框架 123456789101112app.all(&apos;*&apos;, (req, res, next) =&gt; &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;); res.setHeader(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;); next()&#125;); php12header(&quot;Access-Control-Allow-Origin: *&quot;); WebSocket","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[]},{"title":"移动端布局","slug":"杂项/88-1-flex+rem","date":"2018-05-10T00:36:28.962Z","updated":"2018-05-10T01:06:05.052Z","comments":true,"path":"2018/05/10/杂项/88-1-flex+rem/","link":"","permalink":"http://yoursite.com/2018/05/10/杂项/88-1-flex+rem/","excerpt":"","text":"移动端布局 使用淘宝团队开发的适配方案 flexible 也就是手淘的H5多终端适配方案 flexible参考链接 使用的方式1.开启移动端布局1234// 设置meta&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; 2.引用多终端适配方案1234// 多终端适配&lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt; 3.设置像素转化 将设计稿上的px 像素单位转化为 css 的 rem 布局方案 也就是px和rem的转化比例 123456789设计稿: 750 -----&gt; 转化比例 75设计稿: 640 -----&gt; 转化比例 64 在hbuild中内置px转rem工具,如果找不到以下选项,建议更新hbuild版本 菜单栏----&gt; 工具 ----&gt; 选项 ----&gt; Hbuild ----&gt; 代码助手设置 ----&gt; 启动px转rem自动提示","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[]},{"title":"04-微信小程序组件","slug":"weChat/04-组件","date":"2018-05-10T00:36:28.951Z","updated":"2018-05-10T01:07:58.863Z","comments":true,"path":"2018/05/10/weChat/04-组件/","link":"","permalink":"http://yoursite.com/2018/05/10/weChat/04-组件/","excerpt":"","text":"微信小程序组件 框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。","categories":[{"name":"weChat","slug":"weChat","permalink":"http://yoursite.com/categories/weChat/"}],"tags":[]},{"title":"03-小程序开发实战","slug":"weChat/03-豆瓣电影的基本实现","date":"2018-05-10T00:36:28.942Z","updated":"2018-05-10T01:08:13.288Z","comments":true,"path":"2018/05/10/weChat/03-豆瓣电影的基本实现/","link":"","permalink":"http://yoursite.com/2018/05/10/weChat/03-豆瓣电影的基本实现/","excerpt":"","text":"小程序开发实战–豆瓣电影项目配置 在项目的app.json文件中完成配置 12 微信小程序访问豆瓣电影api400错误解决方法","categories":[{"name":"weChat","slug":"weChat","permalink":"http://yoursite.com/categories/weChat/"}],"tags":[]},{"title":"02-基础知识点","slug":"weChat/02-基本知识点","date":"2018-05-10T00:36:28.932Z","updated":"2018-05-10T01:08:08.643Z","comments":true,"path":"2018/05/10/weChat/02-基本知识点/","link":"","permalink":"http://yoursite.com/2018/05/10/weChat/02-基本知识点/","excerpt":"","text":"基础知识点数据展示语法1&#123;&#123;msg&#125;&#125; 列表渲染123&lt;view wx:for=&quot;&#123;&#123;arr&#125;&#125;&quot;&gt; &lt;text&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt;&lt;/view&gt; 解析 arr: 渲染的数据 item: 当前循环的内容 索引值添加 123&lt;view wx:for=&quot;&#123;&#123;items&#125;&#125;&quot; wx:for-index=&quot;index&quot; wx:for-item=&quot;item&quot;&gt;&#123;&#123;index+1&#125;&#125;、&#123;&#123;item.title&#125;&#125;&lt;/view&gt; 数据的添加和修改数据的添加 和vue的数据模型没有太大差别 1234data: &#123; message: &quot;hello world&quot;, arr:[]&#125; 数据的修改123456//在生命周期钩子中修改数据onLoad() &#123; //在这里修改页面数据 ---- 不能使用this.data.message,小程序捕获不到 this.setData(&#123; message: Date.now()&#125;) 接口的调用123456789101112131415161718 //不能使用ajax的方式调取数据(BOM),应该使用微信官方提供的api wx.request(&#123; url: &apos;https://api.douban.com/v2/movie/in_theaters&apos;, data: &#123; &apos;count&apos;:5 &#125;, header: &#123; // &apos;content-type&apos;: &apos;application/json&apos; // 默认值 &quot;Content-Type&quot;: &quot;json&quot; &#125;, success: (res) =&gt; &#123; console.log(res) // this.setData(&#123; // arr : res.data.playlist.tracks // &#125;) &#125; &#125;)&#125; 事件绑定12&lt;view&gt;&#123;&#123; msg &#125;&#125;&lt;/view&gt;&lt;button bindtap=&quot;clickMe&quot;&gt;点击我&lt;/button&gt;","categories":[{"name":"weChat","slug":"weChat","permalink":"http://yoursite.com/categories/weChat/"}],"tags":[]},{"title":"01-微信小程序入门","slug":"weChat/01-入门","date":"2018-05-10T00:36:28.924Z","updated":"2018-05-10T01:08:03.992Z","comments":true,"path":"2018/05/10/weChat/01-入门/","link":"","permalink":"http://yoursite.com/2018/05/10/weChat/01-入门/","excerpt":"","text":"微信小程序入门萨芬给谁发的规范和 必备知识121. 需要会html--css--js,但不是必备2. 更好的话react vue 项目目录结构解析 详解 1.app.js: 定义应用程序的主逻辑 定义全部逻辑 12345678910111213//使用App构造方法创建应用程序App(&#123; //小程序启动之后.onLaunch方法会执行 onLaunch()&#123; &#125;, //定义全局的fn方法----这个方法可以看成是共享的 fn()&#123; console.log(1) &#125;&#125;) 2.app.json : 应用程序全局配置 包含页面配置项和系统配置项等内容 123456789101112&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &#125;&#125; 3.app.wxss 配置全局的样式 12345678910/**app.wxss**/.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box;&#125; 4.project.config.json 项目配置,可以设置一些个性化的内容,可以快速进行项目的个性化设置 文件/页面 页面结构解析 为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。 1.index.js : 定义页面的逻辑 123456789101112//获取应用程序的实例var app = getApp()//Page就是一个页面构造器,用于创建页面Page(&#123; data: &#123; // 参与页面渲染的数据 logs: [] &#125;, onLoad: function () &#123; // 页面渲染后 执行 &#125;&#125;) 2.index.json 文件配置项 3.index.wxml 页面内容,相当于html部分 4.index.wxss 页面样式,相当于css 小程序特色 小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。 框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。 1.响应的数据绑定,类似于angular和vue 2.组件化-提供丰富的组件 3.丰富的api,简化操作","categories":[{"name":"weChat","slug":"weChat","permalink":"http://yoursite.com/categories/weChat/"}],"tags":[]},{"title":"22-核心知识点","slug":"angular2/999-核心知识点","date":"2018-05-10T00:36:05.077Z","updated":"2018-05-10T01:31:39.299Z","comments":true,"path":"2018/05/10/angular2/999-核心知识点/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/999-核心知识点/","excerpt":"","text":"核心知识点 组件 路由 数据请求 服务 模块 难点 组件通信 服务的使用 路由守卫,异步模块加载…… 依赖注入 rxjs 具体内容详见图谱","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"21-angular优质学习资源","slug":"angular2/300-3-优质学习资源收集","date":"2018-05-10T00:36:05.073Z","updated":"2018-05-10T01:31:31.420Z","comments":true,"path":"2018/05/10/angular2/300-3-优质学习资源收集/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/300-3-优质学习资源收集/","excerpt":"","text":"angular优质学习资源文档博客书籍类官方网站： https://angular.io angular官方源码库 https://github.com/angular/angular 中文站点： https://angular.cn Victor的blog（Victor是Angular路由模块的作者）： https://vsavkin.com/@vsavkin Todd Motto的Blog： https://toddmotto.com/ ThoughtRAM上的Blog频道： https://blog.thoughtram.io/categories/angular-2/ Angular University： http://blog.angular-university.io/ Deborah’s Developer MindScape： http://blogs.msmvps.com/deborahk/ Jason Watmore’s Blog： http://jasonwatmore.com/ RxJS官方网站： http://reactivex.io/ RxJS中文版文档（这是我看过的最好的关于RxJS的中文文档，注意，没有之一！向译者致敬！）： https://www.gitbook.com/book/buctwbzs/rxjs/details 一本开源的Angular2书籍：https://zhangchen915.gitbooks.io/angular2-training/ 开源项目类Angular Angury项目： https://augury.angular.io/ Angular Team在github上的地址： https://github.com/angular ng2-bootstrap： https://ng-bootstrap.github.io/#/home NGPrime： http://www.primefaces.org/primeng/#/ Angular-Material2： https://github.com/angular/material2 KendoUI：http://www.telerik.com/blogs/what-to-expect-in-2016-for-kendo-ui-with-angular-2-and-more ionic： https://ionic.io/ 一个非常好的管理后台项目（那些拿Angular来做管理系统的朋友，请务必看这个项目，它是非常好的后台管理界面模板，而且是开源免费的）： https://github.com/akveo/ng2-admin 一个很好的Blog项目： https://github.com/WittBulter/sails-blog-frontend RxJS聊天室： https://github.com/ng-book/angular2-rxjs-chat 教学用的项目NiceFish： http://git.oschina.net/mumu-osc/NiceFish GitHub上搜索Angular相关资源的更好方法：https://github.com/search?utf8=%E2%9C%93&amp;q=topic%3Aangular&amp;type=Repositories&amp;ref=searchresults 一组Angular2应用收集：http://angularexpo.com/ 一组UI库：https://teradata.github.io/covalent/#/ 一个非常好的入门项目： https://github.com/AngularClass/angular2-webpack-starter 基于Angular 1.x+Bootstrap的后台管理模板项目：https://github.com/akveo/blur-admin NiceFish（美人鱼）是一个系列教学项目 https://gitee.com/mumu-osc/NiceFishNiceFish-openChina http://git.oschina.net/mumu-osc/NiceFish webpack-angular-aot https://github.com/kunl/Angular-webpack-AOT codebe/钟钟,一个整合各种插件的项目 https://gitee.com/zt_zhong/CodeBe 视频类一个非常好的RxJS教学视频（想快速学会RxJS的朋友请务必仔细看完这个视频）： https://coryrylan.com/blog/introduction-to-rxjs-observables-and-angular 关于RxJS的更多视频（RxJS官方出的）： https://egghead.io/lessons/rxjs-rxjs-observables-vs-promises 油管上的AngularConnect频道： https://www.youtube.com/channel/UCzrskTiT_ObAk3xBkVxMz5g 油管上的ng-conf频道： https://www.youtube.com/user/ngconfvideos angular1大漠视频教程 http://www.imooc.com/learn/156 优酷频道 http://i.youku.com/i/UMzI1MjQ0MDgw/videos?spm=a2hzp.8253876.0.0","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"20-ui库","slug":"angular2/300-2-angular-ui库","date":"2018-05-10T00:36:05.070Z","updated":"2018-05-10T01:31:23.613Z","comments":true,"path":"2018/05/10/angular2/300-2-angular-ui库/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/300-2-angular-ui库/","excerpt":"","text":"angular ui库12Angular-Material,Prime-NG,ng2-bootstrap,ionic ng2-bootstrap官方文档链接地址 PrimeNG官方文档链接地址 Angular-Material2官方文档链接地址 Ionic官方文档链接地址","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"19-angular核心","slug":"angular2/300-1-核心概念","date":"2018-05-10T00:36:05.067Z","updated":"2018-05-10T01:31:16.296Z","comments":true,"path":"2018/05/10/angular2/300-1-核心概念/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/300-1-核心概念/","excerpt":"","text":"angular核心三大核心概念 Component,Module,Route 组件化组件树与视图变更检测机制 组件树 数据变更检测机制 在angular1中使用的是数据双向绑定,利用脏值检测机制,每次当有内容发生变化的时候,都会检测整个应用程序,造成很大的性能上的浪费 在angular2以及以上版本中,抛弃了脏值检测的方式,而改用单项数据流,当内容发生变化的时候,不会检测整个组件树,只会检测当前分支 参考链接 github官网-angular数据流 模块化 类似于组件化,可以实现项目的按功能模块进行划分 123451. 应用程序的功能(业务)模块划分,使用根模块进行统一管理2. 模块内部可以包含组件,指令,管道,路由,服务......3. 配合路由操作可以实现按需加载 ----- 类似于vue的组件懒加载 在angular应用程序中,只有ngModule模块装饰器来定义一个模块,这样做的意义在哪? 在开发过程中,我们需要根据业务模块在应用程序开发的过程中,进行模块化的划分,但是在在项目打包的时候,我们需要在文件的体积和请求的次数之间进行一个权衡 模块划分 模块划分当然是越详细越好,有利于项目的二次开发和代码的维护 请求次数 每个模块(打包后的js文件)都会发送一次http请求 我们可以在控制台的network查看具体的请求 模块划分和请求次数的权衡 需要根据实际需求在两者之间找到一个平衡点 路由 我们可以使用路由操作配合模块化实现异步模块加载 1.静态路由 2.异步路由 Angular核心架构思想依赖注入DI123451.每一个HTML标签上面都会有一个注射器实例2.注射是通过constructor进行的3.@Injectable是@Component的子类 依赖注入的具体实现可以参考一下链接 依赖注入的实现机制1依赖注入的实现机制1 数据绑定数据绑定的具体实现可以参考一下链接 数据绑定的实现1数据绑定的实现2","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"18-自动化测试","slug":"angular2/18-自动化测试","date":"2018-05-10T00:36:05.061Z","updated":"2018-05-10T01:31:04.420Z","comments":true,"path":"2018/05/10/angular2/18-自动化测试/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/18-自动化测试/","excerpt":"","text":"自动化测试单元测试mooc网视频教程 http://www.imooc.com/video/2638 karma 和 jasmine Karma+Jasmine可以用于任意前端框架 集成测试中文视频和详细的语法解释：http://www.imooc.com/video/4361 Protractor是专门针对Angular设计的 http://www.protractortest.org/#/ 前端测试神器F2etest是一个面向前端、测试、产品等岗位的多浏览器兼容性测试整体解决方案https://github.com/alibaba/f2etest http://f2etest.com/","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"17-i18n","slug":"angular2/17-i18n-国际化","date":"2018-05-10T00:36:05.058Z","updated":"2018-05-10T01:30:55.453Z","comments":true,"path":"2018/05/10/angular2/17-i18n-国际化/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/17-i18n-国际化/","excerpt":"","text":"i18n 国际化,让我们的应用支持多种语言","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"16-自定义指令","slug":"angular2/16-指令","date":"2018-05-10T00:36:05.055Z","updated":"2018-05-10T01:30:46.204Z","comments":true,"path":"2018/05/10/angular2/16-指令/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/16-指令/","excerpt":"","text":"自定义指令 —- 陌陌详情参考此链接 在angular中指令有两种： 123属性型指令：比如 ngClass ngStyle 等 修改宿主元素的样式或行为等结构型指令，比如 *ngIf，*ngFor 修改DOM结构。 自定义指令的实现创建指令 我们创建一个test指令： 1ng g directive directive/test 对于指令，会生成两个文件： 12test.directive.ts test.directive.spec.ts 文件模板 12345678910import &#123; Directive &#125; from &apos;@angular/core&apos;;@Directive(&#123; selector: &apos;[appTest]&apos;&#125;)export class TestDirective &#123; constructor() &#123; &#125;&#125; 自定义属性型指令 自定义属性型指令,完成类样式的添加 12345678910111213import &#123; Directive, ElementRef, AfterViewInit, Renderer2 &#125; from &apos;@angular/core&apos;; @Directive(&#123; selector: &apos;[appButton]&apos; &#125;) export class ButtonDirective implements AfterViewInit&#123; constructor(private er: ElementRef, private renderer2: Renderer2) &#123; &#125; ngAfterViewInit() &#123; this.renderer2.addClass(this.er.nativeElement, &apos;btn&apos;); &#125; &#125; 具体使用 12&lt;button appButton&gt;指令按钮/button&gt; 自定义结构型指令 自定义一个实现*ngIf功能的指令 123456789101112131415161718import &#123; Directive, Input, ViewContainerRef, TemplateRef &#125; from &apos;@angular/core&apos;; @Directive(&#123; selector: &apos;[appMyIf]&apos; &#125;) export class MyIfDirective &#123; constructor(private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef) &#123; &#125; @Input() set appMyIf(condition: boolean) &#123; if (condition) &#123; this.viewContainer.createEmbeddedView(this.templateRef); &#125; else &#123; this.viewContainer.clear(); &#125; &#125; &#125; 具体使用 1&lt;div *appMyIf=&quot;isMyShow&quot;&gt;自定义结构型指令appMyIf&lt;/div&gt;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"15-动画","slug":"angular2/15-动画","date":"2018-05-10T00:36:05.052Z","updated":"2018-05-10T01:30:39.204Z","comments":true,"path":"2018/05/10/angular2/15-动画/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/15-动画/","excerpt":"","text":"动画动画模块安装 Angular4后动画模块分离出来了 12npm install @angular/animations --save","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"14-表单处理","slug":"angular2/14-表单","date":"2018-05-10T00:36:05.037Z","updated":"2018-05-10T01:30:31.358Z","comments":true,"path":"2018/05/10/angular2/14-表单/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/14-表单/","excerpt":"","text":"表单处理以前学过的表单1.基本的html表单 123456&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;div&gt;用户名: &lt;input type=&quot;text&quot;/&gt;&lt;/div&gt; &lt;div&gt;密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;div&gt;确认密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 2.html5表单 在原先表单的基础上,添加了一些简单的验证,并添加了一些新的输入类型和表单元素 新增的表单输入类型 12345678910111213colordatedatetimedatetime-localemailmonthnumberrangesearchteltimeurlweek 新增的表单元素 123&lt;datalist&gt;&lt;keygen&gt;&lt;output&gt; 新增的输入类型的属性 12345678910111213141516autocompleteautofocusactionenctypemethodnovalidatetargetheight and width height 和 width 属性只适用于 image 类型的&lt;input&gt; 标签。listmin and maxmultiplepattern (regexp)placeholderrequiredstep 123456&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;div&gt;用户名: &lt;input type=&quot;text&quot; required=&quot;required&quot;/&gt;&lt;/div&gt; &lt;div&gt;密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;div&gt;确认密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 在ng2Pro中的表单模板式表单 在ng2Pro中在原先表单的继承上,添加了一些新的功能,通过指令的形式实现 模板驱动表单中,所有的验证逻辑都写在表单里面 1.使用angular表单,需要先导入FormsModule 123451.导入表单模块 import &#123; FormsModule &#125; from &apos;@angular/forms&apos;;2. 放到模块装饰器的imports中 imports:[FormsModule] 2.取消了submit的默认提交事件 只有在添加ngNoForm的时候才会还原表单默认的提交事件 123456&lt;form action=&quot;/login&quot; method=&quot;post&quot; ngNoForm&gt; &lt;div&gt;用户名: &lt;input type=&quot;text&quot; required=&quot;required&quot;/&gt;&lt;/div&gt; &lt;div&gt;密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;div&gt;确认密码: &lt;input type=&quot;password&quot; /&gt;&lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 3.表单的使用比原先学习的方式更加便捷 在这里使用到了一些知识点 12345678910111. #myForm表示一个本地变量,你可以理解为就像vue中虚拟dom那样,能够直接获取到当前的标签,但是只能在当前页面使用2. ngForm指令你可以理解为表示的整个表单,其value属性值表示的是表单里面标识有name属性的所有的value值 但是ngForm不能够直接去使用(隐式创建了一个FormGroup类的实例,包含了表单内部的value值)3. #myForm=&apos;ngForm&apos;就是一个简单的赋值操作,使用本地变量的形式得到--angular--表单内部的Value值4. 在表单内部,可以直接使用ngModel来获取到表单内部的value值来添加到设置的name属性上(后面会有效果的演示) 注意: 在这里不能使用[(ngModel)]5. ngSubmit事件 其实就是--angular--表单的提交事件,可以理解为重命名了一下 实现的效果如下 3.ngModelGroup的使用 可以用于处理复杂的表单 结构层次上更加清晰 响应式表单 响应式表单的类名和指令如下图所示 将功能代码书写到代码中进行实现,简化页面的html结构 123456FormControl 用于跟踪一个单独的表单控件的值和有效性状态。它对应于一个HTML表单控件，比如输入框和下拉框。FormGroup 用于 跟踪一组AbstractControl的实例的值和有效性状态。 该组的属性中包含了它的子控件。 组件中的顶级表单就是一个FormGroup。FormArray 用于跟踪AbstractControl实例组成的有序数组的值和有效性状态。 1.FormControl 2.FormGroup和FormArray 如果有多个FormControl，我们会希望把它们注册进一个父FormGroup中 同样,如果有多个FormController,我们可以把它放到一个FormArray中 最终FormArray是要放到FormGroup中的 动态表单 根据数据去动态的生成表单 表单几乎都是使用代码创建的 表单验证 Angular使用ngModel和name属性构建了一个FormControl，这也是我们可以通过NgForm.controls获取里面所有具有name属性的表单，它是一个数组。 而对于每一个FormControl，它都有以下验证属性： 内置的一些校验规则 12345678requiredrequiredTrueminLengthmaxLengthpatternnullValidatorcomposecomposeAsync 基本验证123456789101112&lt;div&gt; &lt;label&gt; 性别： &lt;select [(ngModel)]=&quot;sex&quot; name=&quot;sex&quot; required #sexInput=&quot;ngModel&quot;&gt; &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;p *ngIf=&quot;sexInput.invalid&quot; class=&quot;error&quot;&gt;不合法&lt;/p&gt; &lt;p *ngIf=&quot;sexInput.errors?.required&quot;&gt;失败显示的内容&lt;/p&gt;&lt;/div&gt; 能力提升1234567891011121314151617181920212223242526&lt;div class=&quot;box&quot;&gt; &lt;form #userForm=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(userForm.form.valid)&quot; novalidate&gt; &lt;div&gt; &lt;label&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;name&quot; [(ngModel)]=&quot;name&quot; required&gt; &lt;/label&gt; &lt;p *ngIf=&quot;userForm.controls[&apos;name&apos;]?.invalid&quot; class=&quot;error&quot;&gt;用户名必填&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt; 电话：&lt;input type=&quot;text&quot; name=&quot;tel&quot; [(ngModel)]=&quot;tel&quot; pattern=&quot;1[3|5|8]\\d&#123;9&#125;&quot; required&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt; 性别： &lt;select [(ngModel)]=&quot;sex&quot; name=&quot;sex&quot; required&gt; &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;p *ngIf=&quot;userForm.controls[&apos;sex&apos;]?.errors?.required&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; [disabled]=&quot;!userForm.form.valid&quot;&gt;发布&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"13-服务","slug":"angular2/13-服务","date":"2018-05-10T00:36:05.033Z","updated":"2018-05-10T01:30:17.894Z","comments":true,"path":"2018/05/10/angular2/13-服务/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/13-服务/","excerpt":"","text":"服务 封装了一项功能,并且可以通过注入的方式供其他使用的独立模块 服务可以分为很多种—-包括值,函数以及其他特性 如果在项目中有一段代码是很多组件都要使用的，那么最好的方式就是把它做成服务。 服务是一种在组件中共享功能的机制，当我们使用标签将多个组件组合在一起时我们需要操作一些数据或是需要做一些运算时，我们需要做一个服务；服务能帮我们引入外部的数据 old服务的种类 服务分为很多种，包括：值、函数，以及应用所需的特性。 以下是几种常见的服务： 12345日志服务数据服务消息总线税款计算器应用程序配置 服务的生成(基本使用)1.创建服务 1ng g service serviceName/file 2.提供服务 提供的服务需要在app.module.ts中显式声明 123451.先导入 import &#123; HeroService &#125; from &apos;./hero.service&apos;;2.再声明 providers: [HeroService], 3.服务实现的功能 也就是说这个服务是做什么的 以一个提供数据的服务为例 4.使用服务 服务的应用12345日志服务数据服务消息总线税款计算器应用程序配置 数据服务 将项目中使用到的相关数据获取的操作都分离出来,做成一个可复用的可注入的服务 1.定义服务Appservice 首先使用命令行生成一个服务 ng g service service/app 123456789101112131415161718192021import &#123;Injectable&#125; from &quot;@angular/core&quot;;import &#123;Http, Jsonp&#125; from &quot;@angular/http&quot;;import &quot;rxjs/add/operator/map&quot;;@Injectable()export class AppService &#123; constructor(public http:Http, public jsonp:Jsonp) &#123; &#125; // http.get httpGet(url, params) &#123; return this.http.get(url, &#123;search: params&#125;).map(result=&gt;result.json()); &#125; // http.post httpPost(url, params) &#123; return this.http.post(url, params).map(result=&gt;result.json()); &#125; // jsonp jsonpGet(url, params) &#123; return this.jsonp.get(url, &#123;search: params&#125;).map(result=&gt;result.json()); &#125;&#125; 2.定义组件,加载服务 1234567891011121314151617181920212223242526272829303132import &#123;Component, OnInit&#125; from &quot;@angular/core&quot;;// 获取路由传递传递过来的params(id) 增加模块激活的路由(ActivatedRoute)import &#123;ActivatedRoute&#125; from &quot;@angular/router&quot;;import &#123;AppService&#125; from &quot;./app.service&quot;;import &#123;URLSearchParams&#125; from &quot;@angular/http&quot;;@Component(&#123; selector: &quot;my-info&quot;, templateUrl: &quot;../templates/about-info.html&quot;, providers: [AppService]&#125;)export class AboutInfoComponent implements OnInit &#123; // 定义一个变量, 获取服务方法取得的数据 info:Number; data:Array&lt;Object&gt;; // 初始化变量, 这里必须加修饰词 public private, 初始化服务, 然后使用服务方法,调取数据 constructor(public infos:AppServer) &#123; &#125; // 方法中操作id, 通过id查询信息等等 ngOnInit()&#123; var url = &quot;http://localhost:3000/login&quot;; var params = new URLSearchParams(); params.set(&quot;id&quot;, &quot;1&quot;); // 传递过来的不是promise 所以要subscribe执行 this.infos.getHttp(url, params).subscribe(res=&gt; &#123; console.log(res); &#125; ); &#125;&#125; 3.服务的全局加载 上面组件中局部加载了这个服务， 如果需要全局导入服务 app.module.ts文件中 1providers: [AppService] 日志服务 以下实例是一个简单的日志服务，用于把日志记录到浏览器的控制台： 12345export class Logger &#123; log(msg: any) &#123; console.log(msg); &#125; error(msg: any) &#123; console.error(msg); &#125; warn(msg: any) &#123; console.warn(msg); &#125;&#125; new基本使用1.生成服务 12ng g service service/data 2.基本模板 建议每一个服务都加上@Injectable()装饰器。 注意： 当 TypeScript 看到@Injectable()装饰器时，就会记下本服务的元数据。 如果 Angular 需要往这个服务中注入其它依赖，就会使用这些元数据。 12345678import &#123; Injectable &#125; from &apos;@angular/core&apos;;@Injectable()export class DataService &#123; constructor() &#123; &#125;&#125; 示例1 定义一个提供数据的服务 1. 定义本地json—-数据模拟 data.json 12345678910111213&#123; &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;HTML&quot; &#125;, &#123; &quot;name&quot;: &quot;Javascript&quot; &#125;, &#123; &quot;name&quot;: &quot;Angular&quot; &#125; ] &#125; 2.定义服务功能 123456789101112131415161718192021222324252627282930import &#123; Injectable &#125; from &apos;@angular/core&apos;;import &#123; Http &#125; from &apos;@angular/http&apos;;import &apos;rxjs/add/operator/toPromise&apos;; @Injectable()export class DataService &#123; constructor( public $http: Http ) &#123;&#125; getData() &#123; console.log(1) const url = &apos;./assets/data.json&apos;; return this.$http.get(url) .toPromise() .then(res =&gt; res.json()) .catch(this.handleError); &#125; private handleError(error: any): Promise&lt;any&gt; &#123; console.error(&apos;An error occurred&apos;, error); // for demo purposes only return Promise.reject(error.message || error); &#125;&#125; 3.使用服务 在这里是在当前组件使用 在这里必须使用异步的方式获取数据 12345678910111213141516171819202122232425262728import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123;DataService&#125; from &apos;../../service/data.service&apos;; @Component(&#123; selector: &apos;app-service-test&apos;, templateUrl: &apos;./service-test.component.html&apos;, styleUrls: [&apos;./service-test.component.css&apos;], providers: [DataService]&#125;)export class ServiceTestComponent implements OnInit &#123; constructor( public dataService:DataService ) &#123; &#125; ngOnInit() &#123; this.dataService.getData().then((res)=&gt;&#123; console.log(res) &#125;) &#125;&#125; 常用服务1.get 1234567891011get() &#123; return this.http.get(url) .toPromise() .then(response =&gt; response.json() ) .catch(this.handleError); &#125; private handleError(error: any): Promise&lt;any&gt; &#123; console.error(&apos;An error occurred&apos;, error); // for demo purposes only return Promise.reject(error.message || error); &#125; 2.post 123456789private headers = new Headers(&#123;&apos;Content-type&apos;: &apos;application/json&apos;&#125;); create() &#123; return this.http .post(url, JSON.stringify(hero), &#123;headers: this.headers&#125;) .toPromise() .then(response =&gt; response.json()) .catch(this.handleError); &#125; 3.update 12345678910private headers = new Headers(&#123;&apos;Content-type&apos;: &apos;application/json&apos;&#125;); update() &#123; return this.http .put(url, JSON.stringify(hero), &#123;headers: this.headers&#125;) .toPromise() .then(response =&gt; response.json()) .catch(this.handleError); &#125; 4.delete 123456789private headers = new Headers(&#123;&apos;Content-type&apos;: &apos;application/json&apos;&#125;); delete() &#123; return this.http .delete(url, &#123;headers: this.headers&#125;) .toPromise() .then(() =&gt; null) .catch(this.handleError); &#125;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"12-数据请求","slug":"angular2/12-数据请求","date":"2018-05-10T00:36:05.029Z","updated":"2018-05-10T01:30:06.999Z","comments":true,"path":"2018/05/10/angular2/12-数据请求/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/12-数据请求/","excerpt":"","text":"数据请求 在vue中进行数据请求使用的是vue-resource和axios这两个插件在angular中,对数据请求以模块化的方式进行了封装,封装到@angular/http模块中 我们在使用的时候,首先要导入这个模块,就像是vue中导入axios.js和vue-resource.js一样 数据请求的简单实现发送get请求大致过程可以分为以下几步 123456789101112131415161718192021222324252627282930311.导入请求模块,在angular中,使用什么东西首先要在app.module中导入 import &#123; HttpModule &#125; from &apos;@angular/http&apos;; 并将导入的模块添加到 @NgModule 的 imports中2.在需要的地方导入http模块,也就是说要在哪里发送请求,就在哪里导入http模块(类)即可 import &#123; Http &#125; from &apos;@angular/http&apos;; 3.将到如的模块注入到构造函数中 constructor(private $http: Http) &#123; &#125;4.发送请求,获取数据 ngOnInit() &#123; const url = &quot;http://127.0.0.1/00-exam/1508A/week1/select.php&quot; this.$http.get(url) //Angular 的http.get返回一个 RxJS 的Observable对象,在这里我们不需要关注这个对象是一个什么东西 //有一种提供好的方式也就是 toPromise()可以将这个Observable对象转化为我们所熟知的内容 .toPromise() .then((res)=&gt;&#123; //调用 HTTP 的Reponse对象的json方法，以提取出其中的数据 console.log(res.json()) //将我们读取到的数据赋值给数据并进行渲染就可以了 &#125;) //捕获错误 .catch((error)=&gt;&#123; console.log(error) &#125;) &#125; 图解 发送post请求大致过程可以分为以下几步 1234567891011121314151617181920212223242526272829301.导入请求模块,在angular中,使用什么东西首先要在app.module中导入 import &#123; HttpModule &#125; from &apos;@angular/http&apos;; 并将导入的模块添加到 @NgModule 的 imports中2. 在需要的地方导入http模块,也就是说要在哪里发送请求,就在哪里导入http模块(类)即可,此外,还需要URLSearchParams import &#123; Http , URLSearchParams &#125; from &apos;@angular/http&apos;;3. 注入到构造函数 constructor(public $http: Http) &#123;&#125;4. 发送请求 var url = &quot;http://127.0.0.1:8899/api/insertData&quot; let params = new URLSearchParams(); params.set(&apos;name&apos;, &apos;huge&apos;); params.set(&apos;sex&apos;, &apos;huge&apos;); params.set(&apos;email&apos;, &apos;huge&apos;); params.set(&apos;phone&apos;, &apos;huge&apos;); params.set(&apos;address&apos;, &apos;huge&apos;); this.$http.post(url, params) .toPromise() .then(res =&gt; &#123; console.log(res); &#125;) jquery 像vue那样,除了本身的数据请求方式之外,还可以使用其他的方式,比如我们的jquery jquery的使用可以参考配置教程* get请求 使用的时候代码按需修改 123456789var url = &quot;http://127.0.0.1:8899/api/getData&quot;$.ajax(&#123; type: &quot;get&quot;, url:url, success(data)&#123; console.log(data) &#125;&#125;) post请求 使用的时候代码部分按需修改 1234567891011121314151617var url = &quot;http://127.0.0.1:8899/api/insertData&quot;var body = &#123; name: &apos;this.name&apos;, sex: &apos;this.sex&apos;, email: &apos;this.email&apos;, phone: &apos;this.phone&apos;, address: &apos;this.address&apos;&#125;$.ajax(&#123; type: &quot;post&quot;, url:url, data:body, success(data)&#123; console.log(data) &#125;&#125;) jsonp-跨域 有的时候,一些接口是在默认情况下只能进行同源访问 在不同源进行访问的时候收到限制,需要使用跨域的方式 1234567891011//jquery-ajax的jsonp请求$.ajax(&#123; type: &quot;get&quot;, url: &quot;https://api.douban.com/v2/movie/top250&quot;, async: true, success(data) &#123; console.log(data) &#125;, jsonpCallback: &quot;fn&quot;, dataType: &quot;jsonp&quot;&#125;); 综合练习基本练习 微信1.案例效果图 题目描述 1234567891.路由模块引入2.路由正确传参3.正确引入http模块和服务4.首页页脚固定5.列表页面的数据请求和渲染6.点击不同用户进入不同的用户聊天窗口7.给点击发送注册正确的事件8.正确的使用双向数据绑定，并且引入正确的模块9.点击发送后正确的发送和接受数据 跨域问题解决方案反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 基本使用1.在项目的根目录下创建一个proxy.config.json文件 内容如下: 12345&#123; &quot;**&quot;:&#123; &quot;target&quot;:&quot;http://127.0.0.1:8800&quot; &#125;&#125; 2.修改package.json文件 更改启动项 1ng serve --proxy-config proxy.config.json 3.配置根模块 12345import &#123;HttpModule&#125; from &quot;@angular/http&quot;imports: [ HttpModule] 4.使用http 三步操作 12345678910111213141. 导入http import &#123;Http&#125; from &quot;@angular/http&quot;2. 注入到构造函数 constructor(public http:Http) &#123;&#125;3. 调用方法 ngOnInit()&#123; var url = &quot;/test&quot; this.http.get(url) .subscribe((res)=&gt;&#123; console.log(res.json()) &#125;) &#125; 5.使用express框架,配置node服务,提供接口 123456789101112131415161718const express = require(&quot;express&quot;);const app = express();let dataSet = [ &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;pengsuo&quot;,&quot;age&quot;:20&#125;, &#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;chenqian&quot;,&quot;age&quot;:34&#125;, &#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;mahao&quot;,&quot;age&quot;:30&#125;, &#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;chenbo&quot;,&quot;age&quot;:50&#125;];app.get(&quot;/test&quot;,(req,res)=&gt;&#123; res.json(dataSet);&#125;);app.listen(8800)console.log(&quot;http://127.0.0.1:8800&quot;) jsonpangular的jsonp模块1.配置根模块 123456import &#123;JsonpModule&#125; from &quot;@angular/http&quot;imports: [ JsonpModule] 2.使用jsonp 三步操作 12345678910111213141. 导入jsonp import &#123;Jsonp&#125; from &quot;@angular/http&quot;2. 注入到构造函数 constructor(public jsonp:Jsonp) &#123;&#125;3. 调用方法 ngOnInit()&#123; var url = &quot;http://127.0.0.1:8800/test?callback=JSONP_CALLBACK&quot; this.jsonp.get(url) .subscribe((res)=&gt;&#123; console.log(res.json()) &#125;) &#125; 3.服务器端代码书写 基于nodejs的express框架 12345678910111213141516171819const express = require(&quot;express&quot;);const app = express();let dataSet = [ &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;pengsuo&quot;,&quot;age&quot;:20&#125;, &#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;chenqian&quot;,&quot;age&quot;:34&#125;, &#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;mahao&quot;,&quot;age&quot;:30&#125;, &#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;chenbo&quot;,&quot;age&quot;:50&#125;];app.get(&quot;/test&quot;,(req,res)=&gt;&#123; res.jsonp(dataSet);&#125;);app.listen(8800)console.log(&quot;http://127.0.0.1:8800&quot;) jquery的ajax跨域12345678910111213$.ajax(&#123; type: &quot;get&quot;, url: &quot;http://127.0.0.1:8800/test?callback=?&quot;, async: true, success(data) &#123; console.log(data) &#125;, error(error)&#123; console.log(error) &#125;, //jsonpCallback: &quot;fn&quot;, dataType: &quot;jsonp&quot;&#125;); cros 服务器端设置跨域资源共享 详情参考此链接 nodejs 基于express框架 123456789101112app.all(&apos;*&apos;, (req, res, next) =&gt; &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;); res.setHeader(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;); next()&#125;); php12header(&quot;Access-Control-Allow-Origin: *&quot;); WebSocket","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"11-路由","slug":"angular2/11-路由操作","date":"2018-05-10T00:36:05.012Z","updated":"2018-05-10T01:29:59.417Z","comments":true,"path":"2018/05/10/angular2/11-路由操作/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/11-路由操作/","excerpt":"","text":"路由 和vue一样,在ng2Pro中也有路由操作 在vue中需要引入vue-router 在ng2Pro中的路由是将相关的操作一模块化的方式封装到一个类中,在使用的时候只需要导入对应的类即可 知识点概述 路由的基本实现 创建一个新的项目模板 1ng new router --routing 和vue一样,流程化操作即可 1234567891011121314151617181920212223242526272829303132331. 引入js / 导入js -----自动完成2. 组件的定义 创建组件----使用命令行的形式 ng g component tab1 ng g component tab2 导入组件 import &#123; Tab1Component &#125; from &apos;./tab1/tab1.component&apos;; import &#123; Tab2Component &#125; from &apos;./tab2/tab2.component&apos;;3. 路由的配置 const routes: Routes = [ &#123;path:&apos;tab1&apos;,component:Tab1Component&#125;, &#123;path:&apos;tab2&apos;,component:Tab2Component&#125; ]; 4. 路由的挂载----自动完成5. 导航的链接 //routerLink的值可以是一个字符串,便于在使用路由的时候传递参数 &lt;a routerLink=&quot;/demoComponent&quot;&gt;创建组件&lt;/a&gt; //routerLink的值可以是一个数组,便于在使用路由的时候传递参数 &lt;a [routerLink]=&quot;[&apos;/&apos;]&quot;&gt;主页&lt;/a&gt; &lt;a [routerLink]=&quot;[&apos;/product&apos;]&quot;&gt;商品详情页&lt;/a&gt; &lt;a [routerLink]=&quot;[&apos;/demoComponent&apos;, &#123; name: &apos;route&apos;, id: 123&#125;]&quot;&gt;商品详情页&lt;/a&gt;6. 组件的显示 显示组件内容的一个容器 &lt;router-outlet&gt;&lt;/router-outlet&gt; 具体实现 使用js控制路由跳转 和基本路由的实现一样,在这里只不过是将a简介跳转的形式换成一种使用js控制路由跳转 和之前相比有区别的地方 12345678910111. 导入路由对象 import &#123;Router&#125; from &apos;@angular/router&apos;2. 注入到构造函数 constructor(private router:Router)&#123;&#125;3. 使用navigate设置跳转的路由 this.router.navigate[&apos;/tab1&apos;] 路由参数和参数对象的获取实现的思路 和vue一样,在基本路由操作的基础上,只需要修改和路径相关的内容就可以了 12345678910111. 导入获取路由参数的对象 ---- ActivatedRoute import &#123;ActivatedRoute&#125; from &apos;@angular/router&apos; 2. 注入到构造函数 constructor(public routerInfo:ActivatedRoute) &#123; &#125;3. 使用snapshot这个对象的相关属性获取对应的参数和参数对象 参数的获取:params[&apos;id&apos;] this.routerInfo.snapshot.params[&apos;id&apos;] 参数对象的获取 this.routerInfo.snapshot.queryParams[&apos;id&apos;] 路由参数获取的另一种方式 上面使用的那一种是参数快照,还有一种是参数订阅的方式 参数订阅能够作什么? 123456 使用这种形式能够正确的获取到通过路由传递过来的参数,但是当当前路由跳转到当前路由的话会有问题 出现像参数快照那样的问题的原因是我们的ngOnInit生命周期钩子只会在创建当前组件的时候调用一次, 当前路由跳转到当前路由的时候,这个钩子不会重复执行使用参数订阅的方式能够解决当前路由跳转到当前路由的问题 参数快照和参数订阅的实现 路由通配符设置通配符号配置路由 每一个都会把一个URL路径(path)映射到一个组件 当所有其上面的路由路径都不符合(包括无效路径)时，就会采取通配符路由 12//当页面不存在的的时候,显示404页面 ---- 通配符这个路由要放到路由的最后面&#123;path:&apos;**&apos;,component:Code404Component&#125; 嵌套路由嵌套路由 重定向路由重定向123&#123;path:&apos;&apos;,component:HomeComponent&#125;,&#123;path:&apos;&apos;,redirectTo:&apos;/home&apos;,pathMatch:&apos;full&apos;&#125;,&#123;path:&apos;home&apos;,component:HomeComponent&#125;, routerLinkActive 一般情况下，我们会为当前激活的路径链接添加一些高亮效果，这时我们可以利用routerLinkActive属性 12345&lt;a routerLink=&quot;/demoComponent&quot; routerLinkActive=&quot;active&quot;&gt;创建组件&lt;/a&gt; 它的值是一个以空格分割的CSS样式类列表。 还可以是一个CSS类数组： [routerLinkActive]=&quot;[&apos;...&apos;]&quot; 注（来源官网）：RouterLinkActive指令会基于当前的RouterState对象来为激活的RouterLink切换CSS类。 这会一直沿着路由树往下进行级联处理，所以父路由链接和子路由链接可能会同时激活。 要改变这种行为，可以把[routerLinkActiveOptions]绑定到{exact: true}表达式。 如果使用了{ exact: true }那么只有在其URL与当前URL精确匹配时才会激活指定的RouterLink 补充12在特性模块中，应该使用RouterModule.forChild() 辅助路由 使用辅助路由可以实现多级视图的效果 1.路由链接和两个视图 1234567891011121314&lt;a [routerLink]=&quot;[&apos;/tab1&apos;]&quot;&gt;tab1&lt;/a&gt;&lt;a [routerLink]=&quot;[&apos;/tab2&apos;]&quot;&gt;tab2&lt;/a&gt;&lt;a [routerLink]=&quot;[&apos;/tab3&apos;]&quot;&gt;tab3&lt;/a&gt;&lt;a [routerLink]=&quot;[&apos;/tab4&apos;]&quot;&gt;tab4&lt;/a&gt;&lt;a [routerLink]=&quot;[&#123;outlets:&#123;aux:&apos;chat1&apos;&#125;&#125;]&quot;&gt;chat1&lt;/a&gt;&lt;a [routerLink]=&quot;[&#123;outlets:&#123;aux:&apos;chat2&apos;&#125;&#125;]&quot;&gt;chat2&lt;/a&gt; //将第二级视图绑定到tab1上 &lt;a [routerLink]=&quot;[&#123;outlets:&#123;primary:&apos;tab1&apos;,aux:&apos;chat2&apos;&#125;&#125;]&quot;&gt;chat2&lt;/a&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;router-outlet name=&apos;aux&apos;&gt;&lt;/router-outlet&gt; 2.路由信息定义 1234567891011121314151617181920212223242526272829import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;import &#123; Tab1Component &#125; from &apos;./component/tabs/tab1/tab1.component&apos;;import &#123; Tab2Component &#125; from &apos;./component/tabs/tab2/tab2.component&apos;;import &#123; Tab3Component &#125; from &apos;./component/tabs/tab3/tab3.component&apos;;import &#123; Tab4Component &#125; from &apos;./component/tabs/tab4/tab4.component&apos;;import &#123; Chat1Component &#125; from &apos;./component/chat/chat1/chat1.component&apos;;import &#123; Chat2Component &#125; from &apos;./component/chat/chat2/chat2.component&apos;;const routes: Routes = [ &#123;path:&quot;tab1&quot;,component:Tab1Component&#125;, &#123;path:&quot;tab2&quot;,component:Tab2Component&#125;, &#123;path:&quot;tab3&quot;,component:Tab3Component&#125;, &#123;path:&quot;tab4&quot;,component:Tab4Component&#125;, &#123;path:&quot;chat1&quot;,component:Chat1Component,outlet:&apos;aux&apos;&#125;, &#123;path:&quot;chat2&quot;,component:Chat2Component,outlet:&apos;aux&apos;&#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; 路由钩子/路由守卫任何用户都能在任何时候导航到任何地方。 但有时候这样是不对的。 考虑一下场景 123456789101. 该用户可能无权导航到目标组件。2. 可能用户得先登录（认证）。3. 在显示目标组件前，我们可能得先获取某些数据。4. 在离开组件前，我们可能要先保存修改。5. 我们可能要询问用户：你是否要放弃本次更改，而不用保存它们？ 路由守卫 123456789我们可以往路由配置中添加守卫，来处理这些场景。守卫返回一个值，以控制路由器的行为： 如果它返回true，导航过程会继续 如果它返回false，导航过程会终止，且用户会留在原地。 守卫还可以告诉路由器导航到别处，这样也取消当前的导航。 路由守卫的种类12345678910用CanActivate来处理导航到某路由的情况。用CanActivateChild来处理导航到某子路由的情况。用CanDeactivate来处理从当前路由离开的情况.用Resolve在路由激活之前获取路由数据。用CanLoad来处理异步导航到某特性模块的情况。 CanActivate的基本使用1.新建一个守卫 123456789101112131415161718 import &#123;CanActivate&#125; from &apos;@angular/router&apos; //使用angular router内置的接口CanActivate实现路由守卫 export class LoginGuard implements CanActivate &#123; canActivate()&#123; let loginIn:boolean = Math.random() &lt; 0.5 if(!loginIn) &#123; console.log(&quot;用户还没有登录&quot;) &#125; return loginIn &#125; &#125;` 2.在路由的配置文件中app-routing.module.ts使用守卫 1234567891011121314151617181920212223242526272829//1.导入定义好的路由守卫import &#123; LoginGuard &#125; from &apos;./guard/login.guard&apos;;//2.配置路由守卫const routes: Routes = [ &#123;path:&apos;&apos;,redirectTo:&apos;swiper&apos;,pathMatch:&apos;full&apos;&#125;, &#123;path:&apos;swiper&apos;,component:SwiperComponent&#125;, &#123;path:&apos;index&apos;,component:IndexComponent&#125;, &#123; path:&apos;tab2&apos;, component:Tab2Component, //路由进入的守卫 --- 可以执行多个路由守卫,---- 都满足的时候才能进行路由跳转 canActivate:[LoginGuard] &#125;, &#123;path:&apos;**&apos;,component:Error404Component&#125; ];//3.使用守卫----需要通过依赖注入的形式实现,也就是providers@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule], //路由守卫 providers:[LoginGuard]&#125;) CanDeactivate的基本使用1.新建一个守卫 1234567891011121314 import &#123;CanDeactivate&#125; from &apos;@angular/router&apos; import &#123; ProductComponent &#125; from &apos;../product/product.component&apos;; //导入路由离开时候的路由守卫 //泛型 指向当前组件的类型(也就是要保存的组件) export class UnsavedGuard implements CanDeactivate&lt;ProductComponent&gt;&#123; canDeactivate (component: ProductComponent)&#123; return window.confirm(&quot;你还没有保存,确定要离开吗?&quot;) &#125; &#125;` 2.在路由的配置文件中app-routing.module.ts使用守卫 1234567891011121314151617181920212223242526272829303132//1.导入定义好的路由守卫import &#123; LoginGuard &#125; from &apos;./guard/login.guard&apos;;import &#123; UnsavedGuard &#125; from &apos;./guard/unsaved.guard&apos;;//2.配置路由守卫const routes: Routes = [ &#123;path:&apos;&apos;,redirectTo:&apos;swiper&apos;,pathMatch:&apos;full&apos;&#125;, &#123;path:&apos;swiper&apos;,component:SwiperComponent&#125;, &#123;path:&apos;index&apos;,component:IndexComponent&#125;, &#123; path:&apos;tab2&apos;, component:Tab2Component, //路由进入的守卫 --- 可以执行多个路由守卫,---- 都满足的时候才能进行路由跳转 canActivate:[LoginGuard], //路由离开的守卫 canDeactivate:[UnsavedGuard], &#125;, &#123;path:&apos;**&apos;,component:Error404Component&#125; ];//3.使用守卫----需要通过依赖注入的形式实现,也就是providers@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule,UnsavedGuard], //路由守卫 providers:[LoginGuard]&#125;) Resolve: 预先获取组件数据123456789101112在Hero Detail和Crisis Detail中，它们等待路由读取完对应的英雄和危机。In the Hero Detail and Crisis Detail, the app waited until the route was activated to fetch the respective hero or crisis.这种方式没有问题，但是它们还有进步的空间。 如果我们在使用真实api，很有可能数据返回有延迟，导致无法即时显示。 在这种情况下，直到数据到达前，显示一个空的组件不是最好的用户体验。我们最好预先从服务器上获取完数据，这样在路由激活的那一刻数据就准备好了。 还要在路由到此组件之前处理好错误。 但当某个id无法对应到一个危机详情时，我们没办法处理它。 这时我们最好把用户带回到“危机列表”中，那里显示了所有有效的“危机”。总之，你希望的是只有当所有必要数据都已经拿到之后，才渲染这个路由组件。我们需要Resolve守卫。 1.创建守卫 12345678910111213141516171819202122232425262728293031import &#123;Resolve,ActivatedRouteSnapshot,RouterStateSnapshot,Router&#125; from &apos;@angular/router&apos;import &#123; Product &#125; from &apos;../product/product.component&apos;;import &#123;Observable&#125; from &apos;rxjs&apos;import &#123;Injectable&#125; from &apos;@angular/core&apos;//使用Injectable装饰器装饰 生成服务@Injectable()export class Test implements Resolve&lt;Product&gt;&#123; constructor(private router:Router)&#123;&#125; resolve (route: ActivatedRouteSnapshot,state:RouterStateSnapshot)&#123; let productId:number = route.params[&apos;id&apos;] //数据获取成功 if(productId ==1 )&#123; return new Product(1,&quot;success&quot;) &#125; //数据获取不成功 导航到新路径 else&#123; this.router.navigate([&apos;/home&apos;]) return undefined &#125; &#125; &#125;export class Test &#123;&#125; 2.使用守卫 1234567891011121314151617181920212223242526272829303132333435//1.导入定义好的路由守卫import &#123; LoginGuard &#125; from &apos;./guard/login.guard&apos;;import &#123; UnsavedGuard &#125; from &apos;./guard/unsaved.guard&apos;;import &#123; Test &#125; from &apos;./guard/test.test&apos;;//2.配置路由守卫const routes: Routes = [ &#123;path:&apos;&apos;,redirectTo:&apos;swiper&apos;,pathMatch:&apos;full&apos;&#125;, &#123;path:&apos;swiper&apos;,component:SwiperComponent&#125;, &#123;path:&apos;index&apos;,component:IndexComponent&#125;, &#123; path:&apos;tab2&apos;, component:Tab2Component, //路由进入的守卫 --- 可以执行多个路由守卫,---- 都满足的时候才能进行路由跳转 canActivate:[LoginGuard], //路由离开的守卫 canDeactivate:[UnsavedGuard], //导航之前获取数据 resolve:&#123; product: Test&#125; &#125;, &#123;path:&apos;**&apos;,component:Error404Component&#125; ];//3.使用守卫----需要通过依赖注入的形式实现,也就是providers@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule,UnsavedGuard,Test], //路由守卫 providers:[LoginGuard]&#125;) 3.数据的获取 1234567//使用路由守卫在渲染这个组件之前先从服务器读取数据this.routeInfo.data.subscribe((data:Product)=&gt;&#123; //this.productId = product.id //this.productName = product.name console.log(&quot;传递过来的数据是:&quot;+data)&#125;) 综合练习基本路由 配合bootstrap实现布局 路由使用1.效果图 2.题目描述 12345671.配置angular路由切换2.页面轮播的实现3.数据请求的实现 + 列表渲染4.实现搜索功能","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"10-生命周期钩子","slug":"angular2/10-生命周期钩子","date":"2018-05-10T00:36:05.009Z","updated":"2018-05-10T01:29:53.765Z","comments":true,"path":"2018/05/10/angular2/10-生命周期钩子/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/10-生命周期钩子/","excerpt":"","text":"生命周期钩子 在vue2.0中有八种生命周期钩子,之后又新增了两个钩子函数 ng2Pro中的生命周期钩子函数有九个 在ng2Pro中的生命周期钩子是一个接口,在这个接口里面定义了方法,在使用的时候要先实例化 1234567891011121314151617181920212223242526272829301.ngOnChanges() 当Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的SimpleChanges对象 当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit()之前。2.ngOnInit() 在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。 在第一轮ngOnChanges()完成之后调用，只调用一次。3.ngDoCheck() 检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。 在每个Angular变更检测周期中调用，ngOnChanges()和ngOnInit()之后。4.ngAfterContentInit() 当把内容投影进组件之后调用。 第一次ngDoCheck()之后调用，只调用一次。只适用于组件。5.ngAfterContentChecked() 每次完成被投影组件内容的变更检测之后调用。 ngAfterContentInit()和每次ngDoCheck()之后调用 ,只适合组件。6.ngAfterViewInit() 初始化完组件视图及其子视图之后调用。 第一次ngAfterContentChecked()之后调用，只调用一次。只适合组件。7.ngAfterViewChecked() 每次做完组件视图和子视图的变更检测之后调用。 ngAfterViewInit()和每次ngAfterContentChecked()之后调用。只适合组件。8.ngOnDestroy 当Angular每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。 在Angular销毁指令/组件之前调用。 钩子函数不需要全部设置,根据自己的需求,有选择的去使用","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"09-组件之间的数据传递","slug":"angular2/09-组件之间的数据传递","date":"2018-05-10T00:36:05.006Z","updated":"2018-05-10T01:29:47.174Z","comments":true,"path":"2018/05/10/angular2/09-组件之间的数据传递/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/09-组件之间的数据传递/","excerpt":"","text":"组件之间的数据传递 基本思路/逻辑和vue很相似 有数据可以传递(传递什么数据) 如何传递数据 将数据传递到哪(数据的接收) 父组件向子组件传递数据 使用输入属相 @Input() 可以实现父组件向子组件传递数据 具体使用的方式 123456789101112131.有数据可以传递----确定传递哪个数据 222 / selectedHero2.如何传递数据----使用属性绑定的形式实现 [test]=&apos;222&apos;3.接收传递过来的数据并在视图中使用,先从@angular/core这个包中导入 Input import &#123; Component, OnInit ,Input&#125; from &apos;@angular/core&apos; @Input() test 子组件向父组件传递数据 在子组件中使用 @Output 输出一个自定义事件 在父组件中绑定一个自定义事件,通过绑定的自定义事件的事件处理函数接收传递过来的数据 具体实现的方式 12345678910111213141516171.有数据可以传递----确定传递哪个数据----在子组件中输出自定义事件,在触发的时候将数据传递出去2.如何传递数据----在触发自定义事件的时候将数据传递出去 //输出属性,输出一个外部能够访问的自定义事件 @Output() sendData = new EventEmitter() //在创建组件的时候会默认执行一次 ngOnInit() &#123; //触发自定义事件将数据传递出去 this.sendData.emit(&apos;这是子组件数据&apos;) &#125;3.接收传递过来的数据并在视图中使用,先从@angular/core这个包中导入 Input &lt;app-tab2 (sendData)=&apos;getData($event)&apos;&gt;&lt;/app-tab2&gt; //在执行自定义事件处理函数的时候接收数据------------详情参考上图 非父子组件之间的数据传递 在vue中, 提出了一种中间人模式 也就是在两个没有关系的组件之间建立关联 var bus = new Vue() 中间人模式 选定一个组件当做中间人—-使用这个中间人进行 父亲 和 兄弟二人 使用服务的形式实现组件之间的数据传递 代码实现 以下详细说明了如何试用服务实现组件之间的数据的传递 基本配置 至少两个组件 ng g component sibling1ng g component sibling2 使用服务实现两个组件的传值 ng g service service/pass 在跟模块的provider下声明服务先导入服务 再提供服务{PassService} from ‘./service/pass.service’providers: [PassService], 使用服务传值1.service 123456789101112131415161718192021222324import &#123; Injectable &#125; from &apos;@angular/core&apos;;@Injectable()export class PassService &#123; constructor() &#123; &#125; // 用于存消息的变量 message:&quot;&quot; // &#123;&#125; [] send(data)&#123; this.message = data &#125; receive()&#123; return this.message &#125; &#125; 2.sibling1 1234567891011121314151617181920212223import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123;PassService&#125; from &apos;../service/pass.service&apos;@Component(&#123; selector: &apos;app-sibling1&apos;, templateUrl: &apos;./sibling1.component.html&apos;, styleUrls: [&apos;./sibling1.component.css&apos;]&#125;)export class Sibling1Component implements OnInit &#123; constructor( public pass:PassService ) &#123; &#125; ngOnInit() &#123; this.pass.send(&apos;我是组件1&apos;) &#125;&#125; 3.sibling2 1234567891011121314151617181920212223import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123;PassService&#125; from &apos;../service/pass.service&apos;@Component(&#123; selector: &apos;app-sibling2&apos;, templateUrl: &apos;./sibling2.component.html&apos;, styleUrls: [&apos;./sibling2.component.css&apos;]&#125;)export class Sibling2Component implements OnInit &#123; constructor( public pass:PassService ) &#123; &#125; ngOnInit() &#123; console.log(this.pass.receive()) &#125;&#125; 其他方式模板本地变量的使用 通过模板本地变量的使用,能够实现父组件获取并使用子组件里面的属性和方法 ViewChild 可以实现子组件数据和方法在父组件使用 实现的是在父组件中直接访问子组件内容 在父组件的 ngAfterViewInit 生命周期钩子中才能成功获取通过 ViewChild 查询的元素 12345678910111213141516171819202122232425262728//父组件中使用@ViewChild拿到子组件的变量和方法(父组件可调用子组件的方法和变量)import &#123; Component , ViewChild ,ContentChild&#125; from &apos;@angular/core&apos;;// 导入子组件import &#123; ChildComponent &#125; from &apos;./child/child.component&apos;;@Component(&#123; selector: &apos;app-root&apos;, templateUrl: &apos;./app.component.html&apos;, styleUrls: [&apos;./app.component.css&apos;]&#125;)export class AppComponent &#123; // 通过@ViewChild注册子组件 @ViewChild(ChildComponent) public viewChild:ChildComponent; title = &apos;app&apos;; ngAfterViewInit ()&#123; console.log(this.viewChild) &#125; &#125; Inject 子组件中使用@Inject调用父组件中的变量和方法 parent 123456789101112131415161718import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;my-parent&apos;, templateUrl: &apos;./parent.component.html&apos;, styleUrls: [ &apos;./parent.component.css&apos; ],&#125;)export class ParentComponent implements OnInit &#123; constructor() &#123;&#125; ngOnInit(): void &#123; &#125; sayHello()&#123; console.log(&quot;Hello!&quot;) &#125;&#125; child 12345678910111213141516171819import &#123; Component, OnInit, Inject, forwardRef&#125; from &apos;@angular/core&apos;;import &#123; ParentComponent &#125; from &apos;./parent.component&apos;;@Component(&#123; selector: &apos;my-child&apos;, templateUrl: &apos;./child.component.html&apos;, styleUrls: [ &apos;./child.component.css&apos; ],&#125;)export class ChildComponent implements OnInit &#123; constructor( @Inject(forwardRef(()=&gt;ParentComponent)) public parent:ParentComponent ) &#123;&#125; ngOnInit(): void &#123; this.parent.sayHello(); //&quot;Hello!&quot; &#125;&#125; ContentChildhttps://www.cnblogs.com/zheng-chuang/p/7418833.html https://www.cnblogs.com/mttcug/p/8004359.html app.html 12345&lt;h4&gt;Welcome to Angular World&lt;/h4&gt;&lt;app-parent&gt; &lt;app-child&gt;&lt;/app-child&gt;&lt;/app-parent&gt; parent 12345678&lt;p&gt; parent works!&lt;/p&gt;&lt;p&gt;Parent Component&lt;/p&gt;&lt;ng-content&gt;&lt;/ng-content&gt; 1234567891011121314151617181920212223import &#123; Component, OnInit, ContentChild, AfterContentInit &#125; from '@angular/core';import &#123; ChildComponent &#125; from '../child/child.component';@Component(&#123; selector: 'app-parent', templateUrl: './parent.component.html', styleUrls: ['./parent.component.css']&#125;)export class ParentComponent implements OnInit &#123; @ContentChild(ChildComponent) childCmp: ChildComponent; constructor() &#123;&#125; ngOnInit() &#123;&#125; ngAfterContentInit() &#123; console.dir(this.childCmp); &#125;&#125; child 1234567&lt;p&gt; child works!&lt;/p&gt;&lt;p&gt;Child Component&lt;/p&gt; 123456789101112131415161718import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-child', templateUrl: './child.component.html', styleUrls: ['./child.component.css']&#125;)export class ChildComponent implements OnInit &#123; num = 1 constructor() &#123; &#125; ngOnInit() &#123; &#125;&#125; 综合练习父组件向子组件传递数据描述: 点击按钮,实现将文本款里面的数据传递到子组件 备注: 仔细分析一下数据传递的基本流程 子组件向父组件传递数据描述: 点击按钮,实现将子组件文本款里面的数据传递到父组件 代码实现 备注: 仔细分析一下数据传递的基本流程 非父子组件传递数据描述: 实现非父子组件之间的数据通信,点击组件1的按钮,将数据传递到组件2 备注: 仔细分析一下数据传递的基本流程 综合技能1:效果图如下: 综合描述: 使用组件化的方式进行页面的开发,对于星级别评价部分使用数据传递的方式实现 综合技能2:使用组件化的方式完成以下页面的开发 综合练习3 综合练习四1.效果图 2.实现要求 123456789101112131415161. 使用ngIf实现页面选项卡切换2. 在英雄面板显示排在头部的数据3. 在列表页面显示所有的英雄4. 面板页面和列表页面的数据都定义在父组件中5. 使用Input属性/装饰器将父组件中定义好的面板页面的数据传递到对应的子组件中6. 在子组件页面点击添加按钮,能够新增一条数据7. 使用Output属性/装饰器将添加的数据更新到父组件8. 点击 x 能够删除当前数据 , 并保持数据的同步更新","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"08-ng2Pro中的组件化开发","slug":"angular2/08-组件化开发","date":"2018-05-10T00:36:05.001Z","updated":"2018-05-10T01:29:38.865Z","comments":true,"path":"2018/05/10/angular2/08-组件化开发/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/08-组件化开发/","excerpt":"","text":"ng2Pro中的组件化开发 为了使得开发的项目更容易维护,一般需要在结构上进行项目的拆分 也就是一组件化的形式实现模块化开发 哈哈哈哈 子组件的创建 在创建子组件的时候有一种简答的方式,也就是直接使用命令行的形式进行组件的创建 1ng g component componentName 生成的组件的基本结构 简单解析 这个目录结构就相当于是vue中的单文件组件 template标签 —- html文件 script标签 —- ts文件 style标签 —- css文件 组件内容解析 主要是ts文件 12345678910111213import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;; @Component(&#123; selector: &apos;app-tab1&apos;, templateUrl: &apos;./tab1.component.html&apos;, styleUrls: [&apos;./tab1.component.scss&apos;] &#125;) export class Tab1Component implements OnInit &#123; constructor() &#123; &#125; ngOnInit() &#123;&#125; &#125; @Component()是一个装饰器，唯一需要的参数是一个元数据对象。 对象的参数/属性说明： 12345678selector：组件选择器名称,作为标签的形式显示到页面templateUrl：模板文件路径styleUrls：样式文件路径当然，还有两个属性： template：模板字符串 styles：样式数组，比如：styles: [&apos;h1&#123;font-size:20px;&#125;&apos;] 动态插入内容 类似于vue的slot,允许我们动态的向组件内部插入内容,可以用于封装独立组件 组件的基本使用1&lt;app-tab1&gt;&lt;/app-tab1&gt; 动态内容嵌入123&lt;app-tab1&gt; &lt;span&gt;这是动态插入内容&lt;/span&gt;&lt;/app-tab1&gt; 嵌入内容的显示: 将组件内部的内容插入指定位置 ng-content还有一个特别的属性，值可以是”element”, #id”, “.class”, “[name=value] 12//将组件标签内部嵌入的span标签显示到指定的位置&lt;ng-content select=&quot;span&quot;&gt;&lt;/ng-content&gt; 组件样式添加1.在tab1.component.css文件中书写 123span&#123; background: pink;&#125; 2.使用样式字符串 1styles: [&apos;span &#123; font-weight: normal; &#125;&apos;] 3.使用行内样式 1&lt;span style=&quot;background: red;&quot;&gt;这是动态插入内容&lt;/span&gt; 给组件标签添加样式 也就是给当前组件添加样式 host表示的是宿主,可以看成是当前的组件名 1.:host就表示当前样式模板的宿主元素。 注意：默认情况下，自定义组件的display属性是空字符串的，也就是不占据空间。123:host&#123; background: red;&#125; 2.如果只要当其有一定条件的时候才显示某个样式，比如只要当宿主元素具有active类时，才出现灰色背景，可以这样： 123:host(.active) &#123; background: red; &#125; 3.当组件外部有一些条件时，组件内容的样式才变化。最明显的就是主题，比如当某个祖先元素具有CSS类.theme-blue时，字体才变为蓝色： 123:host-context(.theme-blue) &#123; color: blue; &#125; 组件树 理解下面这样一幅图,每一部分内容都是一个组件,不用去管 .vue后缀 组件树概念简单理解 一个工具，允许您查看您的Angular应用程序依赖关系。","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"07-管道","slug":"angular2/07-管道--过滤器","date":"2018-05-10T00:36:04.997Z","updated":"2018-05-10T01:29:28.067Z","comments":true,"path":"2018/05/10/angular2/07-管道--过滤器/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/07-管道--过滤器/","excerpt":"","text":"管道 这里所说的管道指的就是vue中的过滤器 和vue与区别的是在新版本的vue中,取消了内置过滤器的使用,只允许使用自定义过滤器 ng2Pro中的过滤器既有内置的 也允许 自定义 内置管道/过滤器基本管道 和vue没有太大差别 12// 基本过滤器的使用&#123;&#123;name | uppercase&#125;&#125; 日期管道 丰富的日期格式 123456789101112&apos;short&apos;: equivalent to &apos;M/d/yy, h:mm a&apos; (e.g. 6/15/15, 9:03 AM)&apos;medium&apos;: equivalent to &apos;MMM d, y, h:mm:ss a&apos; (e.g. Jun 15, 2015, 9:03:01 AM)&apos;long&apos;: equivalent to &apos;MMMM d, y, h:mm:ss a z&apos; (e.g. June 15, 2015 at 9:03:01 AM GMT+1)&apos;full&apos;: equivalent to &apos;EEEE, MMMM d, y, h:mm:ss a zzzz&apos; (e.g. Monday, June 15, 2015 at 9:03:01 AM GMT+01:00)&apos;shortDate&apos;: equivalent to &apos;M/d/yy&apos; (e.g. 6/15/15)&apos;mediumDate&apos;: equivalent to &apos;MMM d, y&apos; (e.g. Jun 15, 2015)&apos;longDate&apos;: equivalent to &apos;MMMM d, y&apos; (e.g. June 15, 2015)&apos;fullDate&apos;: equivalent to &apos;EEEE, MMMM d, y&apos; (e.g. Monday, June 15, 2015)&apos;shortTime&apos;: equivalent to &apos;h:mm a&apos; (e.g. 9:03 AM)&apos;mediumTime&apos;: equivalent to &apos;h:mm:ss a&apos; (e.g. 9:03:01 AM)&apos;longTime&apos;: equivalent to &apos;h:mm:ss a z&apos; (e.g. 9:03:01 AM GMT+1)&apos;fullTime&apos;: equivalent to &apos;h:mm:ss a zzzz&apos; (e.g. 9:03:01 AM GMT+01:00) 具体使用 1234567891011可以以多样化的形式格式化日期输出&lt;p&gt;&#123;&#123;birthday | date:&apos;fullDate&apos;&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;birthday | date:&quot;MM/dd/yy&quot;&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;birthday | date:&apos;shortDate&apos;&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;birthday | date:&quot;yyyy/MM/dd,hh:mm:ss&quot; &#125;&#125;&lt;/p&gt; json管道 将对象转化为json格式进行输出 参考链接 具体实现 1234561. 导入json管道 import &#123; JsonPipe &#125; from &apos;@angular/common&apos;;2. 使用json管道 &lt;h1&gt;json管道&lt;/h1&gt; &lt;p&gt;&#123;&#123;obj | json&#125;&#125;&lt;/p&gt; 链式管道 我们可以把管道链在一起，以组合出一些潜在的有用功能 12345//过滤器支持连写 也就是多次过滤&lt;p&gt;我的生日是 &#123;&#123;birthday | date | uppercase&#125;&#125;&lt;/p&gt;//特殊的日期格式&lt;p&gt;我的生日是 &#123;&#123;birthday | date | uppercase&#125;&#125;&lt;/p&gt; 更多管道查看更多管道可以参考链以下接 管道API 自定义管道/过滤器基本管道使用1.使用命令行的形式生成一个管道 12//生成一个用于乘法计算的管道ng g pipe pipe/multiple 2.基本结构 12345678910111213import &#123; Pipe, PipeTransform &#125; from &apos;@angular/core&apos;;@Pipe(&#123; name: &apos;multiple&apos;&#125;)export class MultiplePipe implements PipeTransform &#123; transform(value: any, args?: any): any &#123; return null; &#125;&#125; 使用 @Pipe 装饰器定义 Pipe 的 metadata 信息，如 Pipe 的名称 - 即 name 属性 实现 PipeTransform 接口中定义的 transform 方法 3.给管道定义将要实现的功能 数组排序的管道1234567891011121314151617181920import &#123; Pipe, PipeTransform &#125; from &apos;@angular/core&apos;; @Pipe(&#123; name: &apos;sort&apos; &#125;) export class SortPipe implements PipeTransform &#123; transform(array: Array&lt;any&gt;, args?: string): Array&lt;any&gt; &#123; array.sort((a: any, b: any) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; else if (a &gt; b) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;); return array; &#125; &#125; 注解我们更倾向使用纯管道。对于自定义管道，默认是纯管道，如果需要转为非纯管道，可以将@Pipe()中的元数据的pure属性设置为false。 附录（来源官网）： 纯管道 Angular只有在它检测到输入值发生了纯变更时才会执行纯管道。 纯变更是指对原始类型值(String、Number、Boolean、Symbol)的更改， 或者对对象引用(Date、Array、Function、Object)的更改。 Angular会忽略(复合)对象内部的更改。 如果我们更改了输入日期(Date)中的月份、往一个输入数组(Array)中添加新值或者更新了一个输入对象(Object)的属性，Angular都不会调用纯管道。 非纯管道 Angular会在每个组件的变更检测周期中执行非纯管道。 非纯管道可能会被调用很多次，和每个按键或每次鼠标移动一样频繁。","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"06-知识小结","slug":"angular2/06-知识点集锦","date":"2018-05-10T00:36:04.992Z","updated":"2018-05-10T01:29:13.154Z","comments":true,"path":"2018/05/10/angular2/06-知识点集锦/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/06-知识点集锦/","excerpt":"","text":"知识小结知识点集锦类型注解的另一种使用的方式 自定义一个类,使用类型注解的方式使用 123456789101112//创建一个类export class Hero &#123; id: number; name: string;&#125;//类型注解 hero变量是一个Hero类型的数据------自定义数据类型hero:Hero = &#123; id:1, name:&quot;hahaha&quot;&#125; 数据的双向绑定 在ng2Pro中,默认使用的是单向的数据绑定 使用[(ngModel)]语法可以实现数据的双向绑定 1234&lt;h1&gt;数据的双向绑定&lt;/h1&gt;&lt;p&gt;&#123;&#123;title&#125;&#125;&lt;/p&gt;&lt;input type=&quot;text&quot; [(ngModel)]=&quot;title&quot; /&gt; &lt;input type=&quot;text&quot; [value]=&quot;title&quot; /&gt; 一点问题 不幸的是，做了这项改动之后，我们的程序崩溃了。 打开浏览器的控制台，我们会看到Angular抱怨说：“ngModel … isn’t a known property of input.”（ngModel不是input元素的已知属性） 虽然NgModel是一个有效的Angular指令，但它默认情况下却是不可用的。 默认情况下的数据是单向绑定的 它属于一个可选模块FormsModule。 我们必须选择使用这个模块。 代码 1234import &#123; FormsModule &#125; from &apos;@angular/forms&apos;; // &lt;-- NgModel lives hereFormsModule // &lt;-- import the FormsModule before binding with [(ngModel)] 列表/表格渲染 在vue中使用的是v-for指令 在ng2Pro中使用的是 *ngFor 进行列表和表格的渲染 12345678&lt;!--基本的循环渲染--&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr *ngFor=&quot;let data of arr&quot;&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.sex&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 在ngFor中使用索引值 let i = index 这部分和vue稍微有所区别 12345678910&lt;!--循环渲染 添加索引值--&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr *ngFor=&quot;let data of arr let i = index&quot;&gt; &lt;td&gt;&#123;&#123;i&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.sex&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 使用索引值的另外一种方式 123&lt;ul&gt; &lt;li *ngFor=&quot;let data of arr; index as i&quot;&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt; &lt;/ul&gt; 可以在此基础上添加一些事件处理的逻辑 在这里可以尝试一下使用ng2Pro的形式实现一下类似于vue之中的数据的增删改查 ngIf 条件渲染 类似于vue中的v-if (v-else-if v-else v-show),能够根据条件判断是否渲染当前元素 12345&lt;div *ngIf=&quot;bool&quot;&gt; &lt;p&gt;这是一个p标签&lt;/p&gt; &lt;/div&gt; 描述: 当定义的数据 bool的值是true的时候,当前元素会显示 否则隐藏 else效果 在angular4中,新增else效果(使用模板变量#name) 1234&lt;button (click)=&quot;isShowElse = !isShowElse&quot;&gt;点击试试ngIf else&lt;/button&gt; &lt;div *ngIf=&quot;isShowElse else next&quot;&gt;ngIf结构型指令中的else&lt;/div&gt; &lt;ng-template #next&gt;else效果&lt;/ng-template&gt; 补充 ng-container元素会将其里面的内容插入或移除，但ng-container元素不会出现在页面里。 1&lt;ng-container *ngIf=&quot;isShow&quot;&gt;&lt;/ng-container&gt; 样式的添加 有两种方式 1.直接使用属性绑定2.使用ngClass 和 ngStyle 类样式ngClass 123456&lt;button [ngClass]=&quot;&apos;test&apos;&quot;&gt;click&lt;/button&gt;&lt;button [ngClass]=&quot;&apos;test test1&apos;&quot;&gt;click&lt;/button&gt;//只有当isTrue变量的值为true时，active样式类才会添加到div上&lt;div [ngClass]=&quot;&#123;active: isTrue&#125;&quot;&gt;Active类&lt;/div&gt; 单个类样式 在vue中使用v-bind绑定属性,在ng2Pro中使用的是[]的形式进行属性的绑定 12345&lt;div [class.bg]=&apos;bool&apos;&gt; &lt;p&gt;这是一个p标签&lt;/p&gt; &lt;/div&gt; 描述: 当定义的bool值或者是逻辑表达式为true的时候,给div添加bg这个类样式 行内样式ngStyle 1&lt;button [ngStyle]=&quot;&#123;&apos;width&apos;:&apos;100px&apos;&#125;&quot;&gt;click&lt;/button&gt; 行内样式 123456&lt;!-- 直接绑定行内样式 --&gt;&lt;button [style.color] = &quot;isSpecial ? &apos;red&apos;: &apos;green&apos;&quot;&gt;红色&lt;/button&gt; &lt;button [style.background-color]=&quot;canSave ? &apos;cyan&apos;: &apos;grey&apos;&quot; &gt;保存&lt;/button&gt;&lt;!-- 带有单位的样式绑定 --&gt;&lt;button [style.font-size.em]=&quot;isSpecial ? 3 : 1&quot; &gt;大&lt;/button&gt;&lt;button [style.font-size.%]=&quot;!isSpecial ? 150 : 50&quot; &gt;小&lt;/button&gt; 事件操作 在vue中, 使用v-on的形式进行事件的绑定 12//点击按钮的时候,执行fn方法&lt;button v-on:click=&quot;fn()&quot;&gt;click&lt;/button&gt; 在ng2Pro中 1234567//点击按钮的时候,执行fn方法&lt;button (click)=&quot;fn()&quot;&gt;click&lt;/button&gt;&lt;button on-click=&quot;fn()&quot;&gt;click&lt;/button&gt;//使用原生js的事件操作,需要传递特殊的事件参数&lt;button on-click=&quot;fn($event)&quot;&gt;click&lt;/button&gt; 属性操作 在vue中使用的是v-bind,在ng2Pro中使用的是[] 1234//变量imgSrc在ts文件中定义&lt;img [src]=&quot;src&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;&#123;&#123;src&#125;&#125;&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;../../assets/favicon.ico&quot; alt=&quot;&quot; /&gt; ngSwitch 当需要从一组可能的数据中选择其中的一个的时候,就要用到ngSwitch 1234567&lt;ul [ngSwitch]=&apos;item&apos;&gt; &lt;li *ngSwitchCase=&quot;&apos;王&apos;&quot;&gt;王&lt;/li&gt; &lt;li *ngSwitchCase=&quot;&apos;李&apos;&quot;&gt;李&lt;/li&gt; &lt;li *ngSwitchCase=&quot;&apos;吾&apos;&quot;&gt;吾&lt;/li&gt; &lt;li *ngSwitchCase=&quot;&apos;刘&apos;&quot;&gt;刘&lt;/li&gt; &lt;li *ngSwitchDefault&gt;哈哈哈哈&lt;/li&gt;&lt;/ul&gt; 当item = “王”的时候,只显示王…… 综合练习投票1.案例效果图 2.题目要求 12345完成列表渲染数据的添加列表的排序 增删改查1.案例效果图 2.题目要求 123456789101112131415161718191.使用正确的命令渲染列表数据2.双向数据绑定引入正确的模3.正确的使用双向数据绑定4.正确的进行商品名模糊搜索5.正确的进行价格区间查询6.正确的进行商品名和价格区间的联合查询7.清空条件后回复列表数据8.新增商品9.编辑商品10.删除商品","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"05-插件使用第一种方式","slug":"angular2/05-bootstrap和jquery的使用","date":"2018-05-10T00:36:04.988Z","updated":"2018-05-10T01:29:02.715Z","comments":true,"path":"2018/05/10/angular2/05-bootstrap和jquery的使用/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/05-bootstrap和jquery的使用/","excerpt":"","text":"ng2Pro中插件的使用第一种方式 也是一种较为麻烦的方式,不过也是推荐使用的方式 以bootstrap 和 jquery为例 1.安装bootstrap和jquery 12npm install bootstrap--save npm install jquery --save 2.在.angular-cli.json文件，添加bootstrap和jQuery 12345678&quot;styles&quot;: [ &quot;styles.css&quot;, &quot;../node_modules/bootstrap/dist/css/bootstrap.css&quot;],&quot;scripts&quot;: [ &quot;../node_modules/jquery/dist/jquery.js&quot;, &quot;../node_modules/bootstrap/dist/js/bootstrap.js&quot;], 3.在typescript环境中使用bootstrap和jquery 需要安装两个依赖,否则的话,不能够识别在jquery的bootstrap中的js语法 12npm install @types/bootstrap --save-devnpm install @types/jquery --save-dev 4.声明 使之成为一个可用的变量 12345declare var $:any;或者是import * as $ from &apos;jquery&apos;; 第二种使用的方式 这种方式比较简单,但是不推荐使用 其他插件的使用方式类似 1.直接在index.html文件中引入相关文件 12345&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; 2.在使用的地方进行声明,使之成为一个可用的变量 12345declare var $:any;或者是import * as $ from &apos;jquery&apos;;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"04-项目启动","slug":"angular2/04-项目启动过程","date":"2018-05-10T00:36:04.983Z","updated":"2018-05-10T01:28:55.076Z","comments":true,"path":"2018/05/10/angular2/04-项目启动过程/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/04-项目启动过程/","excerpt":"","text":"项目启动 整个angular项目的启动是从.angular-cli.json文件开始的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123; &quot;project&quot;: &#123; &quot;version&quot;: &quot;1.0.0-beta.28.3&quot;, &quot;name&quot;: &quot;test1&quot; &#125;, &quot;apps&quot;: [ &#123; &quot;root&quot;: &quot;src&quot;, &quot;outDir&quot;: &quot;dist&quot;, &quot;assets&quot;: [ &quot;assets&quot;, &quot;favicon.ico&quot; ], &quot;index&quot;: &quot;index.html&quot;, //--------------------------------------------项目的启动从index.html &quot;main&quot;: &quot;main.ts&quot;, //--------------------------------------------项目启动的脚本文件 &quot;polyfills&quot;: &quot;polyfills.ts&quot;, &quot;test&quot;: &quot;test.ts&quot;, &quot;tsconfig&quot;: &quot;tsconfig.json&quot;, &quot;prefix&quot;: &quot;app&quot;, &quot;styles&quot;: [ &quot;styles.css&quot; ], &quot;scripts&quot;: [], &quot;environments&quot;: &#123; &quot;source&quot;: &quot;environments/environment.ts&quot;, &quot;dev&quot;: &quot;environments/environment.ts&quot;, &quot;prod&quot;: &quot;environments/environment.prod.ts&quot; &#125; &#125; ], &quot;e2e&quot;: &#123; &quot;protractor&quot;: &#123; &quot;config&quot;: &quot;./protractor.conf.js&quot; &#125; &#125;, &quot;lint&quot;: [ &#123; &quot;files&quot;: &quot;src/**/*.ts&quot;, &quot;project&quot;: &quot;src/tsconfig.json&quot; &#125;, &#123; &quot;files&quot;: &quot;e2e/**/*.ts&quot;, &quot;project&quot;: &quot;e2e/tsconfig.json&quot; &#125; ], &quot;test&quot;: &#123; &quot;karma&quot;: &#123; &quot;config&quot;: &quot;./karma.conf.js&quot; &#125; &#125;, &quot;defaults&quot;: &#123; &quot;styleExt&quot;: &quot;css&quot;, &quot;prefixInterfaces&quot;: false, &quot;inline&quot;: &#123; &quot;style&quot;: false, &quot;template&quot;: false &#125;, &quot;spec&quot;: &#123; &quot;class&quot;: false, &quot;component&quot;: true, &quot;directive&quot;: true, &quot;module&quot;: false, &quot;pipe&quot;: true, &quot;service&quot;: true &#125; &#125;&#125; 1.从main.ts和index.html开始启动项目 整个项目的启动是从main.ts文件开始的,main.ts的文件内容如下所示,可能部分内容是有所区别的,但是问题不到(版本原因)index.html文件是项目启动的参考文件 main.ts的文件内容如图所示 1234567891011121314151617181920212223//导入一些必要的库,以便于兼容,使angular能够正常运行在常见的浏览器import &apos;./polyfills.ts&apos;//使用什么模块启动整个应用import &#123; platformBrowserDynamic &#125; from &apos;@angular/platform-browser-dynamic&apos;;//开发者模式是否启用import &#123; enableProdMode &#125; from &apos;@angular/core&apos;;//导入环境配置,在打包部署的时候会用到import &#123; environment &#125; from &apos;./environments/environment&apos;;//导入主模块import &#123; AppModule &#125; from &apos;./app/app.module&apos;;//如果当前是生产环境,关闭开发者模式if (environment.production) &#123; enableProdMode();&#125;//整个程序从这个位置开始启动platformBrowserDynamic().bootstrapModule(AppModule); index.html文件 在这个文件的内容里面有一个 Loading… 这个东西你可以理解为组件的名称,具体的内容在跟组件中可以找到依据 就是类似于vue的组件和组件民,这部分定义的是显示组件的位置,也就是组件的名称 2.项目的启动从主模块开始123456789101112131415161718192021222324252627//导入一些必要的包import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; FormsModule &#125; from &apos;@angular/forms&apos;;import &#123; HttpModule &#125; from &apos;@angular/http&apos;;import &#123; AppComponent &#125; from &apos;./app.component&apos;;//模块元素装饰器,可以理解为是向模块里面添加内容的@NgModule(&#123; //声明模块中拥有的内容,在这一部分,只能声明组件,指令和管道 declarations: [ AppComponent ], //导入需要的依赖内容----模块 imports: [ BrowserModule, FormsModule, HttpModule ], //在这里声明提供的服务 providers: [], //声明主组件 bootstrap: [AppComponent]&#125;)//导出一个模块export class AppModule &#123; &#125; 3.在主模块中,加载了主组件1234567891011121314//定义组件,需要导入一个组件装饰器import &#123; Component &#125; from &apos;@angular/core&apos;;//组件元数据装饰器,会将元数据附加到typescript类中@Component(&#123; selector: &apos;app-root&apos;, //组件名称----在index.html页面,组件名作为标签显示到页面上 //template: &apos;&lt;p&gt;&#123;&#123;title&#125;&#125;&lt;p/&gt;&apos;, //组件内容 templateUrl: &apos;./app.component.html&apos;, styleUrls: [&apos;./app.component.css&apos;] //组件样式&#125;)export class AppComponent &#123; title = &apos;app works!&apos;; //组件要处理的业务逻辑部分(数据--方法---属性)&#125; 主组件和样式文件 app.component.html 和 app.component.css 在主模块中使用的内容 和 样式文件 //将主模块中的数据渲染到 app.component.html 页面上 &lt;h1&gt;{{title}}&lt;/h1&gt;","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"03-项目简介","slug":"angular2/03-项目目录结构解析","date":"2018-05-10T00:36:04.978Z","updated":"2018-05-10T01:28:37.059Z","comments":true,"path":"2018/05/10/angular2/03-项目目录结构解析/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/03-项目目录结构解析/","excerpt":"","text":"项目简介目录介绍1234567891.e2e end to end 端到端的测试目录2.src目录 这个应用的源代码文件3.karam 配置文件,自动化测试4.protractor 配置文件 ,和karam类似 , 做自动化测试5.tslint typescript语法检测 重点 src目录123456789101112131.app目录 ,代码一般都是写在这个目录,包含应用的模块和组件2.assets: 静态资源目录3.environments目录, 开发环境配置,支持多环境开发4.index.html 整个应用的根html,整个应用就是从这个文件开始的------------&lt;app-root&gt;&lt;/app-root&gt;5.main.ts 脚本执行的入口点,从这个文件启动ng应用程序6.polyfile.ts 导入的一些库,可以做一些兼容方面的内容,也就是运行在低版本浏览器7.style.css 定义全局的样式","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"02-开发环境","slug":"angular2/02-开发环境搭建","date":"2018-05-10T00:36:04.973Z","updated":"2018-05-10T01:28:51.296Z","comments":true,"path":"2018/05/10/angular2/02-开发环境搭建/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/02-开发环境搭建/","excerpt":"","text":"开发环境搭建开发环境基本环境需求1.安装nodejs 2.全局安装@angular/cli 1234567npm install -g angular-clinpm install -g @angular/cli 新版本npm install -g @angular/cli@latest 最近更新的版本-推荐使用npm install -g @angular/cli@1.3.1 安装指定的版本 3.安装成功,使用ng -v命令查看版本,成功的话就可以正常创建我们的项目了 12查看版本命令行: ng -v 4.项目的创建 123使用以下命令进行项目的创建 ng new projectName 5.切换目录 1cd projectName 6.启动服务 启动成功后可以看到ng的标识 12345678//需要手动输入主机名和端口号ng serve//自动打开浏览器ng serve -o // 生成最小化的测试单元ng serve --prod --aot 7.项目打包 将做好的项目进行打包 1234ng build// 生成最小化的包,抛弃一些无用的单元/模块ng build --prod --aot 其他命令1234567891011121314151. 创建组件 ng g component componentName2. 创建服务 ng g service serviceName3. 创建指令 ng g directive directiveName4. 创建管道 ng g pipe pipeName5. 创建类 ng g class className6. 创建接口 ng g intetrface interfaceName7. 创建枚举 ng g enum enumName8. 创建模块 ng g module moduleName 关于安装过程中的小问题1.速度慢 123456789切换配置源,默认使用淘宝镜像: npm config set registry https://registry.npm.taobao.org 淘宝镜像安装 npm install -g cnpm --registry=https://registry.npm.taobao.org升级淘宝镜像 cnpm install cnpm -g 2.cnpm 建议不要使用cnpm进行安装,在使用的时候可能会有一些小问题 能够使用npm的尽量使用npm进行,实在安装不上的话,再使用cnpm 安装报错可以尝试一下操作 1234567891011121.先卸载包 npm uninstall -g @angular/cli2.强制清缓存 旧版本: npm cache clean 新版本: npm cache clean --force 3.重新安装 npm install -g @angular/cli@latest","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"01-angular概述","slug":"angular2/01-简介","date":"2018-05-10T00:36:04.968Z","updated":"2018-05-10T01:28:23.565Z","comments":true,"path":"2018/05/10/angular2/01-简介/","link":"","permalink":"http://yoursite.com/2018/05/10/angular2/01-简介/","excerpt":"","text":"angular概述test angular简介 angular2Pro使用typescript,typescript是angular2Pro应用程序的主要开发语言 知识点概述12345678910111213141.路由2.依赖注入----编写可重用组件3.绑定,响应式编程和管道4.组件通信5.表单处理6.与服务器通信7.构建和部署 angular架构 12345671. 模块: angular必须包含一个模块,模块用来将应用中不同的组织组成一个angular框架可以理解的单元 2. 组件是基本组成部分,也就是angular的基本构建块可以理解为一段具有业务逻辑和数据的html3. 服务:用来封装可以重用的业务逻辑4. 指令: 允许你向html添加自定义行为 与vue的对比vue123456789101112优点: 1.小型 2.灵活 3.性能--虚拟dom小问题: 1.个人主导 2.只关注于web 3.vue本身不支持服务器端渲染","categories":[{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/categories/angular2/"}],"tags":[]},{"title":"ts简单总结","slug":"ts/07-简单总结/07-简单总结","date":"2018-05-10T00:35:41.599Z","updated":"2018-05-10T01:03:01.085Z","comments":true,"path":"2018/05/10/ts/07-简单总结/07-简单总结/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/07-简单总结/07-简单总结/","excerpt":"","text":"ts简单总结 类型注解 声明一个变量 提前确定类型 1234567891011121314151617181920// 基本的类型注解 number string boolean null undefined var a:number = 10//对象的类型注解 object(function array) public $http:Http --- public routerInfo:ActivatedRoute ---// 补充any enumdeclare var $:any; ----declare var Swiper:any; ----var arr:enum // 这是枚举类型 模块化语法 1234567891011121314151617181920212223242526272829303132333435 导入 import &#123;Tab1Component&#125; from &quot;路径&quot; 导出 export class Tab1Component&#123;&#125; 导入重命名语法 import &#123;Tab1Component as tab1&#125; from &quot;路径&quot; 在vue单文件组件中 导出 export default &#123;&#125; 导入 import aaa from &apos;./components/01-head/head.vue&apos;1. 单个export 导出 导出的是单个变量 需要使用 &#123;&#125;2. 使用export default 导出的是当前的所有 内容 是一个集合 export default &#123; name: &apos;app&apos;, data() &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, created()&#123; &#125;, methods:&#123; &#125; &#125;3. 使用export 导入和导出名称要一致4. 使用export default 名称可以随便命名 let const var 123456let 定义变量 ----- 局部作用域var 定义变量 ------ 全局作用域const 定义常量,声明只读关键字 class 123456789101112定义类 class Parent&#123;&#125; class Tab1Component&#123;&#125;继承类 class Child extends Parent&#123;&#125;类的成员属性 public private protected static readonly 装饰器 123456789101112@Component@NgModule@Pipe@Input@Output@inject 浏览器: 浏览器支持 html css js es6 .ts 浏览器不完全支持 es6 使用babel-loader 将es6转化为es5 浏览器不支持ts 需要使用typescript包将ts转化为es5","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"07-简单总结","slug":"ts/07-简单总结","permalink":"http://yoursite.com/categories/ts/07-简单总结/"}],"tags":[]},{"title":"装饰器","slug":"ts/06-装饰器/06-装饰器","date":"2018-05-10T00:35:41.581Z","updated":"2018-05-10T01:02:55.534Z","comments":true,"path":"2018/05/10/ts/06-装饰器/06-装饰器/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/06-装饰器/06-装饰器/","excerpt":"","text":"装饰器 以@开头 装饰即附加内容 这一部分知识在后期讲解","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"06-装饰器","slug":"ts/06-装饰器","permalink":"http://yoursite.com/categories/ts/06-装饰器/"}],"tags":[]},{"title":"模块化","slug":"ts/05-模块化/05-模块化","date":"2018-05-10T00:35:41.550Z","updated":"2018-05-10T01:02:51.412Z","comments":true,"path":"2018/05/10/ts/05-模块化/05-模块化/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/05-模块化/05-模块化/","excerpt":"","text":"模块化 重点是模块的导入和导出 import 和 export 基本使用导出 在ModuleA.js导出内容 12345678//导出变量 export var a = 10//导出函数 export function fn()&#123;&#125;//导出类 export class Parent&#123;&#125; 导入 在另一个文件中导入 12345678//导出单个变量import &#123;a&#125; from &quot;ModuleA&quot;import &#123;a,fn&#125; from &quot;ModuleA&quot;//导入类import &#123;Parent&#125; from &quot;ModuleA&quot; 导入重命名语法 as语法 123456//导入jquery所有内容重命名为$import * as $ from &quot;jquery&quot; //将变量a重命名为bimport &#123;a as b&#125; from &quot;moduleA&quot;","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"05-模块化","slug":"ts/05-模块化","permalink":"http://yoursite.com/categories/ts/05-模块化/"}],"tags":[]},{"title":"类和继承","slug":"ts/04-类/04-类","date":"2018-05-10T00:35:41.522Z","updated":"2018-05-10T01:02:47.540Z","comments":true,"path":"2018/05/10/ts/04-类/04-类/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/04-类/04-类/","excerpt":"","text":"类和继承12345678class : 封装/继承 特点: 可以书写属性和方法 能够实现继承 能够实例化 基本知识点123456789101112131415161718192021书写方式 class className&#123; &#125;构造函数 construct()&#123;&#125; 在创建实例的时候,这个函数会默认执行成员类型 public 默认的/公共的 所有实例都能访问 private 私有的 只有在class中使用 protected 受保护的 实例下不能用 在子类中能够使用 static 声明静态成员 js使用原型模拟类1.扩展原型 1234567function Person(name) &#123; this.name = name;&#125;Person.prototype.say = function()&#123;&#125;Person.prototype.toString = function()&#123;&#125;Person.prototype.toString1 = function()&#123;&#125;Person.prototype.toString2 = function()&#123;&#125; 2.替换原型 123456Person.prototype = &#123; constructor: function () &#123; &#125;, toString: function () &#123; &#125;, toValue: function () &#123; &#125;, say: function () &#123;console.log(&quot;考试一团糟&quot;);&#125;&#125;; 3.函数名称简写 类的雏形由此而来 123456Person.prototype = &#123; constructor () &#123; &#125;, toString () &#123; &#125;, toValue () &#123; &#125;, say () &#123;console.log(&quot;考试一团糟&quot;);&#125;&#125;; 类的定义123456789101112131415class Person &#123; //构造函数会默认执行 constructor () &#123; console.log(1) &#125; toString() &#123;&#125; toValue() &#123;&#125; say()&#123; console.log(&quot;考试一团糟&quot;) &#125;&#125; 存取器 设置/获取值的时候自动调用相关的方法 123456789101112class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &apos;getter&apos;; &#125; set prop(value) &#123; console.log(&apos;setter: &apos;+value); &#125;&#125; 继承的实现 super 123456789101112131415161718192021222324//类的实现 class Person &#123; public name: string; constructor(name: string) &#123; this.name = name; &#125; &#125; class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; //继承父类的内容 super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125; &#125; let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;); console.log(howard.getElevatorPitch()); console.log(howard.name); // error","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"04-类","slug":"ts/04-类","permalink":"http://yoursite.com/categories/ts/04-类/"}],"tags":[]},{"title":"接口","slug":"ts/03-接口/03-接口","date":"2018-05-10T00:35:41.413Z","updated":"2018-05-10T01:02:43.911Z","comments":true,"path":"2018/05/10/ts/03-接口/03-接口/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/03-接口/03-接口/","excerpt":"","text":"接口什么是接口 方法-索引-事件-属性的集合 在编程中,接口就是一个抽象的数据类型,使用interface声明 接口不能像对象那样实例化,只能被继承 1234interface Person &#123; firstName: string; lastName: string;&#125; 为什么使用接口 一些抽象的方法和特征的集合,可以通过 继承接口的方式,来继承接口中的属性和方法 可以有效的减少代码的冗余 接口的特点 1234书写形式上和class很相似封装属性和方法不能实例化,只能被继承默认所有的属性必须全部被实现 / 如果不全部实现,添加 ? 接口补充 在默认的情况下,接口里面的内容必须都被实现 123只读属性 readonly可选属性 ? 接口的基本使用 在js中实现一个接口 123456789101112interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;&#125;var user = &#123; firstName: &quot;Jane&quot;, lastName: &quot;User&quot; &#125;;document.body.innerHTML = greeter(user); 和其他语言有区别 我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements语句。 接口的实现 除了上述使用的方式之外,也可以使用implements的方式来实现接口 实现接口之后,可以使用接口里面所有的属性和方法 123456789interface parent&#123;&#125;//继承接口之后,可以实现接口里面的属性和方法class child implements parent&#123;&#125; 补充123456789101112131415161718192021221. 正常的接口定义 interface Person &#123; firstName: string; lastName: string; &#125;2. 接口的可选属性定义 interface SquareConfig &#123; color?: string; width?: number; &#125;3. 接口的只读属性定义 interface Point &#123; readonly x: number; readonly y: number; &#125;4. 函数类型的接口 interface SearchFunc &#123; (source: string, subString: string): boolean; &#125;","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"03-接口","slug":"ts/03-接口","permalink":"http://yoursite.com/categories/ts/03-接口/"}],"tags":[]},{"title":"强类型和类型注解","slug":"ts/02-类型注解/02-类型注解","date":"2018-05-10T00:35:41.401Z","updated":"2018-05-10T01:02:40.320Z","comments":true,"path":"2018/05/10/ts/02-类型注解/02-类型注解/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/02-类型注解/02-类型注解/","excerpt":"","text":"强类型和类型注解js本身是一种弱类型的语言 123没有严格的变量声明规范变量的类型根据变量的值确定现有变量值,再有变量类型 强类型 类似于c语言 java…. 在变量定义的时候确定变量的类型 对变量加以严格约束 123456int : 整型float: 浮点型double : 双精度 .............. 在ts中使用类型注解的形式显示语言强类型 什么是类型注解 TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式 在定义变量的时候添加类型注解,可以预防一些编译时的错误 js类型类型 在讲解typescript的基础数据类型之前,先看一下js的数据类型 js的六大数据类型: js中有六种数据类型，包括五种基本数据类型（Number,String,Boolean,Null,Undefined）,和一种混合数据类型（Object）。 typescript支持的数据类型和JavaScript基本上完全相同 在此基础上增加了枚举数据类型以方便我们使用 常见数据类型的类型注解1.boolean 12//添加类型注解----当前的数据类型值只能是boolean类型let bool:boolean = false 2.number 12//添加类型注解 ---- 当前的数据类型只能是数字类型let num:number = 1 3.string 123//添加类型注解----当前的数据类型只能是字符串类型----在此基础上,还支持模板字符串的使用let str:string=&quot;坏孩子&quot;let sentence = `我们都是$&#123;str&#125;,我们都是坏孩子` 4.null和undefined 1let n:null = null 5.undefined 1let u:undefined = undefined 6.array 12345678910//定义数组并添加类型注解的形式 //添加类型注解,数组里面的元素只能是数字类型 ---- 这是第一种方式 let arr:number[] = [1,2,3] // 使用数组泛型 ---- 这是第二种方式 let arr:Array&lt;number&gt; = [1,2,3]//定义元组Tuple----元组里面的数据可以是不同的数据类型let x: [string, number] = [&quot;1&quot;,2] 类型注解补充1.enum 枚举 可以简单理解为遍历 12345678910111213141516//在默认的情况下,从0开始赋予编号,也可以手动指定成员的数值,进行手动编号enum Color &#123;Red, Green, Blue&#125;//(function (Color) &#123;// Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;;// Color[Color[&quot;Green&quot;] = 1] = &quot;Green&quot;;// Color[Color[&quot;Blue&quot;] = 2] = &quot;Blue&quot;;//&#125;)(Color || (Color = &#123;&#125;));let c: Color = Color.Green;console.log(Color)//手动设置成员的编号enum Color &#123;Red = 1, Green, Blue&#125; 2.any 不对变量的值进行检查,也就是说变量的值可以是任意类型的 1let notSure: any = 4; 3.void 1234有参数 有返回值有参数 无返回值无参数 有返回值无参数 无返回值 在定义一个函数的时候 如果有个函数没有返回值,可以使用void声明 给一个变量使用类型注解的时候没有太大意义,只能给值 undefined / null 1function fn:void &#123; &quot;这是函数体&quot;&#125; 4.never never类型表示的是哪些永不存在的值 never可以赋值个任何类型,任何类型的值都不能赋值给never never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(&quot;Something failed&quot;);&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 5.断言 断言好比类型转换,但是不进行特殊的数据检查和解构 1234//&lt;&gt;语法let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length; 1234//as语法let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 一个简单的例子123456789101112//在这里,传递参数的时候给这个参数添加一个类型:stringfunction greeter(person:string) &#123; return &quot;Hello, &quot; + person;&#125;//var user = &quot;Jane User&quot;;//在这里,尝试修改一些user的值变成一个数组var user = [1,2,3]document.body.innerHTML = greeter(user); 上述代码在编译的过程中会发生错误 TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。 1greeter.ts(11,35): error TS2345: Argument of type &apos;number[]&apos; is not assignable to parameter of type &apos;string&apos;. 要注意的是尽管有错误，greeter.js文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行。 知识点补充基本数据类型和复杂数据类型 检测基本数据类型: typeof检测复杂数据类型: instanceof 补充1 123456789101112typeof 1 ----- numbertypeof 1 + &quot;2&quot; ----- number2typeof -&apos;2&apos; ----- numbertypeof 1-&apos;2&apos; ----- number-&quot;2&quot; NaNtypeof null objecttypeof undefined undefinednull==undefined truenull===undefined false 补充2 12345678910111213141516function fn()&#123;&#125;fn instanceof Function[] instanceof Array&#123;&#125; instanceof Object特殊 : Function 所有的函数都是直接或者是间接通过Function构造函数创建 对象Object也是由Function构造函数创建","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"02-类型注解","slug":"ts/02-类型注解","permalink":"http://yoursite.com/categories/ts/02-类型注解/"}],"tags":[]},{"title":"typescript知识点","slug":"ts/01-ts入门/01-typescript入门","date":"2018-05-10T00:35:41.384Z","updated":"2018-05-10T01:02:36.215Z","comments":true,"path":"2018/05/10/ts/01-ts入门/01-typescript入门/","link":"","permalink":"http://yoursite.com/2018/05/10/ts/01-ts入门/01-typescript入门/","excerpt":"","text":"typescript知识点typescript什么是typescript TypeScript 是一种由微软开发的自由和开源的编程语言，它是JavaScript的一个超集，扩展了JavaScript的语法。 语法特性123456类 Classes接口 Interfaces模块 Modules 类型注解 Type annotations编译时类型检查 Compile time type checking Arrow 函数 (类似 C## 的 Lambda 表达式) JavaScript 与 TypeScript 的区别 TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。 开始使用typescript1.使用npm安装 1npm install -g typescript 2.构建第一个typescript文件 命名为 test.ts文件,写入一下内容 1234567function greeter(person) &#123; return &quot;Hello, &quot; + person;&#125;var user = &quot;Jane User&quot;;document.body.innerHTML = greeter(user); 3.编译 .ts文件 在执行 .ts文件之前,需要将 .ts文件 编译为 .js文件 1tsc test.ts 执行以上命令,可以将 test.ts文件转化为同名的 test.js文件 4. 使用 创建有个html文件,引入test.js文件","categories":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/categories/ts/"},{"name":"01-ts入门","slug":"ts/01-ts入门","permalink":"http://yoursite.com/categories/ts/01-ts入门/"}],"tags":[]},{"title":"06-主题设置","slug":"ionic2/06-主体化","date":"2018-05-10T00:35:17.973Z","updated":"2018-05-10T01:27:54.235Z","comments":true,"path":"2018/05/10/ionic2/06-主体化/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/06-主体化/","excerpt":"","text":"主题设置 在ionic中提供了快速定义主题的方式 自定义主题参考链接 自定义一套ionic主题 主题修改 项目目录 src/theme/variables.scss 件中的$colors 你可以在这里定制你的主题 1.样式修改 2.变量定义 使用$定义变量 可以使用多次 文字修改1234567891011121314文本对齐 text-left text-right text-start text-end text-center text-justify text-wrap text-nowrap文本转换 text-uppercase text-lowercase text-capitalize响应文本属性 text-&#123;modifier&#125; 在所有屏幕尺寸上将修饰符应用于元素。 text-sm-&#123;modifier&#125; 将修饰符应用于元素min-width: 576px。 text-md-&#123;modifier&#125; 将修饰符应用于元素min-width: 768px。 text-lg-&#123;modifier&#125; 将修饰符应用于元素min-width: 992px。 text-xl-&#123;modifier&#125; 将修饰符应用于元素min-width: 1200px。 元素放置1234567891011浮动元素 float-left float-right float-start float-end响应浮动属性 float-&#123;modifier&#125; 在所有屏幕尺寸上将修饰符应用于元素。 float-sm-&#123;modifier&#125; 将修饰符应用于元素min-width: 576px。 float-md-&#123;modifier&#125; 将修饰符应用于元素min-width: 768px。 float-lg-&#123;modifier&#125; 将修饰符应用于元素min-width: 992px。 float-xl-&#123;modifier&#125; 将修饰符应用于元素min-width: 1200px。 元素填充123456789padding padding: 16px 适用于各方面的填充。padding-top padding-top: 16px 将填充应用到顶部。padding-left padding-left: 16px 在左侧应用填充。padding-right padding-right: 16px 在右侧应用填充。padding-bottom padding-bottom: 16px 将填充应用于底部。padding-vertical padding: 16px 0 将填充应用于顶部和瓶颈。padding-horizontal padding: 0 16px 适用于左侧和右侧的填充。no-padding padding: 0 适用于所有方面的填充。 外边距12345678margin margin: 16px 适用于各方面。margin-top margin-top: 16px 应用边缘到顶部。margin-left margin-left: 16px 在左边应用边距。margin-right margin-right: 16px 适用于右侧的保证金。margin-bottom margin-bottom: 16px 将余量应用到底部。margin-vertical margin: 16px 0 应用顶部和瓶颈的余量。margin-horizontal margin: 0 16px 应用左边和右边的边距。no-margin margin: 0 对各方没有利润。 动态属性 通过动态设置CSS属性，可以根据特定条件从组件添加或删除功能。要动态设置属性，请使用以下语法： 1&lt;div [attr.text-center]=&quot;isMD ? &apos;&apos; : null&quot;&gt;I will be centered when isMD is true.&lt;/div&gt; 平台样式 ionic是一个跨平台的框架,针对于不同的平台设置了不同的样式 1234567 android: md ios: ios window:wp 不符合的以上三种/core: md默认的平台样式也是md 课程重点/考点1234567891011121314151617主题使用 theme/.sasssass--less变量 定义 sass $ less @工具属性平台样式样式覆写 css层叠特性 css优先级 !important&gt;行内&gt;id&gt;类&gt;标签动态属性 什么是动态属性","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"05-导航","slug":"ionic2/05-组件补充","date":"2018-05-10T00:35:17.962Z","updated":"2018-05-10T01:27:45.381Z","comments":true,"path":"2018/05/10/ionic2/05-组件补充/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/05-组件补充/","excerpt":"","text":"navigation/导航详情参考官网api文档 使用这一部分内容基本可以替代路由操作 导航的使用 可以将所有的页面理解为一个栈的结构 实现页面的导航,也就是出栈和入栈的过程 基本导航的实现三步操作 1231. 导入控制器类2. 注入到构造函数3. 调用方法 1.导入控制器类 1import &#123; NavController &#125; from &apos;ionic-angular&apos;; 2. 注入到构造函数 注入多个内容,中间使用逗号隔开 1constructor(public navCtrl: NavController) &#123;&#125; 3.调用方法 可以实现基本导航,也可以实现像路由跳转那样进行参数的传递 1234567891011121314151617//在html页面调用这个函数即可实现基本导航操作pushPage()&#123; //这里OtherPage指代的是你需要导航到的页面,这个页面需要自己手动创建 //页面创建完成之后需要在根模块完成配置并导入到当前页面 this.navCtrl.push(OtherPage); &#125;//在进行页面导航的时候还可以进行参数传递 pushPage()&#123; //在进行页面导航的时候传递id参数和name参数 this.navCtrl.push(OtherPage, &#123; id: &quot;123&quot;, name: &quot;Carl&quot; &#125;); &#125; 路由导航参数的获取 在页面导航的时候,如果需要进行参数的传递,在已传递参数的情况下,可以在导航到的页面获取之前传递的参数 比如在上述示例中导航到OtherPage页面,可以在这个页面获取到传递过来的参数 1.导入控制器类 1import &#123; NavParams &#125; from &apos;ionic-angular&apos;; 2.注入到构造函数1constructor(private navParams: NavParams) &#123;&#125; 3.调用方法 12//获取传递的id参数this.navParams.get(&apos;id&apos;); 从根组件开始导航12345678910111213141. 导入控制器 import &#123; Component, ViewChild &#125; from &apos;@angular/core&apos;; import &#123; NavController &#125; from &apos;ionic-angular&apos;;2. 注入 使用ViewChild @ViewChild(&apos;myNav&apos;) nav: NavController 3. 调用方法 this.nav.push(Page1); //导航到Page1页面,这个页面需要手动生成并完成配置 导航移除 从栈中移除导航的页面 12345678910111. 导入控制器 import &#123; NavController &#125; from &apos;ionic-angular&apos;;2. 注入 使用ViewChild constructor(public navCtrl: NavController )&#123;&#125; 3. 调用方法 this.navCtrl.pop(); 综合练习手机qq1.案例效果图 2.题目要求 1234567891011121. 点击头像,弹出侧边菜单2. 使用图标组件实现侧边页面布局3. 侧边数据使用ngFor指令渲染4. 侧边列表的实现使用ionic的列表组件5. 实现底部导航6. 在qq首页完成数据渲染7. 使用ngFor指令配合ionic列表组件实现页面布局(avatar)8. 正确使用徽章组件9. 实现页面导航效果----点击钱包,进行页面跳转10. 在聊天页面点击每一条都能够跳转到聊天页面 知识点补充-数据请求数据请求的实现 123456789101112131415161718192021222324252627281.导入请求模块,在angular中,使用什么东西首先要在app.module中导入 import &#123; HttpModule &#125; from &apos;@angular/http&apos;; 并将导入的模块添加到 @NgModule 的 imports中2.在需要的地方导入http模块,也就是说要在哪里发送请求,就在哪里导入http模块(类)即可 import &#123; Http &#125; from &apos;@angular/http&apos;; 3.将到如的模块注入到构造函数中 constructor(private $http: Http) &#123; &#125;4.发送请求,获取数据 ngOnInit() &#123; const url = &quot;http://127.0.0.1/00-exam/1508A/week1/select.php&quot; this.$http.get(url) .subscribe((res)=&gt;&#123; //调用 HTTP 的Reponse对象的json方法，以提取出其中的数据 console.log(res.json()) //将我们读取到的数据赋值给数据并进行渲染就可以了 &#125;) //捕获错误 -------------------------------------根据需要选择 .catch((error)=&gt;&#123; console.log(error) &#125;) &#125; 掌阅读书 使用swipe事件进行操作,模拟实现翻页效果 因为没有可用的数据接口 当滑动的时候加载下一页数据即可 1.案例效果图以及说明 2.要求 1234561.滑动的时候实现翻页效果,翻页数据使用其他的接口进行模拟,重点是实现的思路 //分页数据 //第一页 offet=0 //第二页 offet=6 //第三页 offet=12 //http://musicapi.duapp.com/api.php?type=topPlayList&amp;cat=%E5%85%A8%E9%83%A8&amp;offset=0&amp;limit=6 网易云音乐1.题目描述 可以通过tabsPlacement控制tabs导航显示的位置,默认值是bottom , 还可以是top 请求数据,完成歌单渲染,点击歌单,进入歌曲列表,点击列表,实现音乐播放 2.数据接口 12345678//获取歌单//http://musicapi.duapp.com/api.php?type=topPlayList&amp;cat=%E5%85%A8%E9%83%A8&amp;offset=0&amp;limit=6//获取播放列表详情//https://api.imjad.cn/cloudmusic/?type=playlist&amp;id= 736235890//根据id获取歌曲//http://musicapi.duapp.com/api.php?type=url&amp;id= 739467315 3.效果图 1.歌单页面 2.播放列表页面 和 3.音乐播放页面","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"04-组件使用下","slug":"ionic2/04-ionic组件的使用-下","date":"2018-05-10T00:35:17.953Z","updated":"2018-05-10T01:27:38.500Z","comments":true,"path":"2018/05/10/ionic2/04-ionic组件的使用-下/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/04-ionic组件的使用-下/","excerpt":"","text":"组件使用下 在这一部分,主要是学习ionic标签组件/属性以及其他相关内容的使用 组件工具栏组件 toolbar 将页面按照一定的结构进行划分 1234567891011121314151617181920212223&lt;!--页面头部--&gt;&lt;ion-header&gt; &lt;!--导航组件--&gt; &lt;ion-navbar&gt; &lt;!--标题组件--&gt; &lt;ion-title&gt; Ionic Blank &lt;/ion-title&gt; &lt;/ion-navbar&gt;&lt;/ion-header&gt;&lt;!--页面中间部分--&gt;&lt;ion-content padding&gt;&lt;/ion-content&gt;&lt;!--页面底部--&gt;&lt;ion-footer&gt;&lt;/ion-footer&gt; 补充 123Toolbar可以⽤来当做App的header， sub-header,footer,sub-footer因为ion-toolbar基于flexbox， 所以不管你在⻚⾯中放⼏个Toolbar， 它们都能正确显⽰， ion-content会⾃动调整适应。 ⼀般情况下， NavBar会放在ion-header⾥， ⽤来配合导航。 也可以通过设置color属性来改变toolbar的颜⾊。 当把Toolbar当做footer来⽤的时候， 可以⽤ion-footer来代替ion-toolbar。 列表组件 列表组件通常情况下配合ngFor指令使用 知识点扩展 123456789属性: no-lines:在列表项之间隐藏分隔线 inset: 添加外部边距标签: ion-list-header:添加表头 ion-icon:添加图标 ion-avatar: 添加头像 button/按钮 使用的方式类似于bootstrap,但是在这里是以属性的方式添加 按钮大致可以分为以下几部分 图片/文本/图标…… 123456789101112131415161718192021222324基本按钮 --------------ion-button不能以 标签的形式存在 ion-button &lt;button ion-button&gt;Button&lt;/button&gt;添加颜色 color &lt;button ion-button color=&quot;light&quot;&gt;Light&lt;/button&gt;轮廓 outline &lt;button ion-button color=&quot;light&quot; outline&gt;Light Outline&lt;/button&gt;圆形边框 round &lt;button ion-button color=&quot;light&quot; round&gt;Light Round&lt;/button&gt;清晰风格 clear &lt;button ion-button color=&quot;light&quot; clear&gt;Light Clear&lt;/button&gt;块按钮 block &lt;button ion-button block&gt;Block Button&lt;/button&gt;全按钮 full &lt;button ion-button full&gt;Full Button&lt;/button&gt;按钮大小 large/small &lt;button ion-button large&gt;Large&lt;/button&gt; badges/徽章 Badges(徽章)常常⽤来展⽰给⽤户⼀个数字。 它常⽤于列表项内的数字展⽰。 1234//可以使用color属性指定颜色&lt;ion-badge&gt;&lt;/ion-badge&gt; icon/图标 你可以理解成是通过某种手段绘制出来的东西,只需要会使用即可 12345name属性: 指定图标样式color属性: 指定图标颜色 isActive属性: 指定图标是否激活的状态&lt;ion-icon name=&quot;heart&quot; color=&quot;danger&quot; &gt;&lt;/ion-icon&gt; 更多图标内容请查看此链接 fabs/弹出小图标 可以以更好的体验形式实现页面上常见的分享效果 代码不做详解 123456789101112131415161718192021222324 &lt;ion-content&gt; &lt;!-- Real floating action button, fixed. It will not scroll with the content --&gt; &lt;ion-fab top right edge&gt; &lt;button ion-fab mini&gt;&lt;ion-icon name=&quot;add&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;ion-fab-list&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-facebook&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-twitter&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-vimeo&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-googleplus&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;/ion-fab-list&gt; &lt;/ion-fab&gt; &lt;ion-fab right bottom&gt; &lt;button ion-fab color=&quot;light&quot;&gt;&lt;ion-icon name=&quot;arrow-dropleft&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;ion-fab-list side=&quot;left&quot;&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-facebook&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-twitter&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-vimeo&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;button ion-fab&gt;&lt;ion-icon name=&quot;logo-googleplus&quot;&gt;&lt;/ion-icon&gt;&lt;/button&gt; &lt;/ion-fab-list&gt; &lt;/ion-fab&gt;&lt;/ion-content&gt; segment/选项卡/分割 选项卡是借助于switch case实现的 在ionic/angular中,提供了ngSwitch和ngSwitchCase指令 当然,我们也可以使用ngIf实现 下面看一下ionic本身提供的选项卡 代码部分不做过多讲解 1234567891011121314151617181920212223242526272829303132&lt;div padding&gt; &lt;ion-segment [(ngModel)]=&quot;pet&quot;&gt; &lt;ion-segment-button value=&quot;kittens&quot;&gt; Kittens &lt;/ion-segment-button&gt; &lt;ion-segment-button value=&quot;puppies&quot;&gt; Puppies &lt;/ion-segment-button&gt; &lt;/ion-segment&gt;&lt;/div&gt;&lt;div [ngSwitch]=&quot;pet&quot;&gt; &lt;ion-list *ngSwitchCase=&quot;&apos;puppies&apos;&quot;&gt; &lt;ion-item&gt; &lt;ion-thumbnail item-start&gt; &lt;img src=&quot;img/thumbnail-puppy-1.jpg&quot;&gt; &lt;/ion-thumbnail&gt; &lt;h2&gt;Ruby&lt;/h2&gt; &lt;/ion-item&gt; ... &lt;/ion-list&gt; &lt;ion-list *ngSwitchCase=&quot;&apos;kittens&apos;&quot;&gt; &lt;ion-item&gt; &lt;ion-thumbnail item-start&gt; &lt;img src=&quot;img/thumbnail-kitten-1.jpg&quot;&gt; &lt;/ion-thumbnail&gt; &lt;h2&gt;Luna&lt;/h2&gt; &lt;/ion-item&gt; ... &lt;/ion-list&gt;&lt;/div&gt; grid 栅格布局123456789&lt;ion-grid&gt; &lt;ion-row&gt; &lt;!--页面横向分为12部分,每一个占据一半--&gt; &lt;ion-col col-6&gt;&lt;/ion-col&gt; &lt;ion-col col-6&gt;&lt;/ion-col&gt; &lt;/ion-row&gt; &lt;/ion-grid&gt; card/卡片 这一部分完全可以使用自定义样式实现 123456ion-card&gt;ion-card-header+ion-card-content &lt;ion-card&gt; &lt;ion-card-header&gt;&lt;/ion-card-header&gt; &lt;ion-card-content&gt;&lt;/ion-card-content&gt; &lt;/ion-card&gt; gesture/手势 这个组件涉及的是移动端的一些相关的事件操作 具体的使用方式可以参考点击事件 点击事件 1234(click)=&quot;fn()&quot;fn()&#123;console.log(1)&#125; gesture事件 12345678910111213(pan)=&quot;fn()&quot;fn()&#123;console.log(1)&#125;//以下内容自行理解 pan 触屏上手指按下滑动的过程中一直触发 press 按下触发一次 tap 点击 swipe 上下左右滑动 slide/幻灯片/轮播 基本实现 123456789101112131415&lt;ion-slides pager&gt; &lt;ion-slide style=&quot;background-color: green&quot;&gt; &lt;h2&gt;Slide 1&lt;/h2&gt; &lt;/ion-slide&gt; &lt;ion-slide style=&quot;background-color: blue&quot;&gt; &lt;h2&gt;Slide 2&lt;/h2&gt; &lt;/ion-slide&gt; &lt;ion-slide style=&quot;background-color: red&quot;&gt; &lt;h2&gt;Slide 3&lt;/h2&gt; &lt;/ion-slide&gt;&lt;/ion-slides&gt; 更多内容请参考此链接 searchbar/模糊搜索 这一部分不做讲解 使用我们学过的js的相关知识实现 表单1234输入框: ion-input单选框: radio select/下拉框1234567891011121314&lt;ion-list&gt; &lt;ion-item&gt; &lt;ion-label&gt;Gaming&lt;/ion-label&gt; &lt;ion-select [(ngModel)]=&quot;gaming&quot;&gt; &lt;ion-option value=&quot;nes&quot;&gt;NES&lt;/ion-option&gt; &lt;ion-option value=&quot;n64&quot;&gt;Nintendo64&lt;/ion-option&gt; &lt;ion-option value=&quot;ps&quot;&gt;PlayStation&lt;/ion-option&gt; &lt;ion-option value=&quot;genesis&quot;&gt;Sega Genesis&lt;/ion-option&gt; &lt;ion-option value=&quot;saturn&quot;&gt;Sega Saturn&lt;/ion-option&gt; &lt;ion-option value=&quot;snes&quot;&gt;SNES&lt;/ion-option&gt; &lt;/ion-select&gt; &lt;/ion-item&gt;&lt;/ion-list&gt; toggle/开关 看文档 综合练习1.效果图 2.题目描述 12345678功能点1 点击展开左侧菜单功能点2 路由切换功能功能点3 浮动按钮的展功能点4 左侧菜单展开后的头部布功能点5 左侧菜单展开后的主体布功能点6 文件夹的列表获取功能点7 点击标签显示“添加标签让您更容易找到您的笔记”功能点8 近期文章列表里的下拉刷新功","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"03-组件使用上","slug":"ionic2/03-ionic组件的使用-上","date":"2018-05-10T00:35:17.933Z","updated":"2018-05-10T01:27:31.000Z","comments":true,"path":"2018/05/10/ionic2/03-ionic组件的使用-上/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/03-ionic组件的使用-上/","excerpt":"","text":"组件使用上参考链接 下面这几部分内容为讲解的重点 ionic官网 ionic的API文档 ionic主题配置文档 —theme 指令和语法为了更好的使用组件,先讲解一部分基本语法 接触过vue框架的情况下,对于这一部分内容更容易理解 在这里具体的使用方式不再多做讲解 基本语法123456数据显示 &#123;&#123;&#125;&#125;列表渲染 *ngFor=&quot;let data of arr let i=index&quot;条件判断 *ngIf=&apos;bool&apos; 属性绑定 可以有两种实现形式 12&lt;img src=&quot;&#123;&#123;imgUrl&#125;&#125;&quot; alt=&quot;&quot; /&gt;&lt;img [src]=&quot;imgUrl&quot; alt=&quot;&quot; /&gt; 事件绑定 可以有两种实现方式 12on-click=&quot;fn()&quot;(click)=&quot;fn()&quot; 综合练习 使用以上知识点完成一下练习 1234要求: 1. 使用*ngIf实现选项卡切换效果 2. 使用*ngFor指令完成列表渲染和索引值添加 3. 使用&#123;&#123;&#125;&#125;语法完成数据显示 组件使用 ionic初体验 先了解一下页面常见的效果 menu 实现的效果 点击左上角的菜单项,弹出侧边菜单** 代码实现 在跟组件实现 —- 也就是app组件 12345678910111213141516171819202122232425&lt;ion-menu [content]=&quot;content&quot;&gt; &lt;ion-header&gt; &lt;ion-toolbar&gt; &lt;ion-title&gt;Menu&lt;/ion-title&gt; &lt;/ion-toolbar&gt; &lt;/ion-header&gt; &lt;ion-content&gt; &lt;ion-list&gt; &lt;button ion-item (click)=&quot;openPage(homePage)&quot;&gt; Home &lt;/button&gt; &lt;button ion-item (click)=&quot;openPage(friendsPage)&quot;&gt; Friends &lt;/button&gt; &lt;button ion-item (click)=&quot;openPage(eventsPage)&quot;&gt; Events &lt;/button&gt; &lt;button ion-item (click)=&quot;closeMenu()&quot;&gt; Close Menu &lt;/button&gt; &lt;/ion-list&gt; &lt;/ion-content&gt;&lt;/ion-menu&gt;&lt;ion-nav id=&quot;nav&quot; #content [root]=&quot;rootPage&quot;&gt;&lt;/ion-nav&gt; 相关api 详情可查阅api文档 1234567891011121314151617181920212223242526272829menuToggle : 实现菜单栏的切换menuClose : 关闭菜单栏js控制: 三步操作实现菜单打开/关闭/切换 1. 导入控制器类 import &#123; MenuController &#125; from &apos;ionic-angular&apos;; 2. 注入到构造函数 constructor(public menuCtrl: MenuController) &#123;&#125; 3. 调用方法 (要实现什么样的功能,调用对应的方法即可) openMenu() &#123; this.menuCtrl.open(); &#125; closeMenu() &#123; this.menuCtrl.close(); &#125; toggleMenu() &#123; this.menuCtrl.toggle(); &#125; tabs导航 效果: 底部导航栏 实现手机应用上常见的底部菜单导航效果 组件树 tabs组件的实现较为复杂 在完成这部分内容之前,先理解一下组件的组织结构 以下面一幅图为例 在ionic中,整个应用程序中使用到的组件必须在根模块app.module下完成配置大致如下: tabs实现步骤1. 生成导航的组件 也就是完成组件的创建 —-生成组件tab1 tab2 tab3 ionic g page tab1 ——————使用ionic命令生成页面 ionic g page tab2 ionic g page tab3 2. 配置根模块 可以理解为以app.component为根组件构建组件树 3.实现tabs导航 这一部分参考官网内容即可 作业要求作业1 中间列表部分使用自定义json数据文件实现 ionic组件(js部分) ionic以组件的形式提供了很多好用的效果,提供良好的用户体验以部分组件为例,讲解ionic组件的使用方式 Action Sheets/行动表 ActionSheet是从屏幕底部滑出的， 带着确认(confirm)和取消(cancel)操作的选项集合。 ActionSheet可以⽤作菜单的替换， 但是不能作为导航的替换 实现步骤 1234567891011121314151617181920212223242526272829303132333435361. 导入控制器类 import &#123; ActionSheetController &#125; from &apos;ionic-angular&apos;;2. 注入到构造函数 constructor(public actionSheetCtrl: ActionSheetController) &#123; &#125;3. 调用方法----执行这个方法即可创建弹出框 presentActionSheet() &#123; let actionSheet = this.actionSheetCtrl.create(&#123; //定义标题 title: &apos;Modify your album&apos;, //定义按钮 buttons: [ &#123; //文本和角色和处理点击时的响应事件 text: &apos;Destructive&apos;, role: &apos;destructive&apos;, handler: () =&gt; &#123; console.log(&apos;Destructive clicked&apos;); &#125; &#125;,&#123; text: &apos;Archive&apos;, handler: () =&gt; &#123; console.log(&apos;Archive clicked&apos;); &#125; &#125;,&#123; text: &apos;Cancel&apos;, role: &apos;cancel&apos;, handler: () =&gt; &#123; console.log(&apos;Cancel clicked&apos;); &#125; &#125; ] &#125;); actionSheet.present(); &#125; alert/警告 提示框/弹出框 1234567891011121314151. 导入控制器类 import &#123; AlertController &#125; from &apos;ionic-angular&apos;;2. 注入到构造函数 constructor(public alertCtrl: AlertController) &#123;&#125;3. 调用方法 showAlert() &#123; let alert = this.alertCtrl.create(&#123; title: &apos;New Friend!&apos;, subTitle: &apos;Your friend, Obi wan Kenobi, just accepted your friend request!&apos;, buttons: [&apos;OK&apos;] &#125;); alert.present(); &#125; 流程化操作 根据以上两个示例我们可以看到使用ionic组件(或者是angular)的一个流程化操作 组件(js操作)三步 1231. 导入控制器类(模块)2. 注入到构造函数3. 调用方法 toast/通知1234567891011121314import &#123; ToastController &#125; from &apos;ionic-angular&apos;;export class MyPage &#123; constructor(public toastCtrl: ToastController) &#123; &#125; presentToast() &#123; let toast = this.toastCtrl.create(&#123; message: &apos;User was added successfully&apos;, duration: 3000 &#125;); toast.present(); &#125;&#125; modals/模态框12345678910111213import &#123; ModalController &#125; from &apos;ionic-angular&apos;;import &#123; ModalPage &#125; from &apos;./modal-page&apos;;export class MyPage &#123; constructor(public modalCtrl: ModalController) &#123; &#125; presentModal() &#123; let modal = this.modalCtrl.create(ModalPage); modal.present(); &#125;&#125; Popover/弹出框123456789101112import &#123; PopoverController &#125; from &apos;ionic-angular&apos;;import &#123; MyPopOverPage &#125; from &apos;./my-pop-over&apos;;export class MyPage &#123; constructor(public popoverCtrl: PopoverController) &#123; &#125; presentPopover() &#123; let popover = this.popoverCtrl.create(MyPopOverPage); popover.present(); &#125;&#125; 综合练习 1.数据 12345678910111213Arr = [ &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;上海&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;广州&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;, &#123;&quot;address&quot;:&quot;北京&quot;,&quot;money&quot;:&quot;20000&quot;,&quot;compony&quot;:&quot;八维研修&quot;&#125;] 2.题目描述 12341.)当点击”城市”，弹出北京、上海、广州2.)点击”薪资”，弹出2.5K、5K、10K3.)当点击”公司”，弹出中软、浪潮、用友4.)按照用户的选择对列表进行过滤 3、案例完成思路要求: 12345(1)在Ionic的TS文件中声明数组(2)在html页面渲染数组(3)当点击选项的时候，进行过滤(4)当点击每一项时，弹出这一项在列表中的索引位置 4.评分明细 123456789101.良好的注释（10分）2.正确的制作三个滑出控件的数据(10分)3.正确的使用ion-button和给按钮正确的注册事件（10分）4.正确的使用ActionShetConroller（10分）5.正确的制作列表数据（10分）6.正确的使用ion-list控件（10分）7.选中城市或薪资或公司能正确过滤列表数据（10分）8.当取消选中城市或薪资或公司的时候能正确过滤数据（10分）9.点击每一项弹出每一项的索引位置(10分)10.良好的布局（10分）","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"02-ionic的安装与使用","slug":"ionic2/02-ionic安装与使用","date":"2018-05-10T00:35:17.132Z","updated":"2018-05-10T01:27:17.145Z","comments":true,"path":"2018/05/10/ionic2/02-ionic安装与使用/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/02-ionic安装与使用/","excerpt":"","text":"ionic的安装与使用ionic的安装与启动步骤vue项目模板的安装步骤 12345671. npm install -g vue-cli2. vue init webpack vueproject 项目名称(也就是文件夹名称)3. cd vueproject4. npm install5. npm run dev6. npm run build ionic项目模板的安装步骤 123451. npm install -g ionic2. ionic start projectname3. cd projectname4. ionic serve5. ionic build 1.在node环境的基础下适用npm进行全局安装 推荐在使用之前统一下node和npm的版本,要不然可能会存在一系列的问题 在这里 cordova 可以先安装上,cordova的作用是打包手机app,但是配置的过程比较繁琐,我们会在这里使用一种新的方式进行 1npm install -g ionic 2.全局安装完成之后创建一个项目 1234567891011//使用ionic命令开始创建一个项目模板ionic start projectName//在ionic中提供了多种多样的模板ionic start projectName 可选参数 tabs ：一个简单的3选项卡布局 sidemenu：侧面有可滑动菜单的布局 blank:一个单独的启动器 super：启动项目超过14个可以使用的页面设计 tutorial: 一个引导项目 3.切换到项目目录 1cd projectName 4.启动项目 1ionic serve 5.项目打包 1ionic build ionic项目的启动和基本使用 安装项目模板 ionic start projectName 可选参数 根据不同的参数可以生成不同的项目模板 空模板-blank 导航模板-tabs 侧边菜单模板 -sidemenu 辅助命令 在ionic中,除了直接生成模板的命令之外,还提供了一些其他的命令 创建一个新的页面 12//使用ionic命令生成一个页面 g:generateionic g page pageName 当然还有一些其他的扩展命令,这些命令后期会进行详细讲解 1Ionic CLI 可以生成 pages, providers, tabs, pipes, components，directives等。 项目目录结构 以空模板目录结构为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445├─node_modules --------------------------------依赖包的目录├─resources --------------------------------使用cordova打包(android/ios)需要的资源目录│ │ icon.png --------------------------------图标│ │ README.md --------------------------------使用说明│ │ splash.png ---------------------------------启动页│ │ │ ├─android ---------------------------------跨平台打包生成android应用的相关资源│ │ ├─icon │ │ └─splash │ └─ios ---------------------------------跨平台打包生成ios应用的相关资源│ ├─icon │ └─splash│ ├─src ---------------------------------整个应用程序的代码以及相关配置的目录│ │ index.html│ │ manifest.json │ │ service-worker.js│ │ │ ├─app --------------------------------整个应用程序的根组件│ │ app.component.ts│ │ app.html│ │ app.module.ts│ │ app.scss│ │ main.ts│ │ │ ├─assets ---------------------------------静态资源目录│ │ ├─icon│ │ │ favicon.ico │ │ │ │ │ └─imgs│ │ logo.png│ │ │ ├─pages ---------------------------------应用程序的组件/页面所在目录│ │ └─home│ │ home.html│ │ home.scss│ │ home.ts│ │ │ └─theme ---------------------------------应用程序的主题目录│ variables.scss ---------------------------------应用程序的配置目录│ └─www ----------------------------------应用程序打包之后的资源目录 .gitkeep manifest.json service-worker.js 目录结构详解 1231. 在应用程序中,所有的静态资源可以放到assets目录(css/js/图片.......) 使用的时候直接以./assets/.....2. 应用程序使用到的组件/管道/指令/模块等内容都需要在跟模块app.module文件下完成配置 补充 cordova打包现阶段,有很多工具都可以打包生成应用程序,不必再依赖于cordova,这一部分知识点可以作为 可以搜索搭建android开发环境 参考链接:android开发环境 参考","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"01-ionic知识点","slug":"ionic2/01-ionic概述","date":"2018-05-10T00:35:17.124Z","updated":"2018-05-10T01:27:11.161Z","comments":true,"path":"2018/05/10/ionic2/01-ionic概述/","link":"","permalink":"http://yoursite.com/2018/05/10/ionic2/01-ionic概述/","excerpt":"","text":"ionic知识点哈哈哈哈哈群威群胆无qhh ionic2概述课程简介 本门课程大致可以分为三部分内容 12345ionic2 类似于muse-ui,mui,element-ui,是一个ui框架typescript 一种版本的jsangular2 前端流行框架之一 1.ionic是什么? 一款优秀的跨平台移动端开发框架 你可以理解成是vue的ui框架,例如 muse-ui mint-ui element-uiionic基于google的angular2,使用typescript语言编写 typescript是什么? 123456js:es6:第六代版本的jstypescript:是js的超集,使用后端语言的规范,对js的语法进行了扩展 可以看做是一种面向对象的js语言版本 2.ionic能做什么? ionic框架的目的是以web技术开发移动端应用程序 配合 apache 服务器的 cordova的编译平台,实现了编译打包成各个移动操作平台适配的移动端应用 通过cordova平台打包,能够实现多平台共用一套代码 123android平台ios平台window平台 3.如何使用ionic2 ionic提供了cli,只需要一个命令就可以创建应用的初始框架 具体如何使用,下章节讲解 认识ionic2几点基本概念 1234567891011121314151617跨平台开发: 简单来说就是一套代码, 多个平台都可以使用cordova和phonegap: PhoneGap或Cordova将做好的东西打包生成手机app,这项技术可以让开发人员使用Web技术开发出媲美原生App的移动应用。 但是Cordova只提供了使用 JavaScript 调用 Native 功能， 在开发的时候还需要开发人员自己去实现诸如样式美化、页面切换、数据展示、弹出框、Modal窗体、日期选择器等功能或组件， 为了提高开发效率，出现了各种前端框架，如 Ionic、 JQuery Mobile UI、 Sencha Touch、 Framework7等。需要复杂的配置过程,这一部分不作为重点讲解,我们会使用一种替代方案ionic: 前端框架,用来实现页面效果,对 Angular 进行了封装，提供了一套适配各移动平台UI风格的前端组件， 使用 Cordova 进行打包，可以让开发人员免去调试大量 CSS 的工作，专注业务逻辑开发即可。Ionic2 基于 Angular 开发(ionic1基于angularjs,由于AngularJS 1.x版本在性能上已经很难有较大提升， Google 又推出了全新设计的 Angular 2) ionic2介绍123456789Ionic 2 专注于以标准的HTML、CSS和JavaScript来构建移动站点，并可以通过Cordova打包成移动App，只需编写一次代码，就可以分别部署到 iOS 、Android 等多种移动平台上。这项技术已经帮助很多开发者创建了很多漂亮的 App。现在 Ionic 2 已经发布了第二代版本，使移动开发更容易、更有效率。Ionic 2 与一代相比有较大的变化，基于最新的 Angular 2 ，使用 TypeScript进行开发，如果您没有接触过 AngularJS或Ionic1.x，完全不用担心，直接从Ionic 2` 开始学习即可。在使用 Ionic 2 之前，您应该具备 HTML、CSS、JavaScript 基础。 ionic的优势和不足 Ionic 2 借助 Angular 2 的革命性改进，与 1.x 版本相比具有以下优势： 更快的性能 123Angular 1 的检测机制在某些场景下会导致性能降低，由于最初的架构限制已经很难进行提升了。Angular 2 有效避免了这种情况。数据显示 Angular 2 比Angular 1 快5到10倍。官方提供了一个动画来展示 Ionic 2 的性能提升： 更加清晰的结构 12345678910Angualr 2 应用是模块化的，因此Ionic 2的项目结构比Ionic 1更为清晰，如：-home.page--home.page.ts--home.page.html--home.page.scss-about.page--about.page.ts--about.page.html--about.page.scss每个页面的代码、模板、样式都放在一块，意义非常清晰。 更强大的CLI 12345678Ionic CLI 提供了更强大的功能，如添加一个页面，可以使用以下命令：ionic g page NewPageIonic CLI 会生成以下的文件，并且文件中已经生成了基本的代码：-new-page--new-page.ts--new-page.html--new-page.scssIonic CLI 可以生成 pages, providers, tabs, pipes, components，directives等。 更友好的页面导航123456789101112131415161718Ionic 2 的导航方式相比一代有了巨大的改进，完全进行了重写。在 Ionic 1.x 中，需要配置路由： .config(function($stateProvider, $urlRouterProvider) &#123; $stateProvider .state(&apos;home&apos;, &#123; url: &apos;/&apos;, templateUrl: &apos;templates/home.html&apos;, controller: &apos;HomeCtrl&apos; &#125;) .state(&apos;main&apos;, &#123; url: &apos;/main&apos;, templateUrl: &apos;templates/main.html&apos;, controller: &apos;MainCtrl&apos; &#125;); $urlRouterProvider.otherwise(&quot;/&quot;); &#125;);Ionic 2抛弃了这种繁琐的方式，更类似原生的开发体验，一行代码即可搞定：this.nav.push(SecondPage);使用全新的NavController组件，导航栈的操作方式更加方便，实现前进、后退等功能就像操作数组那么简单。 更强大的模板语法 Angular2的模板语法刚接触时可能会觉得有点难以上手，但熟悉之后就能够更加灵活的控制单向绑定、双向绑定、事件绑定等各种功能。 更高效的开发体验12基于 TypeScript，使用 Ionic 2 拥有更好的开发体验，支持类、模块、接口、lambda表达式等新的特性，大大改善了 JavaScript的开发体验。当然你需要一个好的编辑器，如VS Code： 强大的智能感知 自定义的类都可以哦，真的有点开发强类型语言的感觉啊 8-)当然，因为最终还是要依靠 Cordova 进行打包，因此不可避免的会遇到所有 Cordova 类跨平台应用面临的问题，在某些性能较差的移动设备上渲染速度较慢。Ionic 2 已经明确提出不支持低版本 Android 设备，并且在 Angular 2正式版发布以后，支持 AoT 编译也会在一定程度上优化 App 性能。","categories":[{"name":"ionic2","slug":"ionic2","permalink":"http://yoursite.com/categories/ionic2/"}],"tags":[]},{"title":"controller","slug":"angular1/04-模块/043-控制器","date":"2018-05-10T00:34:45.776Z","updated":"2018-05-10T01:11:12.575Z","comments":true,"path":"2018/05/10/angular1/04-模块/043-控制器/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/04-模块/043-控制器/","excerpt":"","text":"controller-控制器 控制angularjs应用程序的数据 控制器是常规的js对象,由javascripe对象的构造函数创建 ng-controller指令指定应用程序的所使用的制器 添加控制器 护手霜就是 程序代码 12345678910111213//------------2 &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;...&lt;/div&gt;&lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); //添加控制器----作用域当做参数传递 app.controller(&quot;myController&quot;,function($scope)&#123; &#125;)&lt;/script&gt; 代码解析 12345678910111. ng-app 声明一个应用程序,它 的值指定 这个应用程序使用了哪个模块2. ng-controller 定义一个控制器,表示当前应用或标签使用了哪个控制器3. angular.module(): 使用angular的module方法创建一个模块4. 使用模块的controller方法创建控制器 控制器方法有两个属性 第一个属性: 控制器的名称 第二个属性: 一个方法,传入作用域,可以用来定义数据模型 在控制器上添加方法以及方法的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&apos;myCtl&apos;&gt; &lt;!--使用$scope的属性--&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;!--使用$scope的方法--&gt; &lt;p&gt;&#123;&#123;fn()&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app = angular.module(&apos;app&apos;,[]) //在模块上添加控制器 app.controller(&apos;myCtl&apos;,function($scope)&#123; //在控制器上添加属性 $scope.name = &quot;高辉&quot;; //在控制器上添加方法 $scope.fn = function()&#123; //存在的问题,这个方法为什么会执行三次 console.log(1) return &quot;name&quot;+ &quot; &quot;+ $scope.name &#125; &#125;)&lt;/script&gt; 外部文件中的控制器 直接将页面中script标签内部的代码剪切到一个js文件中,再将js文件引入即可","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"04-模块","slug":"angular1/04-模块","permalink":"http://yoursite.com/categories/angular1/04-模块/"}],"tags":[]},{"title":"作用域","slug":"angular1/04-模块/042-作用域","date":"2018-05-10T00:34:45.773Z","updated":"2018-05-10T01:11:16.747Z","comments":true,"path":"2018/05/10/angular1/04-模块/042-作用域/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/04-模块/042-作用域/","excerpt":"","text":"scoped-作用域 Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。 Scope 是一个对象，有可用的方法和属性。 Scope 可应用在视图和控制器上。 在在angularjs中创建控制器的时候,你可以将$scope对象当做一个参数来传递 实例演示123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--4. 创建一个应用,并指定这个应用使用的控制器--&gt; &lt;div ng-app=&quot;myapp&quot; ng-controller=&apos;myController&apos;&gt; &lt;!-- 5. 在视图中使用$scope对象中添加的属性 不需要添加$scope,直接使用即可 --&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建一个模块 var app = angular.module(&apos;myapp&apos;,[]); //2. 在模块上添加控制器,并传入作用域这个特殊参数 app.controller(&apos;myController&apos;,function($scope)&#123; //3. 给$scope对象添加一个属性,在视图中能够直接使用 $scope.name = &quot;gaohui&quot; &#125;)&lt;/script&gt; $scope概述scope是angularjs的数据模型部分 $scope是一个对象,这个对象中有属性和方法,可以直接在视图和控制器中使用 $scope的作用域是局部的 $rootScope根作用域所有的应用程序都有一个跟作用域,可以作用于ng-app指令包含下的所有的html元素 $rootScope作用于整个应用程序,是各个controller中scope的桥梁 使用rootScope定义的值,可以在各个控制器(controller)中使用 12","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"04-模块","slug":"angular1/04-模块","permalink":"http://yoursite.com/categories/angular1/04-模块/"}],"tags":[]},{"title":"模块","slug":"angular1/04-模块/041-模块","date":"2018-05-10T00:34:45.770Z","updated":"2018-05-10T01:11:21.504Z","comments":true,"path":"2018/05/10/angular1/04-模块/041-模块/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/04-模块/041-模块/","excerpt":"","text":"模块模块的基本概念 模块定义了一个应用程序 模块是应用程序中不同部分的容器 模块是应用控制器的容器 控制器通常属于一个模块 模块的定义 可以通过angular.module()函数来创建一个模块 第一个参数对应的是执行应用程序的html元素 12345678//------------1 &lt;div ng-app=&quot;myApp&quot;&gt;...&lt;/div&gt;&lt;script&gt; var app = angular.module(&quot;myApp&quot;, []);&lt;/script&gt; 创建好模块之后,就可以在angularjs中添加控制器,过滤器,指令 在创建好的模块上进行控制器的添加12345678910111213//------------2 &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;...&lt;/div&gt;&lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); //添加控制器----作用域当做参数传递 app.controller(&quot;myController&quot;,function($scope)&#123; &#125;)&lt;/script&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"04-模块","slug":"angular1/04-模块","permalink":"http://yoursite.com/categories/angular1/04-模块/"}],"tags":[]},{"title":"全局api","slug":"angular1/19-conclusion/19-知识点总结","date":"2018-05-10T00:34:45.767Z","updated":"2018-05-10T01:12:35.548Z","comments":true,"path":"2018/05/10/angular1/19-conclusion/19-知识点总结/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/19-conclusion/19-知识点总结/","excerpt":"","text":"angularsjs参考手册AngularJS 指令本教程中使用的 AngularJS 指令： 指令 描述 讲解 ng_app 定义应用程序的根元素。 指令 ng_bind 绑定 HTML 元素到应用程序数据。 简介 ng_click 定义元素被单击时的行为。 HTML 事件 ng_controller 为应用程序定义控制器对象。 控制器 ng_disabled 绑定应用程序数据到 HTML 的 disabled 属性。 HTML DOM ng_init 为应用程序定义初始值。 指令 ng_model 绑定应用程序数据到 HTML 元素。 指令 ng_repeat 为控制器中的每个数据定义一个模板。 指令 ng_show 显示或隐藏 HTML 元素。 HTML DOM AngularJS 过滤器本教程中使用的 AngularJS 过滤器： 过滤器 描述 currency 格式化数字为货币格式。 filter 从数组项中选择一个子集。 lowercase 格式化字符串为小写。 orderBy 根据某个表达式排列数组。 uppercase 格式化字符串为大写。","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"19-conclusion","slug":"angular1/19-conclusion","permalink":"http://yoursite.com/categories/angular1/19-conclusion/"}],"tags":[]},{"title":"ng路由","slug":"angular1/18-router/18-angularjs路由","date":"2018-05-10T00:34:45.764Z","updated":"2018-05-10T01:12:39.802Z","comments":true,"path":"2018/05/10/angular1/18-router/18-angularjs路由/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/18-router/18-angularjs路由/","excerpt":"","text":"ng路由 路由允许我们使用不同的 url 访问 不同的内容 通过路由操作可以实现单页面应用 路由的配置配置路由的一般流程 引入实现路由的 js 文件：angular-route.js。 1&lt;script src=&quot;http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js&quot;&gt;&lt;/script&gt; 创建一个模块并注入ngRoute(路由)依赖 1var app = angular.module(&apos;app&apos;,[&apos;ngRoute&apos;]) 进行路由的配置 123456789101112131415app.config([&apos;$routeProvider&apos;, function($routeProvider) &#123; $routeProvider .when(&apos;/&apos;, &#123; template: &apos;&lt;h1&gt;home&lt;/h1&gt;&apos; &#125;) .when(&apos;/about&apos;, &#123; template: &apos;&lt;h1&gt;about&lt;/h1&gt;&apos; &#125;) .when(&apos;/login&apos;, &#123; template: &apos;&lt;h1&gt;login&lt;/h1&gt;&apos; &#125;) .otherwise(&#123; template: &apos;&lt;h1&gt;404&lt;/h1&gt;&apos; &#125;) &#125;]) 简单解析 angularjs模块的config函数用于进行路由的配置 * ----通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数 * ----并且使用$routeProvider.whenAPI来定义我们的路由规则。 * $routeProvider 为我们提供了 when(path,object) &amp; otherwise(object) 函数按顺序定义所有路由，函数包含两个参数:第一个参数是 URL 或者 URL 正则规则。第二个参数是路由配置对象。 在页面上定义路由跳转的链接,也就是 a 链接 123456&lt;div class=&quot;router&quot;&gt; &lt;a href=&quot;#/&quot;&gt;home&lt;/a&gt; &lt;a href=&quot;#/about&quot;&gt;about&lt;/a&gt; &lt;a href=&quot;#/login&quot;&gt;login&lt;/a&gt; &lt;a href=&quot;#/404&quot;&gt;404&lt;/a&gt;&lt;/div&gt; 路由对应内容的显示 1&lt;div ng-view id=&quot;view&quot;&gt;&lt;/div&gt; 完整的实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--1. cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular-animate.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; #view &#123; width: 500px; margin: 0 auto; border: 1px solid red; height: 300px; background: pink; &#125; .router&#123; width: 500px; margin: 0 auto; border: 1px solid red; border-bottom: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--开启一个angular应用程序,使用app这个模块--&gt; &lt;div ng-app=&quot;app&quot;&gt; &lt;!--定义路由--&gt; &lt;div class=&quot;router&quot;&gt; &lt;a href=&quot;#/&quot;&gt;home&lt;/a&gt; &lt;a href=&quot;#/about&quot;&gt;about&lt;/a&gt; &lt;a href=&quot;#/login&quot;&gt;login&lt;/a&gt; &lt;a href=&quot;#/404&quot;&gt;404&lt;/a&gt; &lt;/div&gt; &lt;!--路由对应的内容的显示--&gt; &lt;div ng-view id=&quot;view&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //2. 创建一个模块 并注入ngRouter(路由)依赖 var app = angular.module(&apos;app&apos;, [&apos;ngRoute&apos;]); /* * * 3. 进行路由的配置,使用模块的config方法 * ---AngularJS 模块的 config 函数用于配置路由规则。 * ----通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数 * ----并且使用$routeProvider.whenAPI来定义我们的路由规则。 * * * */ app.config([&apos;$routeProvider&apos;, function($routeProvider) &#123; $routeProvider .when(&quot;/&quot;, &#123; //template:在ng-view中简单的插入html内容 template: &quot;&lt;h1&gt;Home&lt;/h1&gt;&quot; &#125;) .when(&quot;/login&quot;, &#123; template: &quot;&lt;h1&gt;Login&lt;/h1&gt;&quot; &#125;) .when(&quot;/about&quot;, &#123; template: &quot;&lt;h1&gt;about&lt;/h1&gt;&quot; &#125;) .otherwise(&#123; template: &quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot; &#125;) &#125;])&lt;/script&gt; 路由配置对象 总结上节的内容,可以总结出以下几点 我们创建一个模块,在模块中注入ngRoute依赖,通过模块的config方法配置路由 在路由配置的时候,我们需要把$routeProvider注入到我们的配置函数 $routeProvider 为我们提供了 when(path,object) &amp; otherwise(object)函数按顺序定义所有路由，函数包含两个参数: 第一个参数是 URL 或者 URL 正则规则。 第二个参数是路由配置对象。 路由配置对象1234567891011121314151617181920$routeProvider.when(url, &#123; //定义模板字符串 template: string, //定义模板文件 templateUrl: string, //添加控制器 controller: string, function 或 array, //为控制器指定别名 controllerAs: string, //重定向的地址 redirectTo: string, function, //指定当前controller依赖的其他模块 resolve: object&lt;key, function&gt;&#125;);","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"18-router","slug":"angular1/18-router","permalink":"http://yoursite.com/categories/angular1/18-router/"}],"tags":[]},{"title":"依赖注入","slug":"angular1/17-inject/17-依赖注入","date":"2018-05-10T00:34:45.707Z","updated":"2018-05-10T01:12:47.121Z","comments":true,"path":"2018/05/10/angular1/17-inject/17-依赖注入/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/17-inject/17-依赖注入/","excerpt":"","text":"依赖注入","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"17-inject","slug":"angular1/17-inject","permalink":"http://yoursite.com/categories/angular1/17-inject/"}],"tags":[]},{"title":"angularjs动画","slug":"angular1/16-animation/16-angularjs动画","date":"2018-05-10T00:34:45.704Z","updated":"2018-05-10T01:11:50.523Z","comments":true,"path":"2018/05/10/angular1/16-animation/16-angularjs动画/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/16-animation/16-angularjs动画/","excerpt":"","text":"angularjs动画 angularjs提供了动画效果,可以配合css使用 AngularJS 使用动画需要引入 angular-animate.min.js 库。 动画库的使用1. angularjs动画的引入 1&lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular-animate.min.js&quot;&gt;&lt;/script&gt; 2. 在应用中使用模型 ngAnimate 1&lt;body ng-app=&quot;ngAnimate&quot;&gt; 动画的实现 通过样式类的操作实现 123456789101112131415161718192021ngAnimate 模型可以添加或移除 class 。ngAnimate 模型并不能使 HTML 元素产生动画，但是 ngAnimate 会监测事件，类似隐藏显示 HTML 元素 ，如果事件发生 ngAnimate 就会使用预定义的 class 来设置 HTML 元素的动画。AngularJS 添加/移除 class 的指令: ng-show ng-hide ng-class ng-view ng-include ng-repeat ng-if ng-switchng-show 和 ng-hide 指令用于添加或移除 ng-hide class 的值。其他指令会在进入 DOM 会添加 ng-enter 类，移除 DOM 会添加 ng-leave 属性。当 HTML 元素位置改变时，ng-repeat 指令同样可以添加 ng-move 类 。此外， 在动画完成后，HTML 元素的类集合将被移除。例如：ng-hide 指令会添加一下类： ng-animate ng-hide-animate ng-hide-add (如果元素将被隐藏) ng-hide-remove (如果元素将显示) ng-hide-add-active (如果元素将隐藏) ng-hide-remove-active (如果元素将显示) 过渡例子12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; div &#123; transition: all linear 0.5s; background-color: lightblue; height: 100px; &#125; .ng-hide &#123; height: 0; &#125; &lt;/style&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular-animate.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;myApp&quot;&gt; &lt;h1&gt;隐藏 DIV: &lt;input type=&quot;checkbox&quot; ng-model=&quot;myCheck&quot;&gt;&lt;/h1&gt; &lt;div ng-hide=&quot;myCheck&quot;&gt;&lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, [&apos;ngAnimate&apos;]); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 动画例子1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular-animate.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; @keyframes myChange &#123; from &#123; height: 100px; &#125; to &#123; height: 0; &#125; &#125; div &#123; height: 100px; background-color: lightblue; &#125; div.ng-hide &#123; animation: 0.5s myChange; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body ng-app=&quot;ngAnimate&quot;&gt; 隐藏 DIV: &lt;input type=&quot;checkbox&quot; ng-model=&quot;myCheck&quot;&gt; &lt;div ng-hide=&quot;myCheck&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"16-animation","slug":"angular1/16-animation","permalink":"http://yoursite.com/categories/angular1/16-animation/"}],"tags":[]},{"title":"页面包含","slug":"angular1/15-include/15-include","date":"2018-05-10T00:34:45.702Z","updated":"2018-05-10T01:11:56.242Z","comments":true,"path":"2018/05/10/angular1/15-include/15-include/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/15-include/15-include/","excerpt":"","text":"页面包含ng-include:这个指令可以实现页面的包含操作 实现的是在一个页面中使用多页页面里面的内容 存在的小问题: 在一个页面添加样式,会作用于所有页面里面的内容 12345678&lt;!--开启一个应用,使用页面包含--&gt;&lt;div ng-app&gt; &lt;div ng-include=&quot;&apos;./01-head.html&apos;&quot;&gt;&lt;/div&gt; &lt;div ng-include=&quot;&apos;./02-body.html&apos;&quot;&gt;&lt;/div&gt; &lt;div ng-include=&quot;&apos;./03-foot.html&apos;&quot;&gt;&lt;/div&gt; &lt;/div&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"15-include","slug":"angular1/15-include","permalink":"http://yoursite.com/categories/angular1/15-include/"}],"tags":[]},{"title":"","slug":"angular1/14-bootstrap/14-bootstrap使用","date":"2018-05-10T00:34:45.699Z","updated":"2018-05-10T00:52:27.478Z","comments":true,"path":"2018/05/10/angular1/14-bootstrap/14-bootstrap使用/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/14-bootstrap/14-bootstrap使用/","excerpt":"","text":"1title: bootstrap angularjs bootstrapbootstrap概述 AngularJS 的首选样式表是 Twitter Bootstrap， Twitter Bootstrap 是目前最受欢迎的前端框架。 bootstrap使用 引入bootstrap样式之后,就可以使用样式表里面已经定义好的样式了 你可以在你的 AngularJS 应用中加入 Twitter Bootstrap，你可以在你的 元素中添加如下代码: 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt; 如果站点在国内，建议使用百度静态资源库的Bootstrap，代码如下： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://apps.bdimg.com/libs/bootstrap/3.2.0/css/bootstrap.min.css&quot;&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"14-bootstrap","slug":"angular1/14-bootstrap","permalink":"http://yoursite.com/categories/angular1/14-bootstrap/"}],"tags":[]},{"title":"全局api","slug":"angular1/13-全局api/13-全局api","date":"2018-05-10T00:34:45.696Z","updated":"2018-05-10T01:12:01.660Z","comments":true,"path":"2018/05/10/angular1/13-全局api/13-全局api/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/13-全局api/13-全局api/","excerpt":"","text":"全局api API 意为 Application Programming Interface（应用程序编程接口）。 全局api使用angular这个对象进行访问 四种基本的api以及其使用的方式 1234567angular.lowercase() 转换字符串为小写angular.uppercase() 转换字符串为大写angular.isString() 判断给定的对象是否为字符串，如果是返回 true。angular.isNumber() 判断给定的对象是否为数字，如果是返回 true。 一个完整的例子123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;app&quot; ng-controller=&quot;myController&quot;&gt; &lt;h1&gt;name: &#123;&#123; userName1 &#125;&#125;&lt;/h1&gt; &lt;h1&gt;sex : &#123;&#123; userSex1 &#125;&#125;&lt;/h1&gt; &lt;h1&gt;isString : &#123;&#123; isString &#125;&#125;&lt;/h1&gt; &lt;h1&gt;isNumber : &#123;&#123; isNumber &#125;&#125;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建模块 var app = angular.module(&quot;app&quot;, []); //2. 添加控制器 app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) &#123; $scope.userName = &quot;gaohui&quot;; $scope.userSex = &quot;GENDER&quot;; $scope.userName1 = angular.uppercase($scope.userName); $scope.isString = angular.isString($scope.userName); $scope.userSex1 = angular.lowercase($scope.userSex); $scope.isNumber = angular.isNumber($scope.userSex); &#125;])&lt;/script&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"13-全局api","slug":"angular1/13-全局api","permalink":"http://yoursite.com/categories/angular1/13-全局api/"}],"tags":[]},{"title":"表单和输入验证","slug":"angular1/12-validate/12-表单和输入验证","date":"2018-05-10T00:34:45.692Z","updated":"2018-05-10T01:12:07.378Z","comments":true,"path":"2018/05/10/angular1/12-validate/12-表单和输入验证/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/12-validate/12-表单和输入验证/","excerpt":"","text":"表单和输入验证表单 angularjs表单是输入控件的集合 html表单 通常与 html控件同时存在 HTML 控件,以下 HTML input 元素被称为 HTML 控件: input 元素 select 元素 button 元素 textarea 元素 基本表单实例123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--开启一个angularjs应用程序 使用模块 添加控制器--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;form action=&quot;javascript:void(0)&quot; method=&quot;post&quot;&gt; &lt;!--使用数据模型里面的数据--&gt; name:&lt;input type=&quot;text&quot; ng-model=&quot;person.name&quot; /&gt; &lt;br /&gt; age:&lt;input type=&quot;text&quot; ng-model=&quot;person.age&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app = angular.module(&apos;app&apos;, []) //在模块上添加控制器,并传入作用域参数 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.person = &#123; &quot;name&quot;: &quot;gaohui&quot;, &quot;age&quot;: &quot;23&quot; &#125; &#125;)&lt;/script&gt; 表单使用提升12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;formCtrl&quot;&gt; &lt;form novalidate&gt; &lt;p&gt;First Name:&lt;/p&gt; &lt;input type=&quot;text&quot; ng-model=&quot;user.firstName&quot;&gt; &lt;p&gt;Last Name:&lt;/p&gt; &lt;input type=&quot;text&quot; ng-model=&quot;user.lastName&quot;&gt; &lt;div&gt; &lt;button ng-click=&quot;reset()&quot;&gt;RESET&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;p&gt;form = &#123;&#123;user &#125;&#125;&lt;/p&gt; &lt;p&gt;master = &#123;&#123;master&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;formCtrl&apos;, function($scope) &#123; $scope.master = &#123; firstName: &quot;John&quot;, lastName: &quot;Doe&quot; &#125;; $scope.reset = function() &#123; //angular.copy()方法实现数据的拷贝 $scope.user = angular.copy($scope.master); &#125;; //默认先执行一次方法 $scope.reset(); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输入验证 AngularJS 表单和控件可以提供验证功能，并对用户输入的非法数据进行警告。 HTML 属性 novalidate 用于禁用浏览器的默认验证。客户端的验证不能确保用户输入数据的安全，所以服务端的数据验证也是必须的。 表单输入验证例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;验证实例&lt;/h2&gt; &lt;form ng-app=&quot;myApp&quot; ng-controller=&quot;validateCtrl&quot; name=&quot;myForm&quot; novalidate&gt; &lt;p&gt;用户名:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; ng-model=&quot;user&quot; required&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.user.$dirty &amp;&amp; myForm.user.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.user.$error.required&quot;&gt;用户名是必须的。&lt;/span&gt; &lt;/span&gt; &lt;/p&gt; &lt;p&gt;邮箱:&lt;br&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; ng-model=&quot;email&quot; required&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.email.$dirty &amp;&amp; myForm.email.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.email.$error.required&quot;&gt;邮箱是必须的。&lt;/span&gt; &lt;span ng-show=&quot;myForm.email.$error.email&quot;&gt;非法的邮箱地址。&lt;/span&gt; &lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; ng-disabled=&quot;myForm.user.$dirty &amp;&amp; myForm.user.$invalid || myForm.email.$dirty &amp;&amp; myForm.email.$invalid&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;validateCtrl&apos;, function($scope) &#123; $scope.user = &apos;Loen Wang&apos;; $scope.email = &apos;loenwang@loen.wang&apos;; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"12-validate","slug":"angular1/12-validate","permalink":"http://yoursite.com/categories/angular1/12-validate/"}],"tags":[]},{"title":"事件","slug":"angular1/111-event/11-事件","date":"2018-05-10T00:34:45.689Z","updated":"2018-05-10T01:12:13.733Z","comments":true,"path":"2018/05/10/angular1/111-event/11-事件/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/111-event/11-事件/","excerpt":"","text":"事件 ng-click制定了angular应用程序的单机事件 简单实例实例1 点击按钮,进行数字加1的操作 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--ng-app开启一个angularjs应用程序 使用app这个模块 并添加控制器--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&apos;myCtl&apos;&gt; &lt;button ng-click=&quot;num=num+1&quot;&gt;点击加1&lt;/button&gt; &lt;p&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app = angular.module(&apos;app&apos;,[]) //在模块上添加控制器, 并传入作用域参数 app.controller(&apos;myCtl&apos;,function($scope)&#123; $scope.num=0; console.log($scope.num) &#125;) &lt;/script&gt; 实例2 点击按钮,进行元素的显示和隐藏操作 以下操作可以通过简单改写,以点击按钮,执行函数的形式实现 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--ng-app开启一个angularjs应用程序 使用app这个模块 并添加控制器--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&apos;myCtl&apos;&gt; &lt;button ng-click=&quot;bool = !bool&quot;&gt;点击按钮进行元素的显示和隐藏切换&lt;/button&gt; &lt;p&gt;&#123;&#123;bool&#125;&#125;&lt;/p&gt; &lt;!--下面是进行显示额隐藏切换的元素--&gt; &lt;ul ng-show=&apos;bool&apos;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app = angular.module(&apos;app&apos;, []) //在模块上添加控制器, 并传入作用域参数 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.bool = true; &#125;)&lt;/script&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"111-event","slug":"angular1/111-event","permalink":"http://yoursite.com/categories/angular1/111-event/"}],"tags":[]},{"title":"DOM","slug":"angular1/10-dom/10-dom","date":"2018-05-10T00:34:45.684Z","updated":"2018-05-10T01:12:18.639Z","comments":true,"path":"2018/05/10/angular1/10-dom/10-dom/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/10-dom/10-dom/","excerpt":"","text":"angularjs DOM angularjs有自己的html属性指令 ng-disabledng-disabled绑定应用程序数据到html的disabled属性 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--启动一个angularjs应用程序--&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;!--ng-disabled指令绑定应用应用程序数据到html元素的disabled指令--&gt; &lt;button ng-disabled=&quot;bool&quot;&gt;按钮&lt;/button&gt; &lt;!-- ng-model绑定应用程序数据bool到input标签的value值 --&gt; &lt;input type=&quot;checkbox&quot; ng-model=&apos;bool&apos; name=&quot;&quot; id=&quot;&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; ng-show ng-show指令进行元素的显示和隐藏,其值可以是bool值,也可以是一个bool表达式 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--启动一个angularjs应用程序--&gt; &lt;div ng-app&gt; &lt;!-- ng-show指令进行元素的显示和隐藏 其值可以是一个bool表达式 --&gt; &lt;p ng-show=&apos;true&apos;&gt;元素显示&lt;/p&gt; &lt;p ng-show=&apos;false&apos;&gt;元素隐藏&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; ng-hide","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"10-dom","slug":"angular1/10-dom","permalink":"http://yoursite.com/categories/angular1/10-dom/"}],"tags":[]},{"title":"AngularJS概述","slug":"angular1/09-sql/09-sql","date":"2018-05-10T00:34:45.680Z","updated":"2018-05-10T01:12:22.408Z","comments":true,"path":"2018/05/10/angular1/09-sql/09-sql/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/09-sql/09-sql/","excerpt":"","text":"sql","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"09-sql","slug":"angular1/09-sql","permalink":"http://yoursite.com/categories/angular1/09-sql/"}],"tags":[]},{"title":"选择框和表格","slug":"angular1/08-form/08-选择框和表格","date":"2018-05-10T00:34:45.674Z","updated":"2018-05-10T01:12:28.579Z","comments":true,"path":"2018/05/10/angular1/08-form/08-选择框和表格/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/08-form/08-选择框和表格/","excerpt":"","text":"选择框和表格选择框 也叫下拉列表 AngularJS 可以使用数组或对象创建一个下拉列表选项。 使用 ng-options 创建选择框 列表项通过对象和数组循环输出 使用ng-options创建一个下拉列表123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myController&quot;&gt; &lt;!--创建一个下拉列表--&gt; &lt;select ng-model=&quot;selectedName&quot; ng-options=&quot;data for data in arr&quot;&gt; &lt;/select&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1 创建一个模块 var app = angular.module(&apos;app&apos;,[]) //2 在模块上添加控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.arr = [1,2,3] &#125;) /&lt;/script&gt; 使用ng-repeat创建下拉列表12 ng-options更强大12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--开启一个angularjs应用程序--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;select name=&quot;&quot;&gt; &lt;option ng-repeat=&quot;data in arr&quot;&gt;&#123;&#123;data&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建一个模块 var app =angular.module(&apos;app&apos;,[]) //在创建好的模块上添加控制器 app.controller(&apos;myCtl&apos;,function($scope)&#123; //数据模型 $scope.arr = [1,2,3] &#125;)&lt;/script&gt; 表格 ng-repeat 指令可以完美的显示表格。 基本表格操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; table, th, td &#123; border: 1px solid grey; border-collapse: collapse; padding: 5px; &#125; table tr:nth-child(odd) &#123; background-color: #f1f1f1; &#125; table tr:nth-child(even) &#123; background-color: #ffffff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--创建一个angular应用程序--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;en&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;!--使用ng-repeat进行表格数据的渲染--&gt; &lt;tr ng-repeat=&quot;data in stu&quot;&gt; &lt;td&gt;&#123;&#123;data.en&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建一个模块 var app = angular.module(&apos;app&apos;, []) //2. 在模块上添加控制器 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.stu = [ &#123; &quot;en&quot;: &quot;gaohui&quot;, &quot;name&quot;: &quot;高辉&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;angda&quot;, &quot;name&quot;: &quot;昂达&quot;, &quot;age&quot;: &quot;22&quot; &#125;, &#123; &quot;en&quot;: &quot;guofeng&quot;, &quot;name&quot;: &quot;国锋&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;liujina&quot;, &quot;name&quot;: &quot;刘健&quot;, &quot;age&quot;: &quot;23&quot; &#125; ] &#125;)&lt;/script&gt; 表格的排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; table, th, td &#123; border: 1px solid grey; border-collapse: collapse; padding: 5px; &#125; table tr:nth-child(odd) &#123; background-color: #f1f1f1; &#125; table tr:nth-child(even) &#123; background-color: #ffffff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--创建一个angular应用程序--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;en&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;!--表格的排序显示--&gt; &lt;tr ng-repeat=&quot;data in stu | orderBy:&apos;en&apos;&quot;&gt; &lt;td&gt;&#123;&#123;data.en&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建一个模块 var app = angular.module(&apos;app&apos;, []) //2. 在模块上添加控制器 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.stu = [ &#123; &quot;en&quot;: &quot;gaohui&quot;, &quot;name&quot;: &quot;高辉&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;angda&quot;, &quot;name&quot;: &quot;昂达&quot;, &quot;age&quot;: &quot;22&quot; &#125;, &#123; &quot;en&quot;: &quot;guofeng&quot;, &quot;name&quot;: &quot;国锋&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;liujina&quot;, &quot;name&quot;: &quot;刘健&quot;, &quot;age&quot;: &quot;23&quot; &#125; ] &#125;)&lt;/script&gt; 对表格单元格数据使用过滤器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; table, th, td &#123; border: 1px solid grey; border-collapse: collapse; padding: 5px; &#125; table tr:nth-child(odd) &#123; background-color: #f1f1f1; &#125; table tr:nth-child(even) &#123; background-color: #ffffff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--创建一个angular应用程序--&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myCtl&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;en&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;tr ng-repeat=&quot;data in stu&quot;&gt; &lt;!--表格数据的过滤显示--&gt; &lt;td&gt;&#123;&#123;data.en | uppercase&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 创建一个模块 var app = angular.module(&apos;app&apos;, []) //2. 在模块上添加控制器 app.controller(&apos;myCtl&apos;, function($scope) &#123; $scope.stu = [ &#123; &quot;en&quot;: &quot;gaohui&quot;, &quot;name&quot;: &quot;高辉&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;angda&quot;, &quot;name&quot;: &quot;昂达&quot;, &quot;age&quot;: &quot;22&quot; &#125;, &#123; &quot;en&quot;: &quot;guofeng&quot;, &quot;name&quot;: &quot;国锋&quot;, &quot;age&quot;: &quot;23&quot; &#125;, &#123; &quot;en&quot;: &quot;liujina&quot;, &quot;name&quot;: &quot;刘健&quot;, &quot;age&quot;: &quot;23&quot; &#125; ] &#125;)&lt;/script&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"08-form","slug":"angular1/08-form","permalink":"http://yoursite.com/categories/angular1/08-form/"}],"tags":[]},{"title":"Http","slug":"angular1/07-http/07-http","date":"2018-05-10T00:34:45.668Z","updated":"2018-05-10T01:11:35.753Z","comments":true,"path":"2018/05/10/angular1/07-http/07-http/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/07-http/07-http/","excerpt":"","text":"AngularJS Http 是AngularJS 的 XMLHttpRequest,类似于原生js的 ajax 对象$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。 实例$http.get(url).then(function(res){})12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; table&#123; border-collapse: collapse; &#125; th,td&#123; padding: 5px 20px; &#125; img&#123; width: 100px; height: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&apos;myController&apos;&gt; &lt;!--将请求回来的数据渲染在一个表格中--&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;th&gt;img&lt;/th&gt; &lt;/tr&gt; &lt;tr ng-repeat=&quot;data in arr&quot;&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;&#123;&#123;data.imgSrc&#125;&#125;&quot; alt=&quot;&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;,[]) app.controller(&apos;myController&apos;,function($scope,$http)&#123; //使用$http服务发送请求,获取数据 var url = &apos;json/my.json&apos; $http.get(url).then(function(res)&#123; console.log(res.data) //将请求回来的数据保存在数据模型中 $scope.arr = res.data &#125;) &#125;) &lt;/script&gt;; $http.get(url).success(function(res){})12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;//apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;customersCtrl&quot;&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;data in arr&quot;&gt; &#123;&#123; data.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;customersCtrl&apos;, function($scope, $http) &#123; var url = &apos;json/my.json&apos; //发送请求,请求成功后获取数据,通过函数的参数来接受获取的数据 $http.get(url).success(function(res) &#123; console.log(res) $scope.arr = res; &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"07-http","slug":"angular1/07-http","permalink":"http://yoursite.com/categories/angular1/07-http/"}],"tags":[]},{"title":"服务","slug":"angular1/06-service/06-服务","date":"2018-05-10T00:34:45.657Z","updated":"2018-05-10T01:10:56.455Z","comments":true,"path":"2018/05/10/angular1/06-service/06-服务/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/06-service/06-服务/","excerpt":"","text":"服务 在angularjs中,可以创建自己的服务,或者使用内置的服务 服务概述什么是服务 服务是一个函数或者是一个对象,可以在angularjs应用程序中使用 angularjs内置了30多个服务 实例演示$location服务 $location服务可以返回当前页面的url地址 $location服务和$scope一样,是作为一个参数传递到controller中AngularJS 会一直监控应用，处理事件变化， AngularJS 使用 $location 服务比使用 window.location 对象更好。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!--视图 开启一个应用--&gt; &lt;body ng-app=&quot;app&quot; ng-controller=&quot;RegisterController&quot;&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- service:AngularJS 中你可以创建自己的服务，或使用内建服务。 在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。 ----------AngularJS 内建了30 多个服务 1.$location 服务，它可以返回当前页面的 URL 地址。 --------注意 $location 服务是作为一个参数传递到 controller 中。如果要使用它，需要在 controller 中定义。 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建模块 var app = angular.module(&apos;app&apos;, []); //添加控制器 app.controller(&apos;RegisterController&apos;, function($scope, $location) &#123; console.log($location); console.log($location.$$absUrl); console.log(&quot;协议: &quot; + $location.$$protocol) console.log(&quot;主机: &quot; + $location.$$host) console.log(&quot;端口: &quot; + $location.$$port) &#125;)&lt;/script&gt; $http服务 $http 是 AngularJS 应用中最常用的服务。 服务向服务器发送请求，应用响应服务器传送过来的数据。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!--视图 开启一个应用--&gt; &lt;body ng-app=&quot;app&quot; ng-controller=&quot;RegisterController&quot;&gt; &lt;div class=&quot;contain&quot;&gt;&#123;&#123;myWelcome&#125;&#125;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- service:AngularJS 中你可以创建自己的服务，或使用内建服务。 在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。 ----------AngularJS 内建了30 多个服务 2.$http 服务向服务器请求数据:--&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建模块 var app = angular.module(&apos;app&apos;, []); //添加控制器 app.controller(&apos;RegisterController&apos;, function($scope, $http) &#123; $http.get(&quot;views/index.html&quot;).then(function(response) &#123; $scope.myWelcome = response.data; console.log($scope.myWelcome) &#125;) &#125;)&lt;/script&gt; $timeout服务 和 $interval 服务 AngularJS $timeout 服务对应了 JS window.setTimeout 函数。 AngularJS $interval 服务对应了 JS window.setInterval 函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!--视图 开启一个应用--&gt; &lt;body ng-app=&quot;app&quot; ng-controller=&quot;RegisterController&quot;&gt; &lt;form&gt; name: &lt;input type=&quot;text&quot; ng-model=&apos;name&apos; /&gt; &lt;br /&gt; age : &lt;input type=&quot;text&quot; ng-model=&apos;age&apos; /&gt; &lt;br /&gt; sex : &lt;input type=&quot;text&quot; ng-model=&apos;sex&apos; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; &lt;p ng-controller=&quot;timeController&quot;&gt;&#123;&#123;time&#125;&#125;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- service:AngularJS 中你可以创建自己的服务，或使用内建服务。 在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。 ----------AngularJS 内建了30 多个服务 3.$timeout对应js的setTimeout(function()&#123;&#125;,1000) ----interval--&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建模块 var app = angular.module(&apos;app&apos;, []); //添加控制器 app.controller(&apos;RegisterController&apos;, function($scope, $timeout) &#123; //添加模型数据 $scope.name = &quot;gaohui&quot;; $scope.age = &quot;18&quot;; $scope.sex = &quot;male&quot;; //设置定时器 $timeout(function()&#123; $scope.name = &quot;高辉&quot;; &#125;,1000); &#125;) //设置计时器 app.controller(&apos;timeController&apos;,function($scope,$interval)&#123; $scope.time = new Date().toLocaleTimeString(); $interval(function()&#123; $scope.time = new Date().toLocaleTimeString(); &#125;,1000) &#125;)&lt;/script&gt; 自定义服务 以下面的代码为例 123456789101112131415//1 创建一个模块var app = angular.module(&apos;app&apos;,[])//2. 在这里创建一个自定义的服务,添加到控制器app.service(&apos;$uc&apos;,function()&#123; this.toUC = function(data)&#123; return data.toUpperCase() &#125;&#125;)//3. 给模块添加控制器 并使用 自定义的服务app.controller(&apos;controller&apos;,function($scope,$uc)&#123; $scope.name=$uc.toUC(&quot;gaohui&quot;)&#125;) 代码解析 123在第二步实现中,使用模块app的service方法创建一个自定义的服务 第一个参数是服务的名称,第二个参数是一个韩式,定义这个服务要完成的一些操作 实例一: 在控制器中使用自定义服务1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;p&gt;255 的16进制是:&lt;/p&gt; &lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt; &lt;script&gt; //1. 创建模块 var app = angular.module(&apos;myApp&apos;, []); //2. 创建一个自定义的服务 hexafy app.service(&apos;hexafy&apos;, function() &#123; this.myFunc = function(x) &#123; return x.toString(16); &#125; &#125;); //3. 添加控制器,应用创建的服务 app.controller(&apos;myCtrl&apos;, function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实例二: 在过滤器中使用自定义的服务12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;, []); // 在模块的基础上,添加自定义的服务 app.service(&quot;$convert&quot;, function() &#123; //convert是服务的名称,后面是服务的方法声明 this.fn = function(data) &#123; return data.toString(16); &#125; &#125;) // 在模块的基础上添加自定义的过滤器 app.filter(&apos;myFormat&apos;, [&apos;$convert&apos;, function($convert) &#123; return function(data) &#123; return $convert.fn(data); &#125;; &#125;]); // 添加控制器,使用自定义的服务 app.controller(&quot;myController&quot;, [&quot;$scope&quot;, &quot;$convert&quot;, function($scope, $convert) &#123; $scope.counts = [255, 251, 200]; &#125;]) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app=&quot;app&quot; ng-controller=&quot;myController&quot;&gt; &lt;p&gt;在获取数组 [255, 251, 200] 值时使用过滤器:&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in counts&quot;&gt;result: &#123;&#123;x | myFormat&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;过滤器使用服务将10进制转换为16进制。&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"06-service","slug":"angular1/06-service","permalink":"http://yoursite.com/categories/angular1/06-service/"}],"tags":[]},{"title":"angularjs过滤器","slug":"angular1/05-filter/05-过滤器","date":"2018-05-10T00:34:45.651Z","updated":"2018-05-10T01:11:06.720Z","comments":true,"path":"2018/05/10/angular1/05-filter/05-过滤器/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/05-filter/05-过滤器/","excerpt":"","text":"angularjs过滤器 进行过滤操作 实例: 水的过滤 使用一个管道符号添加到指令或者是表达式中 angularjs过滤器 angularjs过滤器可用于进行数据的转化 过滤器 描述 currency 格式化数字为货币格式。 filter 从数组项中选择一个子集。 lowercase 格式化字符串为小写。 orderBy 根据某个表达式排列数组。 uppercase 格式化字符串为大写。","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"05-filter","slug":"angular1/05-filter","permalink":"http://yoursite.com/categories/angular1/05-filter/"}],"tags":[]},{"title":"指令","slug":"angular1/03-ng指令/03-ng指令","date":"2018-05-10T00:34:45.646Z","updated":"2018-05-10T01:11:25.083Z","comments":true,"path":"2018/05/10/angular1/03-ng指令/03-ng指令/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/03-ng指令/03-ng指令/","excerpt":"","text":"指令基本指令ng-app 开启一个angularjs应用程序 ng-app指令定义了angularjs应用程序的根元素,在网页进行加载的时候,会自动渲染页面元素 一个页面可以包含多个运行在不同元素中的angularjs应用程序 123456//ng-app后面可以跟一个值来连接到代码模块&lt;div ng-app=&quot;myapp&quot; ng-controller=&apos;myController&apos;&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt; ng-init 使用ng-init初始化数据,这个指令不是太常用,后面会学习更好的进行数据绑定的方式 在后面的学习中,将使用控制器或者是模块代替这一部分的内容 ng-model 使用ng-model的形式进行数据的双向绑定 ng-model 指令 绑定 HTML 元素 到应用程序数据。 123456789ng-model 指令也可以： 为应用程序数据提供类型验证（number、email、required）。 为应用程序数据提供状态（invalid、dirty、touched、error）。 为 HTML 元素提供 CSS 类。 绑定 HTML 元素到 HTML 表单。 ng-bind 将应用程序的数据绑定到html视图中 ng-repeat ng-repeat指令用在对象或数组上,进行循环输出 angularjs支持数据库的增删改查的操作,可以将页面上的数据想像成数据库中定义的数据 本教程中使用的 AngularJS 指令： 指令 描述 讲解 ng_app 定义应用程序的根元素。 指令 ng_bind 绑定 HTML 元素到应用程序数据。 简介 ng_click 定义元素被单击时的行为。 HTML 事件 ng_controller 为应用程序定义控制器对象。 控制器 ng_disabled 绑定应用程序数据到 HTML 的 disabled 属性。 HTML DOM ng_init 为应用程序定义初始值。 指令 ng_model 绑定应用程序数据到 HTML 元素。 指令 ng_repeat 为控制器中的每个数据定义一个模板。 指令 ng_show 显示或隐藏 HTML 元素。 HTML DOM","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"03-ng指令","slug":"angular1/03-ng指令","permalink":"http://yoursite.com/categories/angular1/03-ng指令/"}],"tags":[]},{"title":"表达式","slug":"angular1/02-ng表达式/02-ng表达式","date":"2018-05-10T00:34:45.572Z","updated":"2018-05-10T01:19:43.435Z","comments":true,"path":"2018/05/10/angular1/02-ng表达式/02-ng表达式/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/02-ng表达式/02-ng表达式/","excerpt":"","text":"表达式AngularJS 使用 表达式 把数据绑定到 HTML。 AngularJS 表达式写在双大括号内：。可以实现和ng-bind同样的功能 AngularJS 表达式 很像 JavaScript 表达式：它们可以包含文字、运算符和变量。 基本表达式123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!-- 表达式可以实现和ng-bind相同的功能 angularjs表达式和js表达式一样,支持文本,变量和运算,对象 --&gt; &lt;body&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;!--表达式的实现--&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;Hello &#123;&#123;1+1&#125;&#125;&lt;/h1&gt; &lt;h1&gt;Hello &#123;&#123;&quot;高辉&quot;+ name&#125;&#125;&lt;/h1&gt; &lt;!--v-bind的实现--&gt; &lt;h1 ng-bind=&quot;&apos;hello&apos;+name&quot;&gt;&lt;/h1&gt; &lt;h1 ng-bind=&quot;1+1&quot;&gt;&lt;/h1&gt; &lt;h1 ng-bind=&quot;&apos;hello&apos;+&apos;高辉&apos;+name&quot;&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 表达式中angularjs对象的使用 和原生js中对象的访问是一样的,在中使用dian.的形式进行对象的属性的访问 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!-- 使用angularjs表达式进行对象的绑定 --&gt; &lt;body&gt; &lt;div ng-app=&quot;&quot; ng-init=&quot;obj=&#123;&apos;name&apos;:&apos;gaohui&apos;,&apos;age&apos;:&apos;18&apos;&#125;&quot;&gt; &lt;!--在表达式中输出对象的值--&gt; &#123;&#123;obj.name&#125;&#125; &#123;&#123;obj.age&#125;&#125; &lt;!--使用ng-bind的形式--&gt; &lt;p ng-bind=&quot;obj.name&quot;&gt;&lt;/p&gt; &lt;p ng-bind=&quot;obj.age&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 表达式中angularjs数组的使用 和原生js中对象的访问是一样的,在中使用dian.的形式进行对象的属性的访问 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;!-- 使用angularjs表达式进行对象的绑定 --&gt; &lt;body&gt; &lt;div ng-app=&quot;&quot; ng-init=&quot;obj=&#123;&apos;name&apos;:&apos;gaohui&apos;,&apos;age&apos;:&apos;18&apos;&#125;&quot;&gt; &lt;!--在表达式中输出对象的值--&gt; &#123;&#123;obj.name&#125;&#125; &#123;&#123;obj.age&#125;&#125; &lt;!--使用ng-bind的形式--&gt; &lt;p ng-bind=&quot;obj.name&quot;&gt;&lt;/p&gt; &lt;p ng-bind=&quot;obj.age&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"02-ng表达式","slug":"angular1/02-ng表达式","permalink":"http://yoursite.com/categories/angular1/02-ng表达式/"}],"tags":[]},{"title":"AngularJS概述","slug":"angular1/01-ng基础/01-ng基础","date":"2018-05-10T00:34:45.565Z","updated":"2018-05-10T01:10:52.413Z","comments":true,"path":"2018/05/10/angular1/01-ng基础/01-ng基础/","link":"","permalink":"http://yoursite.com/2018/05/10/angular1/01-ng基础/01-ng基础/","excerpt":"","text":"AngularJS概述AngularJS简介什么是 AngularJS？ “AngularJS 是专门为应用程序设计的 HTML。” AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。 AngularJS 可以克隆和重复 HTML 元素。 AngularJS 可以隐藏和显示 HTML 元素。 AngularJS 可以在 HTML 元素”背后”添加代码。 AngularJS 支持输入验证。 AngularJS 历史123AngularJS 是比较新的技术，版本 1.0 是在 2012 年发布的。AngularJS 是由 Google 的员工 Miško Hevery 从 2009 年开始着手开发。这是一个非常好的构想，该项目目前已由 Google 正式支持，有一个全职的开发团队继续开发和维护这个库。 AngularJS特点 angular通过新的属性和表达式扩展html angular可以构建一个单页面应用程序 single page application AngularJS 简介 AngularJS 是一个 JavaScript 框架。它可通过 script 标签添加到 HTML 页面。 注意事项: 我们建议把脚本放在 元素的底部。 这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。 AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。 AngularJS 扩展了 HTML123456789AngularJS 通过 ng-directives(指令名) 扩展了 HTML。ng-是angular指令的前缀1. ng-app 指令定义一个 AngularJS 应用程序。2. ng-model 指令把元素值（比如输入域的值）绑定到应用程序。3. ng-bind 指令把应用程序数据绑定到 HTML 视图。4. ng-init 初始化应用程序变量 angularjs的组成 angularjs的组成可以分成三部分 view(视图),即html model(模型)也就是数据 controller(控制器),javascrpt函数,可以添加或修改数据 基本示例基本示例1 ng-app ng-model ng-bind的使用 ng-app 指令定义一个 AngularJS 应用程序。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序。 ng-bind 指令把应用程序数据绑定到 HTML 视图。 v-bind绑定的是i标签的nnerHTML 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--ng-app 指令告诉 AngularJS，&lt;div&gt; 元素是 AngularJS 应用程序 的&quot;所有者&quot;。--&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;!--ng-model 指令把输入域的值绑定到应用程序变量 name。--&gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;!--ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。--&gt; &lt;h1 ng-bind=&quot;name&quot;&gt;hello&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 基本示例2 ng-init的使用 ng-init 初始化应用程序变量 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--ng-app 指令告诉 AngularJS，&lt;div&gt; 元素是 AngularJS 应用程序 的&quot;所有者&quot;。--&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;!--ng-model 指令把输入域的值绑定到应用程序变量 name。--&gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;!--ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。--&gt; &lt;h1 ng-bind=&quot;name&quot;&gt;hello&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 基本示例3 data- html5中自定义属性的应用 AngularJS 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;angular 1&lt;/title&gt; &lt;!--cdn 实现js的引入--&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;!-- 在html5中，允许自定义属性，使用data- AngularJS 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。 --&gt; &lt;body&gt; &lt;div data-ng-app=&quot;&quot; data-ng-init=&quot;name=&apos;高辉&apos;&quot; &gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; data-ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;p data-ng-bind=&apos;name&apos;&gt;&lt;/p&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"angular1","slug":"angular1","permalink":"http://yoursite.com/categories/angular1/"},{"name":"01-ng基础","slug":"angular1/01-ng基础","permalink":"http://yoursite.com/categories/angular1/01-ng基础/"}],"tags":[]},{"title":"常见的查询","slug":"mysql/03-常见查询操作/03-常见的查询的例子","date":"2018-05-10T00:34:11.100Z","updated":"2018-05-10T01:07:28.993Z","comments":true,"path":"2018/05/10/mysql/03-常见查询操作/03-常见的查询的例子/","link":"","permalink":"http://yoursite.com/2018/05/10/mysql/03-常见查询操作/03-常见的查询的例子/","excerpt":"","text":"常见的查询查询所有 12345678910111213MariaDB [test]&gt; select * from shop;+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0001 | A | 3.45 || 0001 | B | 3.99 || 0002 | A | 10.99 || 0003 | B | 1.45 || 0003 | C | 1.69 || 0003 | D | 1.25 || 0004 | D | 19.95 |+---------+--------+-------+7 rows in set (0.00 sec) 1.获取列的最大值 “最大的物品号是什么？” 123456789101112131415MariaDB [test]&gt; select max(price) from shop;+------------+| max(price) |+------------+| 19.95 |+------------+1 row in set (0.00 sec)MariaDB [test]&gt; select max(price) as price from shop;+-------+| price |+-------+| 19.95 |+-------+1 row in set (0.00 sec) 2.拥有某个列的最大值的行的相关信息 任务：找出最贵物品的编号、销售商和价格。 方式1: 找到最大值直接返回 1234567MariaDB [test]&gt; select * from shop where price=(select max(price) from shop);+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0004 | D | 19.95 |+---------+--------+-------+1 row in set (0.00 sec) 方式2: 倒序排序之后返回第一条 1234567MariaDB [test]&gt; select * from shop order by price desc limit 1;+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0004 | D | 19.95 |+---------+--------+-------+1 row in set (0.00 sec) 3.列的最大值：按组 任务：每项物品的的最高价格是多少？ 1234567891011MariaDB [test]&gt; select article,max(price) as price from shop group by article;+---------+-------+| article | price |+---------+-------+| 0001 | 3.99 || 0002 | 10.99 || 0003 | 1.69 || 0004 | 19.95 |+---------+-------+4 rows in set (0.00 sec) 4.拥有某个字段的组间最大值的行 任务：对每项物品，找出最贵价格的物品的经销商。 123456789101112MariaDB [test]&gt; SELECT article, dealer, price FROM shop s1 -&gt; WHERE price=(SELECT MAX(s2.price) FROM shop s2 WHERE s1.article = s2.article);+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0001 | B | 3.99 || 0002 | A | 10.99 || 0003 | C | 1.69 || 0004 | D | 19.95 |+---------+--------+-------+4 rows in set (0.00 sec) 5.使用用户变量 如下所示,使用用户变量获取当前最大值和最小值 1234567891011121314151617MariaDB [test]&gt; select @min:=min(price),@max:=max(price) from shop;+------------------+------------------+| @min:=min(price) | @max:=max(price) |+------------------+------------------+| 1.25 | 19.95 |+------------------+------------------+1 row in set (0.00 sec)MariaDB [test]&gt; select * from shop where price=@min or price=@max;+---------+--------+-------+| article | dealer | price |+---------+--------+-------+| 0003 | D | 1.25 || 0004 | D | 19.95 |+---------+--------+-------+2 rows in set (0.00 sec)","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"03-常见查询操作","slug":"mysql/03-常见查询操作","permalink":"http://yoursite.com/categories/mysql/03-常见查询操作/"}],"tags":[]},{"title":"获取 数据库和表的相关信息","slug":"mysql/02-数据库和表的相关信息/02-获取数据库和表的相关信息","date":"2018-05-10T00:34:11.092Z","updated":"2018-05-10T01:07:25.494Z","comments":true,"path":"2018/05/10/mysql/02-数据库和表的相关信息/02-获取数据库和表的相关信息/","link":"","permalink":"http://yoursite.com/2018/05/10/mysql/02-数据库和表的相关信息/02-获取数据库和表的相关信息/","excerpt":"","text":"获取 数据库和表的相关信息数据库 查看所有的数据库 show databases; 查看当前使用的数据库 select database();` 数据表 查看当前数据库下所有的数据表 show tables; 查看表中列的信息 describe pet; 或者是 explain pet; 查看索引信息 show index from pet;","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"02-数据库和表的相关信息","slug":"mysql/02-数据库和表的相关信息","permalink":"http://yoursite.com/categories/mysql/02-数据库和表的相关信息/"}],"tags":[]},{"title":"mysql 的基本使用","slug":"mysql/01-mysql基础/01-mysql基础","date":"2018-05-10T00:34:10.966Z","updated":"2018-05-10T01:09:40.178Z","comments":true,"path":"2018/05/10/mysql/01-mysql基础/01-mysql基础/","link":"","permalink":"http://yoursite.com/2018/05/10/mysql/01-mysql基础/01-mysql基础/","excerpt":"","text":"mysql 的基本使用简介 mysql高版本就是mariadb，完全兼容mysql，都是一家开发的。本来 MariaDB 的描绘初衷之一即是彻底兼容 MySQL，包含 API 和客户端协议，使之能轻松变成 MySQL 的代替品。 链接和断开mysql链接 打开shell命令窗口,输入以下命令 12mysql -h host -u user -p 断开1mysql&gt; QUIT 输入查询基本输入查询 一个查询返回一行,使用逗号 , 分隔多个查询项 12345678910111213// 输入的查询语句MariaDB [(none)]&gt; select version(),current_date,sin(pi()/3),(4+1)*5;// 返回的结果+-----------------+--------------+--------------------+---------+| version() | current_date | sin(pi()/3) | (4+1)*5 |+-----------------+--------------+--------------------+---------+| 10.1.31-MariaDB | 2018-04-24 | 0.8660254037844386 | 25 |+-----------------+--------------+--------------------+---------+1 row in set (0.00 sec) 多行查询 mysql支持多行查询 , 中间使用 分号 ; 隔开 , 也就是说每一个查询都是以分号进行分隔 , 如果不添加分号, 默认开启多行查询 123456789MariaDB [(none)]&gt; select version(),now(),user() -&gt; ;+-----------------+---------------------+----------------+| version() | now() | user() |+-----------------+---------------------+----------------+| 10.1.31-MariaDB | 2018-04-24 19:47:09 | root@localhost |+-----------------+---------------------+----------------+1 row in set (0.00 sec) 数据库使用数据库操作 以下是数据库操作的增删改查的相关命令 创建数据库 create database demo; 删除数据库 drop database demo 查看所有的数据库 show databases; 使用数据库 MariaDB [chat]&gt; use chat; 数据表的使用 在使用数据表之前要先确定在哪个数据库下面开始操作, 先使用 use 数据库 选择要使用的数据库, 也就是说在哪个数据库下面开始进行表的操作 1.创建数据表 create table pet (name varchar(20),owner varchar(20),species varchar(20),sex char(1),birth date,death date); 2.查看数据表show tables; 3.查看表的详细内容 DESCRIBE和 EXPLAIN语句是同义词，或者用于获取有关表结构或查询执行计划的信息 describe – 描述explain – 解释,说明 1234567891011121314151617181920212223242526MariaDB [test]&gt; describe pet;+---------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+-------------+------+-----+---------+-------+| name | varchar(20) | YES | | NULL | || owner | varchar(20) | YES | | NULL | || species | varchar(20) | YES | | NULL | || sex | char(1) | YES | | NULL | || birth | date | YES | | NULL | || death | date | YES | | NULL | |+---------+-------------+------+-----+---------+-------+6 rows in set (0.01 sec)MariaDB [test]&gt; explain pet;+---------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+-------------+------+-----+---------+-------+| name | varchar(20) | YES | | NULL | || owner | varchar(20) | YES | | NULL | || species | varchar(20) | YES | | NULL | || sex | char(1) | YES | | NULL | || birth | date | YES | | NULL | || death | date | YES | | NULL | |+---------+-------------+------+-----+---------+-------+6 rows in set (0.01 sec) field 列名 type 类型 null 是否能为null key 是否被索引 default 列的默认值 extra 如果表有索引，SHOW INDEX FROM tbl_name生成有关索引的信息。MariaDB [test]&gt; show index from pet;+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+| pet | 1 | name | 1 | name | A | 8 | NULL | NULL | YES | BTREE | | |+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+1 row in set (0.00 sec) 增 创建表后，您需要填充它。该 LOAD DATA和 INSERT语句是这个有用的。 1234567// 向数据库中插入内容insert into pet values (1,1,1,1,&apos;2010-1-1&apos;,&apos;2011-1-1&apos;);// 通过本地文件的形式向数据库中插入内容 ---- 读取本地的my.txt文件,将里面的内容插入到数据库// 在数据插入的时候需要固定的数据格式// 每条数据之间都需要一个制表符隔开 也就是一个tab键load data local infile &apos;D:/xampp/htdocs/my.txt&apos; into table pet; 删 删除name=1的数据 delete from pet where name=1; 改 更新所有的数据 update pet set name=1 更新部分数据 update pet set name=&#39;哈哈哈&#39; where name=1; 查 select声明用于从表中提取信息 基本格式 12select ... from ... where ... 查询所有的数据 select * from pet 选择特定的行 select * from pet where name=1 select * from pet where birth&gt;&#39;1994-11-11&#39;; and select * from where name=1 &amp;&amp; age=2 or select * from where anme=1 or age=2 and和or的连用 select * from where (name=1 and age=2) or (name=3 and age=4) 选择查看特定的列 查看name这一列的数据 select name from pet 查看name这一列的不重复的数据 select distinct name from pet; 组合语句 select name from pet where name=1 排序查询 order desc 使用 order by 实现查询 select * from pet order by name; 默认排序的情况是不区分大小写的, 在排序的时候区分大小写 select * from pet order by binary name; 降序排列 desc ,在使用 order by 的时候进行排序默认的是升序排序,使用倒序的话 ,需要添加 desc 关键字, 实例如下 select * from pet order by name desc; 对多个列进行排序 123456789101112131415161718192021// 先根据name进行排序,再根据birth进行逆序排序MariaDB [test]&gt; select * from pet order by name,birth desc;+------+-------+---------+------+------------+------------+| name | owner | species | sex | birth | death |+------+-------+---------+------+------------+------------+| 1 | NULL | NULL | NULL | 1999-10-10 | NULL || 1 | 1 | 1 | 1 | 0000-00-00 | 0000-00-00 || 2 | 2 | 2 | 2 | 1995-11-11 | 0000-00-00 |+------+-------+---------+------+------------+------------+3 rows in set (0.00 sec)// 先根据name进行排序,再根据birth进行升序排序MariaDB [test]&gt; select * from pet order by name,birth;+------+-------+---------+------+------------+------------+| name | owner | species | sex | birth | death |+------+-------+---------+------+------------+------------+| 1 | 1 | 1 | 1 | 0000-00-00 | 0000-00-00 || 1 | NULL | NULL | NULL | 1999-10-10 | NULL || 2 | 2 | 2 | 2 | 1995-11-11 | 0000-00-00 |+------+-------+---------+------+------------+------------+3 rows in set (0.00 sec) 日期计算 表操作获取当前日期 curdate() 表操作获取当前月份 month(birth) 时间计算 timestampdiff(年份,开始时间,结束时间)123456789101112MariaDB [test]&gt; select name,birth, curdate(),timestampdiff(year,birth,curdate()) as age from pet order by name;+------+------------+------------+------+| name | birth | curdate() | age |+------+------------+------------+------+| 1 | 2018-04-25 | 2018-04-25 | 0 || 1 | 2018-04-25 | 2018-04-25 | 0 || 2 | 1999-10-10 | 2018-04-25 | 18 || 2 | 1995-11-11 | 2018-04-25 | 22 || 3 | 2018-04-26 | 2018-04-25 | 0 || 4 | 2018-04-17 | 2018-04-25 | 0 |+------+------------+------------+------+6 rows in set (0.00 sec) 匹配模式 - like 查询所有的内容 12345678910111213MariaDB [test]&gt; select * from pet order by name;+------+-------------+---------+------+------------+------------+| name | owner | species | sex | birth | death |+------+-------------+---------+------+------------+------------+| 1 | qibaobao | 1 | 1 | 2018-04-25 | 2018-04-20 || 1 | gaohui | 1 | 1 | 2018-04-25 | 2018-04-28 || 2 | fengbin | 2 | 2 | 1999-10-10 | 2018-04-05 || 2 | suming | 2 | 2 | 1995-11-11 | 2018-04-17 || 3 | xiaotibai | 3 | 3 | 2018-04-26 | 2018-04-29 || 4 | wanghongyan | 4 | 4 | 2018-04-17 | 2018-04-30 || 5 | hahha | 5 | 5 | 2018-12-31 | 2019-01-01 |+------+-------------+---------+------+------------+------------+7 rows in set (0.00 sec) 查询以…开头的like像MariaDB [test]&gt; select * from pet where owner like &#39;q%&#39;; 查询以 … 结束的 likeMariaDB [test]&gt; select * from pet where owner like &#39;%a&#39;; 查询包含 … 的 likeMariaDB [test]&gt; select * from pet where owner like &#39;%a%&#39;; 查找含有指定字符个数的内容 —- 五个字符MariaDB [test]&gt; select * from pet where owner like &#39;_____&#39;; 扩展正则表达式`MariaDB [test]&gt; select * from pet where owner regexp ‘^a’; 计数行-分组 [test]> select name,count(*) from pet group by name;```123456788. 多表查询 - 查询两张表的数据`SELECT event.name,remark,type FROM pet INNER JOIN event ON pet.name = event.name` - 其他 mysql&gt; SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species -&gt; FROM pet AS p1 INNER JOIN pet AS p2 -&gt; ON p1.species = p2.species AND p1.sex = ‘f’ AND p2.sex = ‘m’;+——–+——+——–+——+———+| name | sex | name | sex | species |+——–+——+——–+——+———+| Fluffy | f | Claws | m | cat || Buffy | f | Fang | m | dog || Buffy | f | Bowser | m | dog |+——–+——+——–+——+———+ `","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"01-mysql基础","slug":"mysql/01-mysql基础","permalink":"http://yoursite.com/categories/mysql/01-mysql基础/"}],"tags":[]},{"title":"基本开发环境","slug":"react/555-开发环境搭建/555-1-react基本开发环境搭建","date":"2018-05-08T00:22:58.136Z","updated":"2018-05-08T00:49:49.165Z","comments":true,"path":"2018/05/08/react/555-开发环境搭建/555-1-react基本开发环境搭建/","link":"","permalink":"http://yoursite.com/2018/05/08/react/555-开发环境搭建/555-1-react基本开发环境搭建/","excerpt":"","text":"基本开发环境基本使用 在页面中使用引入 123456&lt;!--react的核心库--&gt;&lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;!--react的与dom相关的一些功能--&gt;&lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;!--将浏览器不支持的jsx语法转化为js语法--&gt;&lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; 开发环境搭建 使用 create-react-app 快速构建 React 开发环境 安装项目模板 基于webpack快速搭建开发环境 1.全局安装开发环境 1npm install -g create-react-app 2.创建react项目 1create-react-app my-app 3.切换目录 12345678cd my-app辅助cmd命令: mkdir del rmdir tree 4.启动应用程序 12npm start 目录结构解析 使用 tree /f &gt; tree.txt 命令生成项目目录结构 1234567891011121314151617├─ .gitignore│ package.json│ README.md│ ├─public│ favicon.ico│ index.html│ manifest.json│ └─src App.css App.js App.test.js index.css index.js logo.svg registerServiceWorker.js","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"555-开发环境搭建","slug":"react/555-开发环境搭建","permalink":"http://yoursite.com/categories/react/555-开发环境搭建/"}],"tags":[]},{"title":"react编程思想","slug":"react/23-react编程思想/23-react编程思想","date":"2018-05-08T00:22:58.120Z","updated":"2018-05-08T00:49:55.454Z","comments":true,"path":"2018/05/08/react/23-react编程思想/23-react编程思想/","link":"","permalink":"http://yoursite.com/2018/05/08/react/23-react编程思想/23-react编程思想/","excerpt":"","text":"react编程思想","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"23-react编程思想","slug":"react/23-react编程思想","permalink":"http://yoursite.com/categories/react/23-react编程思想/"}],"tags":[]},{"title":"组合和继承","slug":"react/22-组合和继承/22-组合和继承","date":"2018-05-08T00:22:58.120Z","updated":"2018-05-08T00:50:15.950Z","comments":true,"path":"2018/05/08/react/22-组合和继承/22-组合和继承/","link":"","permalink":"http://yoursite.com/2018/05/08/react/22-组合和继承/22-组合和继承/","excerpt":"","text":"组合和继承","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"22-组合和继承","slug":"react/22-组合和继承","permalink":"http://yoursite.com/categories/react/22-组合和继承/"}],"tags":[]},{"title":"状态提升","slug":"react/21-状态提升/21-状态提升","date":"2018-05-08T00:22:58.105Z","updated":"2018-05-08T00:41:29.337Z","comments":true,"path":"2018/05/08/react/21-状态提升/21-状态提升/","link":"","permalink":"http://yoursite.com/2018/05/08/react/21-状态提升/21-状态提升/","excerpt":"","text":"状态提升","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"21-状态提升","slug":"react/21-状态提升","permalink":"http://yoursite.com/categories/react/21-状态提升/"}],"tags":[]},{"title":"redux","slug":"react/16-redux/16-redux","date":"2018-05-08T00:22:58.105Z","updated":"2018-05-08T00:41:14.464Z","comments":true,"path":"2018/05/08/react/16-redux/16-redux/","link":"","permalink":"http://yoursite.com/2018/05/08/react/16-redux/16-redux/","excerpt":"","text":"redux 状态管理 redux是将整个应用程序的状态存储到一个地方, 称为store","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"16-redux","slug":"react/16-redux","permalink":"http://yoursite.com/categories/react/16-redux/"}],"tags":[]},{"title":"react-router","slug":"react/12-router/12-router","date":"2018-05-08T00:22:58.089Z","updated":"2018-05-08T00:41:02.421Z","comments":true,"path":"2018/05/08/react/12-router/12-router/","link":"","permalink":"http://yoursite.com/2018/05/08/react/12-router/12-router/","excerpt":"","text":"react-router路由的基本实现注意事项 Router或者说是 BrowserRouter 的内部 只能有一个根元素 1.引入相关的包 12345import &#123; BrowserRouter as Router, Route, Link&#125; from &apos;react-router-dom&apos; 2.创建组件并导入 123456789101112131415161718192021222324252627282930313233343536373839404142// 创建home组件import React , &#123;Component&#125; from &quot;react&quot;export class Home extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;// 创建About组件import React , &#123;Component&#125; from &quot;react&quot;export class About extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;关于&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;// 创建topic组件import React , &#123;Component&#125; from &quot;react&quot;export class Topic extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;主题&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;import &#123;Home&#125; from &apos;./home/home&apos;import &#123;About&#125; from &apos;./about/about&apos;import &#123;Topic&#125; from &apos;./topic/topic&apos; 3-4.完善路由跳转链接和路由信息配置 123456789101112131415161718192021222324&lt;Router&gt; &lt;div&gt; &#123;/*3. 定义路由跳转的链接*/&#125; &lt;ul&gt; &lt;li&gt; &lt;Link to=&apos;/&apos;&gt;首页&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&apos;/about&apos;&gt;关于&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&apos;/topic&apos;&gt;主题&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr/&gt; &#123;/*4. 配置路由信息*/&#125; &#123;/*exact : 确切的 精确的*/&#125; &lt;Route exact path=&apos;/&apos; component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path=&apos;/about&apos; component=&#123;About&#125;&gt;&lt;/Route&gt; &lt;Route path=&apos;/topic&apos; component=&#123;Topic&#125;&gt;&lt;/Route&gt; &lt;/div&gt;&lt;/Router&gt; 二级路由 在上述代码的基础上修改 Topic 组件 ,可以实现二级路由 注意事项 获取一级路由信息, 类组件使用 this.props , 函数式组件使用 props 参数 在路由跳转的时候进行拼接url &lt;Link to={${props.url}/topic2}&gt;topic2&lt;/Link&gt; &lt;Route path={${props.url}/topic1} component={Topic1}&gt;&lt;/Route&gt; 路由参数的获取 使用 console.log(props.match.params.id) 具体内容参考以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import React , &#123;Component&#125; from &quot;react&quot;import &#123;BrowserRouter as Router,Route, Link&#125; from &quot;react-router-dom&quot;// 主题组件1function Topic1 () &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )&#125;// 主题组件2function Topic2 () &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )&#125;// 主题组件3function Topic3 (props) &#123; // 获取传递的id参数 console.log(props.match.params.id) return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )&#125;// 函数式组件 ---- 路由创建2function BasicExample2 (props) &#123; console.log(props.url) return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;props.url&#125;/topic1`&#125;&gt;topic1&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;props.url&#125;/topic2`&#125;&gt;topic2&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;props.url&#125;/topic3`&#125;&gt;topic3&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=&#123;`$&#123;props.url&#125;/topic1`&#125; component=&#123;Topic1&#125;&gt;&lt;/Route&gt; &lt;Route path=&#123;`$&#123;props.url&#125;/topic2`&#125; component=&#123;Topic2&#125;&gt;&lt;/Route&gt; &lt;Route path=&#123;`$&#123;props.url&#125;/topic3`&#125; component=&#123;Topic3&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/Router&gt; )&#125;export class Topic extends Component&#123; render()&#123; console.log(this.props.match.path) return ( &lt;div&gt; &lt;h2&gt;主题&lt;/h2&gt; &lt;BasicExample2 url=&#123;this.props.match.path&#125;&gt;&lt;/BasicExample2&gt; &lt;/div&gt; ) &#125;&#125; api文档BrowserRouter","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"12-router","slug":"react/12-router","permalink":"http://yoursite.com/categories/react/12-router/"}],"tags":[]},{"title":"forms","slug":"react/10-form/10-forms","date":"2018-05-08T00:22:58.073Z","updated":"2018-05-08T00:40:47.420Z","comments":true,"path":"2018/05/08/react/10-form/10-forms/","link":"","permalink":"http://yoursite.com/2018/05/08/react/10-form/10-forms/","excerpt":"","text":"forms表单概述 HTML 表单元素与 React 中的其他 DOM 元素有所不同，因为表单元素自然地保留了一些内部状态。例如，这个纯 HTML 表单接受一个单独的 name： 1234567&lt;form&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 该表单和 HTML 表单的默认行为一致，当用户提交此表单时浏览器会打开一个新页面。如果你希望 React 中保持这个行为，也可以工作。但是多数情况下，用一个处理表单提交并访问用户输入到表单中的数据的 JavaScript 函数也很方便。实现这一点的标准方法是使用一种称为“受控组件(controlled components)”的技术。 受控组件Controll 在 HTML 中，表单元素如 &lt;input&gt;，&lt;textarea&gt; 和 &lt;select&gt;表单元素通常保持自己的状态，并根据用户输入进行更新。而在 React 中，可变状态一般保存在组件的 state(状态) 属性中，并且只能通过 setState()更新。 我们可以通过使 React 的 state 成为 “单一数据源原则”来结合这两个形式。然后渲染表单的 React 组件也可以控制在用户输入之后的行为。这种形式，其值由 React 控制的输入表单元素称为“受控组件”。 数据/状态的定义: 使用 this.state = {} 状态的修改: this.state.setState({}) 12345678910111213141516171819202122232425262728293031323334 // 定义类组件class NameForms extends React.Component&#123; constructor(props)&#123; super(props) // 定义状态 this.state = &#123;value:&apos;&apos;&#125; // 函数可以产生独立作用域 ,在这里修改函数内部的指针指向 当前组件(类) this.handleChange = this.handleChange.bind(this) this.handleSubmit = this.handleSubmit.bind(this) &#125; handleChange(e)&#123; this.setState(&#123;value:e.target.value&#125;) &#125; handleSubmit(e)&#123; alert(&quot;A name was submitted : &quot; + this.state.value) e.preventDefault() &#125; render()&#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label for=&quot;&quot;&gt; name : &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ) &#125;&#125;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"10-form","slug":"react/10-form","permalink":"http://yoursite.com/categories/react/10-form/"}],"tags":[]},{"title":"react数据请求","slug":"react/08-数据请求/08-fetchApi-数据请求","date":"2018-05-08T00:22:58.042Z","updated":"2018-05-08T00:40:36.587Z","comments":true,"path":"2018/05/08/react/08-数据请求/08-fetchApi-数据请求/","link":"","permalink":"http://yoursite.com/2018/05/08/react/08-数据请求/08-fetchApi-数据请求/","excerpt":"","text":"react数据请求参考文档 https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch 基本使用cdn链接1&lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; get请求静态数据 最初的时候, 渲染页面 , 数据都是写在本页面 这样操作的问题是修改页面内容不方便, 只能通过操作本页面完成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[ &#123;&quot;id&quot;:&quot;123001&quot;,&quot;name&quot;:&quot;xiaoming&quot;&#125;, &#123;&quot;id&quot;:&quot;123002&quot;,&quot;name&quot;:&quot;xiaobing&quot;&#125;, &#123;&quot;id&quot;:&quot;123003&quot;,&quot;name&quot;:&quot;xiaona&quot;&#125; ] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; json文件 实现页面结构和数据的分离, 修改页面内容的时候, 操作文件即可 以json文件为例, 修改json文件之后, 我们页面的内容也会发生变化 json文件定义—-数据定义 12345[ &#123;&quot;id&quot;:&quot;123001&quot;,&quot;name&quot;:&quot;xiaoming&quot;&#125;, &#123;&quot;id&quot;:&quot;123002&quot;,&quot;name&quot;:&quot;xiaobing&quot;&#125;, &#123;&quot;id&quot;:&quot;123003&quot;,&quot;name&quot;:&quot;xiaona&quot;&#125;] 请求json文件,完成页面的渲染 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &quot;data.json&quot; var option = &#123; methods:&quot;get&quot; &#125; fetch(url,option).then((res)=&gt;&#123; return res.json() &#125;).then((res)=&gt;&#123; // 请求到的数据 console.log(res) // 修改state this.setState(&#123; arr:res &#125;) // 打印输出 console.log(this.state.arr) &#125;) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 数据库 为了便于数据的操作, 我们平时看到的页面上的数据一般都是存在数据库的, 通过后台管理系统, 能够很方便的实现数据的修改 – 此例 不多做演示 在线接口 书写数据接口, 通过后台操作, 读取数据库数据, 并做成接口的形式, 我们需要对数据进行操作的时候,直接操作接口即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; [&#123;&quot;id&quot;:&quot;123001&quot;,&quot;name&quot;:&quot;xiaoming&quot;&#125;,&#123;&quot;id&quot;:&quot;123002&quot;,&quot;name&quot;:&quot;xiaobing&quot;&#125;,&#123;&quot;id&quot;:&quot;123003&quot;,&quot;name&quot;:&quot;xiaona&quot;&#125;] class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &quot;http://www.taoquan.store/robot/getUsers.php&quot; var option = &#123; methods:&quot;get&quot; &#125; fetch(url,option).then((res)=&gt;&#123; return res.json() &#125;).then((res)=&gt;&#123; // 请求到的数据 console.log(res.users) // 修改state this.setState(&#123; arr:res.users &#125;) // 打印输出 console.log(this.state.arr) &#125;) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; post请求 将数据提交到数据库 基本示例 在真正操作的时候只需要将要提交的数据换成表单数据即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Com extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; num:1 &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &apos;http://127.0.0.1:8899/api/insertData&apos; var options = &#123; method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125;, body: &apos;name=1&amp;sex=2&amp;email=3&amp;phone=4&amp;address=5&apos; &#125; fetch(url,options) .then((res)=&gt;&#123; return res.json() &#125;) .then((res)=&gt;&#123; console.log(res) &#125;) &#125; &#125; ReactDOM.render( &lt;Com&gt;&lt;/Com&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 核心代码1234567891011121314151617var url = &apos;http://127.0.0.1:8899/api/insertData&apos;var options = &#123; method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125;, body: &apos;name=1&amp;sex=2&amp;email=3&amp;phone=4&amp;address=5&apos;&#125;fetch(url,options).then((res)=&gt;&#123; return res.json()&#125;).then((res)=&gt;&#123; console.log(res)&#125;) 第二种方式12345678910111213141516171819202122componentDidMount()&#123; var data = &#123; name:&quot;1&quot;, sex:&quot;2&quot;, email:&quot;3&quot;, phone:&quot;4&quot;, address:&quot;5&quot; &#125; fetch(&apos;http://127.0.0.1:8899/api/insertData&apos;,&#123; method: &apos;POST&apos;, body: `data=$&#123;JSON.stringify(data)&#125;`, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &#125; &#125;) .then((res)=&gt;&#123; console.log(res.json()) &#125;)&#125; 文件上传 Content-Type：上传文件的时候，一定要设置为application/x-www-form-urlencoded 跨域fetch跨域概述 在fetch的配置中有 mode选项 , 提供了跨域的能力 mode: ‘cors’, // no-cors, cors, *same-origin mode:’cors’ 这个选项提供了跨域的能力, 但是服务端必须支持 cors ,也就是设置 res.header(“Access-Control-Allow-Origin”, “*”); mode:’no-cors’ 可以跨域进行数据请求 , 不需要设置跨域 header 在该模式下 得到的返回数据中 type为opaque。, 能够在控制台看到返回的数据, 但是没有权限使用这些数据 mode:”same-origin” 同源, 不允许跨域 并不能成功跨域进行数据的访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!--数据请求--&gt; &lt;script src=&quot;https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Fetch_get extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:[] &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &#123; this.state.arr.map((ele,index,arr)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; var url = &quot;https://api.douban.com/v2/movie/top250&quot; // var url = &apos;http://127.0.0.1:8899/api/selectData&apos; var option = &#123; methods:&quot;get&quot;, mode:&apos;no-cors&apos; &#125; fetch(url,option).then((res)=&gt;&#123; console.log(res) &#125;) &#125; &#125; ReactDOM.render( &lt;Fetch_get&gt;&lt;/Fetch_get&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 使用jsonp调取数据 在原生js中, 利用script标签的支持跨域的特性进行 第一种方式 利用script标签的跨域访问特性 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSONP实现跨域2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--代码的先后顺序 不能变--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn(response)&#123; console.log(response); &#125;&lt;/script&gt;&lt;script src=&quot;https://api.douban.com/v2/movie/top250?callback=fn&quot;&gt;&lt;/script&gt; 第二种方式 动态创建script标签 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSONP实现跨域2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--代码的先后顺序 不能变--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn(response)&#123; console.log(response); &#125; var script = document.createElement(&apos;script&apos;) script.src = &apos;https://api.douban.com/v2/movie/top250?callback=fn&apos; document.body.insertBefore(script, document.body.firstChild); &lt;/script&gt; 第三种方式 使用jquery 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; type:&apos;get&apos;, url:&quot;https://api.douban.com/v2/movie/top250?callback=?&quot;, success(res)&#123; console.log(res) &#125;, dataType:&quot;jsonp&quot; &#125;) &lt;/script&gt; 项目中使用 create-react-app fetchApi的使用 npm 地址 https://www.npmjs.com/package/whatwg-fetch 详细的使用说明可以参考这个文档 12345671. 安装 npm install whatwg-fetch --save2. 配置 在使用webpack的时候,需要完成这一步的配置 entry: [&apos;whatwg-fetch&apos;, ...]3. 使用 直接导入这个包即可 import &apos;whatwg-fetch&apos; 请求html文件12345678HTMLfetch(&apos;/users.html&apos;) .then(function(response) &#123; return response.text() &#125;).then(function(body) &#123; document.body.innerHTML = body &#125;) get 请求获取数据 在componentDidMount(){}生命周期钩子中进行数据的初始化操作 1.在构造函数中初始化状态(数据) 1234567constructor(props)&#123; super(props) this.state = &#123; arr:[], name:&quot;test&quot; &#125;&#125; 2.在 componentDidMount 中发送请求,获取数据 12345678910111213141516componentDidMount() &#123; console.log(1) fetch(&apos;http://gaohuimusic.nat123.cc:11444/personalized&apos;) .then((response) =&gt; &#123; return response.json() &#125;).then((json) =&gt; &#123; console.log(&apos;parsed json&apos;, json) this.setState(&#123; arr:json.result &#125;) console.log(this.state.arr) &#125;).catch(function(ex) &#123; console.log(&apos;parsing failed&apos;, ex) &#125;)&#125; 3.在render()函数中完成页面渲染—-将请求到的数据渲染到页面 1234567891011121314render() &#123; return ( &lt;div&gt; &lt;p&gt;这是tab1&lt;/p&gt; &lt;div&gt; &lt;ul&gt; &#123;this.state.arr.map(function(ele,index,arr)&#123; return &lt;li key=&#123;index&#125;&gt;&#123;ele.name&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; )&#125; post 请求","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"08-数据请求","slug":"react/08-数据请求","permalink":"http://yoursite.com/categories/react/08-数据请求/"}],"tags":[]},{"title":"组件补充","slug":"react/07-组件补充/07-组件补充","date":"2018-05-08T00:22:57.995Z","updated":"2018-05-08T00:40:22.704Z","comments":true,"path":"2018/05/08/react/07-组件补充/07-组件补充/","link":"","permalink":"http://yoursite.com/2018/05/08/react/07-组件补充/07-组件补充/","excerpt":"","text":"组件补充组件的嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1.1 创建一个基本的组件 function Welcome(props)&#123; return ( &lt;div&gt; &lt;p&gt;&#123;props.name&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; // 1.2 创建一个app组件,并使用Welcome组件 function App(props)&#123; return ( &lt;div&gt; &lt;Welcome name=&quot;1&quot;&gt;&lt;/Welcome&gt; &lt;Welcome name=&quot;2&quot;&gt;&lt;/Welcome&gt; &lt;Welcome name=&quot;3&quot;&gt;&lt;/Welcome&gt; &lt;/div&gt; ) &#125; var element = &lt;App&gt;&lt;/App&gt; // 2. 组件的使用 ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 公共组件的提取12 props总结props是只读的 所有 React 组件都必须是纯函数，并禁止修改其自身 props 。 知识点扩充纯函数 不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。 123function sum(a, b) &#123; return a + b;&#125; 非纯函数 改变了自身的输入值 123function withdraw(account, amount) &#123; account.total -= amount;&#125;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"07-组件补充","slug":"react/07-组件补充","permalink":"http://yoursite.com/categories/react/07-组件补充/"}],"tags":[]},{"title":"组件传值","slug":"react/06-组件传值/06-组件传值","date":"2018-05-08T00:22:57.964Z","updated":"2018-05-08T00:52:18.304Z","comments":true,"path":"2018/05/08/react/06-组件传值/06-组件传值/","link":"","permalink":"http://yoursite.com/2018/05/08/react/06-组件传值/06-组件传值/","excerpt":"","text":"组件传值 每个组件 的作用域都是独立的, 有时候需要在组件之间完成数据的传递,需要通过组件传值的方式来实现 组件传值可以分为以下三类 父组件向子组件传递数据 子组件向父组件传递数据 非父子组件之间的数据传递 父传子 – 简化版函数式组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot; class=&quot;parent&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个函数组件 ---- 使用props完成值得接收 function Child(props)&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; ReactDOM.render( // 渲染组件 并通过name属性完成传值 &lt;Child name=&quot;3&quot;&gt;&lt;/Child&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个类组件 class Child extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Child name=&quot;1&quot;&gt;&lt;/Child&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 组件传值详解1234567我们调用了 ReactDOM.render() 方法并向其中传入了 &lt;Child name=&quot;1&quot; /&gt; 元素。React 调用 Child 组件，并向其中传入了 &#123;name: &apos;1&apos;&#125; 作为 props 对象。Child 组件返回 &lt;li&gt;1&lt;/li&gt;。React DOM 迅速更新 DOM ，使其显示为 &lt;li&gt;1&lt;/li&gt;。 父传子 – 完整版函数式组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个父组件 function Parent()&#123; return ( &lt;div&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &#123;/*在父组件中嵌套子组件*/&#125; &lt;Child name=&quot;1&quot;&gt;&lt;/Child&gt; &lt;/div&gt; ) &#125; // 创建一个子组件 列表 function Child(props)&#123; return ( &lt;div&gt; &lt;h3&gt;这是子组件&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&#123;props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; // 2. 组件的使用 ReactDOM.render( &lt;Parent&gt;&lt;/Parent&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个类组件 -- 父 class Parent extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &#123;/*在父组件中嵌套子组件*/&#125; &lt;Child name=&quot;1&quot;&gt;&lt;/Child&gt; &lt;/div&gt; ) &#125; &#125; // 创建一个类组件 -- 子 class Child extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;h3&gt;这是子组件&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Parent&gt;&lt;/Parent&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 子传父函数式组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; //子组件 function Child(props)&#123; return ( &lt;div&gt; &#123;/*当文本框内容发生变化的时候.会执行父组件里面的事件*/&#125; 子组件：&lt;input onChange=&#123;props.handleEmail&#125;/&gt; &lt;/div&gt; ) &#125; //父组件 function Parent() &#123; return ( &lt;div&gt; &lt;div id=&apos;div&apos;&gt;父组件：&#123;1&#125;&lt;/div&gt; &lt;Child name=&quot;email&quot; handleEmail=&#123; function (event)&#123; /*获取子组件的数据*/ console.log(event.target.value) document.getElementById(&apos;div&apos;) = event.target.value &#125; &#125;/&gt; &lt;/div&gt; ) &#125; ReactDOM.render( &lt;Parent /&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; //子组件 class Child extends React.Component&#123; render()&#123; return ( &lt;div&gt; &#123;/*当文本框内容发生变化的时候.会执行父组件里面的事件*/&#125; 子组件：&lt;input onChange=&#123;this.props.handleEmail&#125;/&gt; &lt;/div&gt; ) &#125; &#125; //父组件 class Parent extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; email:&apos;&apos; &#125; &#125; handleEmail(event)&#123; this.setState(&#123;email: event.target.value&#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;div&gt;父组件：&#123;this.state.email&#125;&lt;/div&gt; &lt;Child name=&quot;email&quot; handleEmail=&#123;this.handleEmail.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Parent /&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 非父子非父子组件传值之兄弟组件传值 使用中间人模式 , 定义一个公共的父组件来实现兄弟组件之间的数据传递 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Brother1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.props.refresh&#125;&gt; 更新兄弟组件 &lt;/button&gt; &lt;/div&gt; ) &#125; &#125; class Brother2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.text || &quot;兄弟组件未更新&quot;&#125; &lt;/div&gt; ) &#125; &#125; class Parent extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; refresh()&#123; return (e)=&gt;&#123; this.setState(&#123; text: &quot;兄弟组件沟通成功&quot;, &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;兄弟组件沟通&lt;/h2&gt; &lt;Brother1 refresh=&#123;this.refresh()&#125;/&gt; &lt;Brother2 text=&#123;this.state.text&#125;/&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;Parent /&gt;, document.getElementById(&apos;root&apos;));&lt;/script&gt; 使用jquery自定义事件完成传值 根据上面理解的思路, 使用jquery的事件机制作为中间人, 实现数据的传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Com1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; $(&apos;#root&apos;).on(&apos;bus&apos;,function(e,a,b)&#123; console.log(a,b) &#125;) &#125; &#125; class Com2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; $(&apos;#root&apos;).trigger(&apos;bus&apos;,[11,22]) &#125; &#125; ReactDOM.render( &lt;div&gt; &lt;Com1&gt;&lt;/Com1&gt; &lt;Com2&gt;&lt;/Com2&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;));&lt;/script&gt; 使用原生js的方式实现组件之间的数据的传递 上述使用jquery能够实现数据的传递,但是这样操作的话, 并不是最佳的方式 如果我们只是为了实现组件之间的数据传递而引入jquery框架, 会使项目变得臃肿 为了更好的体验, 我们可以使用原生js的自定义事件的方式完成组件之间的数据的传递 注意事项: 在这里,只是关注与功能的实现, 不考虑兼容性的问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 给dom元素绑定事件 ---- 作为中间人 var elem = document.getElementById(&apos;root&apos;) var events = new Event(&apos;build&apos;); class Com1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; // 给dom元素添加事件监听, 通过函数参数完成数据的接收 elem.addEventListener(&apos;build&apos;, function (event) &#123; console.log(event.name) &#125;, false); &#125; &#125; class Com2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; name:&apos;我是小高&apos; &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; events.name = this.state.name elem.dispatchEvent(events) &#125; &#125; ReactDOM.render( &lt;div&gt; &lt;Com1&gt;&lt;/Com1&gt; &lt;Com2&gt;&lt;/Com2&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;));&lt;/script&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"06-组件传值","slug":"react/06-组件传值","permalink":"http://yoursite.com/categories/react/06-组件传值/"}],"tags":[]},{"title":"state和生命周期","slug":"react/05-state和生命周期/05-state和生命周期","date":"2018-05-08T00:22:57.933Z","updated":"2018-05-08T00:40:00.388Z","comments":true,"path":"2018/05/08/react/05-state和生命周期/05-state和生命周期/","link":"","permalink":"http://yoursite.com/2018/05/08/react/05-state和生命周期/05-state和生命周期/","excerpt":"","text":"state和生命周期state state 允许 React 组件在不违反props规则的情况下, 根据用户操作, 网络响应, 或者其他随便什么东西, 来动态地改变其输出。类似于vue中的data state的定义 在类组件的constructor中定义state 12345678constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;; &#125; 状态的修改不能直接修改state 需要调用this.setState() 12345678910// 错误 这样将不会重新渲染一个组件：this.state.comment = &apos;Hello&apos;;// 正确 用 setState() 代替：this.setState(&#123;comment: &apos;Hello&apos;&#125;);唯一可以分配 this.state 的地方是构造函数。 state(状态) 更新可能是异步的使用回调函数的形式实现异步操作 需要将对象参数转变为回调函数的形式 1234567891011121314// 错误this.setState(&#123; counter: this.state.counter + this.props.increment,&#125;);// 正确this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;));使用另一种 setState() 的形式，它接受一个函数而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数： state(状态)更新会被合并你的状态可能包含几个独立的变量： 12345678constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125; 调用this.setState()修改单个的状态不会影响其他的状态,只会合并当前修改的这一个状态 react-hook函数hook函数的基本概念hook函数参考链接 https://baike.baidu.com/item/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0?fr=aladdin 钩子函数是window消息处理机制的一部分,通过设置”钩子”,应用程序可以在系统级对所有消息,事件进行过滤,访问在正常情况下无法访问的消息 钩子函数的本质是一段用以处理系统消息的程序,通过系统调用,把它挂入系统 react组件的三个状态1.mount123react Components被render解析生成对应的dom节点被插入浏览器的dom结构的一个过程在浏览器上看到组件元素从无到有的过程 2.update 1234一个mounte的react Component被重新render的过程,但是在这个过程中,dom结构并不一定会发生改变在react中,状态的改变会触发update的hook函数 3.unmount 1一个mount的react Component对应的dom节点被从dm中移除的一个过程 react针对以上三种状态都封装了hook函数 生命周期钩子详解mounting 如下这些方法在组件实例被创建和被插入到dom中时被调用。 1.constructor() constructor初始化state的好地方。如果我们不需要初始化state，也不需要bind任何方法，那么在我们的组件中不需要实现constructor函constructor在组件被mounted之前调用，我们的组件继承自React.Component,constructor函数中我们在其他操作前应该先调用super(props)，否则this.props将会是undefined。 constructor初始化state的好地方。如果我们不需要初始化state，也不需要bind任何方法，那么在我们的组件中不需要实现constructor函数。 注意下面这种情况，很容易产生bug，我们通常的做法是提升state到父组件，而不是使劲的同步state和props。 123456constructor(props) &#123; super(props); this.state = &#123; color: props.initialColor &#125;;&#125; componentWillMount() 此方法在mounting之前被立即调用，它在render()之前调用，因此在此方法中setState不会触发重新渲染。此方法是服务器渲染中调用的唯一的生命周期钩子，通常我们建议使用constructor()。 render() render()方法是react组件必须的，它检查this.props和this.state并且返回一个React元素，我们也可以返回null或false，代表我们不想有任何的渲染。 render()方法应该是一个纯方法，即它不会修改组件的state，在每一次调用时返回同样的结果。它不直接和浏览器交互，如果我们想要交互，应该在componentDidMount()或者其他的生命周期函数里面。 componentDidMount() 此方法在组件被mounted之后立即被调用，初始化dom节点应该在此方法中，如果需要从远端健在数据，这里是实例化网络请求的好地方，此方法中setState会触发组件重新渲染。 Updating props和state的改变产生更新。在重新渲染组建时，如下的方法被调用 componentWillReceiveProps() 一个已经mounted的组件接收一个新的props之前componentWillReceiveProps()被调用，如果我们需要更新state来响应prop的更改，我们可以在此方法中比较this.props和nextProps并使用this.setState来更改state。 注意，即使props没有改变，React也可以调用这个方法，因此如果你只想处理改变，请确保比较当前值和下一个值。当父组件导致你的组件重新渲染时，可能会发生这种情况。 React在组件mounting期间不会调用此方法，只有在一些组件的props可能被更新的时候才会调用。调用this.setState通常不会触发componentWillReceiveProps。 shouldComponentUpdate() 使用此方法让React知道组件的输出是否不受当前state或props更改的影响。默认行为是在每次state更改时重新渲染组件，在大多数情况下，我们应该默认改行为。 当接收到新的props或state时，shouldComponentUpdate()在渲染之前被调用。默认返回true，对于初始渲染或使用forceUpdate()时，不调用此方法。返回false不会阻止子组件的state更改时，该子组件重新渲染。 如果shouldComponentUpdate()返回false，那么componentWillUpdate()，render()和componentDidUpdate()将不会被调用。在将来，React可能将shouldComponentUpdate()作为提示而不是strict指令，返回仍然可能导致组件重新渲染。 componentWillUpdate() 当接收新的props或state时，componentWillUpdate()在组件渲染之前被立即调用。使用此函数作为在更新发生之前执行准备的机会。初始渲染不会调用此方法。 注意：这里不能调用this.setState()(如果调用会怎么样？好奇心很重呀，试了一下，会产生死循环，一直更新。 如果我们需要更新state以响应props的更改，我们应该使用componentWillReceiveProps() render() render()方法是react组件必须的，它检查this.props和this.state并且返回一个React元素，我们也可以返回null或false，代表我们不想有任何的渲染。 render()方法应该是一个纯方法，即它不会修改组件的state，在每一次调用时返回同样的结果。它不直接和浏览器交互，如果我们想要交互，应该在componentDidMount()或者其他的生命周期函数里面。 componentDidUpdate() 此函数在更新后立即被调用。初始渲染不调用此方法。 当组件已经更新时，使用此操作作为DOM操作的机会。这也是一个好的地方做网络请求，只要你比较当前的props和以前的props(例如：如果props没有改变，可能不需要网络请求)。 Unmounting 当从dom中移除组件时，这个方法会被调用 componentWillUnmount() 此函数在组件被卸载和销毁之前被立即调用。在此方法中执行一些必要的清理。例如清除计时器，取消网络请求或者清理在componentDidMount中创建的任何DOM元素。 实例演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/babel\"&gt; // 创建一个类组件 class LifeCycle extends React.Component &#123; // 1. mount阶段 constructor(props) &#123; super(props); this.state = &#123;name: 'wlt'&#125;; this.changeState = this.changeState.bind(this); console.log('constructor'); &#125; componentWillMount() &#123; console.log('componentWillMount'); &#125; render() &#123; console.log('render'); return ( &lt;div className=\"life-cycle-bg\"&gt; &lt;p&gt;Hello &#123;this.props.value&#125;&lt;/p&gt; &lt;p&gt;Hello &#123;this.state.name&#125;&lt;/p&gt; &lt;button onClick=&#123;this.changeState&#125;&gt;改变lifeCycle的state&lt;/button&gt; &lt;/div&gt; ); &#125; componentDidMount() &#123; console.log('componentDidMount'); &#125; // 2. update阶段 componentWillReceiveProps(nextProps) &#123; // 只作用于属性的变化,不作用于状态的变化 console.log('componentWillReceiveProps'); &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log('shouldComponentUpdate'); return true; &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('componentWillUpdate'); &#125; // ---- render会重新执行 componentDidUpdate(prevProps, prevState) &#123; console.log('componentDidUpdate'); &#125; // 3. Unmount阶段 componentWillUnmount(prevProps, prevState) &#123; console.log('componentWillUnmount'); &#125; // 修改状态 changeState() &#123; this.setState(&#123;name: 'sxm'&#125;); &#125; &#125; class ParentLifeCycle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: 'World', destroyed: false, rerender: false &#125;; this.handleChange = this.handleChange.bind(this); this.destroyComponent = this.destroyComponent.bind(this); this.handleRerender = this.handleRerender.bind(this); &#125; handleChange() &#123; this.setState((prevState, props) =&gt; (&#123; value: prevState.value + ' wlt' &#125;)); &#125; handleRerender() &#123; this.setState(&#123;rerender: true&#125;); &#125; destroyComponent() &#123; this.setState(&#123;destroyed: true&#125;); &#125; render() &#123; if(this.state.destroyed) return null; return ( &lt;div className=\"parent-life-cycle-bg\"&gt; &lt;p&gt; &lt;button onClick=&#123;this.handleChange&#125;&gt;改变LifeCyle的props&lt;/button&gt; &lt;button onClick=&#123;this.handleRerender&#125;&gt;父组件重新渲染，子组件re-render&lt;/button&gt; &lt;button onClick=&#123;this.destroyComponent&#125;&gt;删除组件&lt;/button&gt; &lt;/p&gt; &lt;LifeCycle value=&#123;this.state.value&#125;/&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;ParentLifeCycle /&gt;, document.getElementById('root') );&lt;/script&gt; state 和 生命周期一个简单的例子 实现一个基本的定时器功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; // 创建一个组件 -- 使用函数式组件 function Clock()&#123; // 创建元素 const element = ( &lt;div&gt; &lt;h1&gt;hello world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) // 使用render函数渲染已经创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &#125; setInterval(Clock,1000)&lt;/script&gt; 存在的问题 完成定时器的功能,使用组件化的形式进行封装的时候,在进行组件调用的时候应该能够直接通过 就能完成一个定时器,而不用再配合外部的js操作 这样做的话能够实现相关的功能,但是不利于复用 改写 使用组件的形式封装一个计时器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 在组件挂载和卸载的时候,会执行对应的生命周期钩子函数 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 使用类的形式对组件进行改写之后,我们可以向类中添加一些内容 class Clock extends React.Component&#123; constructor(props)&#123; // 类组件应始终使用 props 调用基础构造函数。 super(props) // 使用状态进行改写 this.state = &#123; date:new Date() &#125; &#125; // 组件挂载的生命周期钩子函数 componentDidMount()&#123; console.log(&quot;组件挂载了&quot;) this.timer = setInterval(()=&gt;&#123; // 使用this.setState() 更新本地的状态 this.setState(&#123; date:new Date() &#125;) &#125;,1000) &#125; // 组件卸载时会执行的生命周期钩子函数 componentWillUnmount()&#123; console.log(&quot;组件卸载了&quot;) clearInterval(this.timer) &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;hello world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125; &#125; // 使用render函数渲染已经创建的组件 ----- 三个组件互补影响 ReactDOM.render( &lt;div&gt; &lt;Clock&gt;&lt;/Clock&gt; &lt;Clock&gt;&lt;/Clock&gt; &lt;Clock&gt;&lt;/Clock&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"05-state和生命周期","slug":"react/05-state和生命周期","permalink":"http://yoursite.com/categories/react/05-state和生命周期/"}],"tags":[]},{"title":"组件","slug":"react/04-组件基本使用/04-组件基本使用","date":"2018-05-08T00:22:57.901Z","updated":"2018-05-08T00:39:42.075Z","comments":true,"path":"2018/05/08/react/04-组件基本使用/04-组件基本使用/","link":"","permalink":"http://yoursite.com/2018/05/08/react/04-组件基本使用/04-组件基本使用/","excerpt":"","text":"组件什么是组件 组成的部件 组件使你可以将 UI 划分为一个一个独立，可复用的小部件，并可以对每个部件进行单独的设计。 从定义上来说， 组件就像JavaScript的函数。封装内容, 达到重用的目的. 组件可以接收任意输入(称为”props”)， 并返回 React 元素，用以描述屏幕显示内容 为什么使用组件 封装 重用 如何使用组件 在使用组件的时候, 推荐使用类组件的形式 注意事项 组件的名称 首字母必须大写 一个组件只能有一个根元素 两种组件创建的方式函数式组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1. 创建一个基本的组件 function Welcome()&#123; return ( &lt;div&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;/div&gt; ) &#125; // 2. 组件的使用 ReactDOM.render( &lt;Welcome&gt;&lt;/Welcome&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt; 类组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 组件：组成的部件,可以接受任何props输入,并返回元素 --&gt; &lt;script type=&quot;text/babel&quot;&gt; // 1. 创建一个基本的组件 class Welcome extends React.Component&#123; render ()&#123; return ( &lt;div&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;/div&gt; ) &#125; &#125; // 2. 组件的使用 ReactDOM.render( &lt;Welcome&gt;&lt;/Welcome&gt;, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 补充类组件的事件绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; class Toggle extends React.Component &#123; constructor(props) &#123; super(props); // 设置状态 this.state = &#123;isToggleOn: true&#125;; // 这个绑定是必要的，使`this`在回调中起作用 this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; ); &#125; &#125; ReactDOM.render( &lt;Toggle /&gt;, document.getElementById(&apos;root&apos;) );&lt;/script&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"04-组件基本使用","slug":"react/04-组件基本使用","permalink":"http://yoursite.com/categories/react/04-组件基本使用/"}],"tags":[]},{"title":"jsx语法","slug":"react/02-jsx语法/02-jsx语法","date":"2018-05-08T00:22:57.870Z","updated":"2018-05-19T00:51:53.401Z","comments":true,"path":"2018/05/08/react/02-jsx语法/02-jsx语法/","link":"","permalink":"http://yoursite.com/2018/05/08/react/02-jsx语法/02-jsx语法/","excerpt":"","text":"jsx语法什么是jsx语法语法特点 react使用jsx代替常规的javascript 1234567891011 1. 一个很像是XML的js语法扩展 2. 编写模板更加快速-简单 3. 它是类型安全的,在编译的过程中就能发现错误``` ### 使用规则- react jsx的使用 1. 可以创建一个独立的js文件来使用,通过script标签来引入 2. 使用多个标签,使用div包裹 3. 支持表达式, js表达式可以直接被解析 4. 不支持if else 可以使用三元表达式代替 相当于是vue中 的 v-if 5. 直接解析数组 相当于是vue中的v-for 6. 标签中注释使用花括号包裹,区别于原先的js注释 , 否则的话 , 注释会 直接解析成文本 7. 推荐使用内联样式 直接进行样式的绑定 相当于是vue中的 v-bind 123456789101112131415161718## 为什么使用jsx语法&gt; jsx语法允许html和js的混写, 使页面数据和样式的操作变得钢架简单**核心**- 遇到 `HTML` 标签（以 `&lt;` 开头），就用 `HTML` 规则解析；- 遇到 以 `&#123;` 开头的结构，就用 `js` 规则解析；## 如何使用jsx语法### 标签渲染**遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；** &lt;!DOCTYPE html&gt; Hello World // ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( Hello, world!, document.getElementById(‘root’) ); // 如果{} 渲染的变量是一个数组,jsx语法会解析里面的所有成员并添加到模板 var arr = [ Hello world!, React is awesome ]; ReactDOM.render( {arr}, document.getElementById(‘example’) ) 1234### 代码注释&gt; 在jsx语法中, 标签中写代码注释需要放到&#123;&#125; 中&lt;!DOCTYPE html&gt; Hello World // ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( /注释/ Hello, world! {/注释要加上{} 要不然直接解析成文本/} , document.getElementById(‘root’) ); var i=1; ReactDOM.render( {/*如果是多个标签,推荐使用div包裹*/} react jsx的使用 {/*支持使用js表达式*/} {1+1} {/*不能使用if else 语句,可以使用三元表达式代替*/} {i == 1 ? 'True!' : 'False'} , document.getElementById('example') ); 12### 属性值的绑定 v-bind : &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; var obj = { id:1 } // 属性值的绑定 ReactDOM.render( test, document.getElementById(\"root\") ) 1234### 注意事项**模板部分不能有多个根节点** Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; var obj = { id:1, img:\"./img/01.jpg\" } // 属性值的绑定 ReactDOM.render( , document.getElementById(\"root\") ) 12345678### 事件处理 v-on @&gt; 在react中的事件处理和dom操作类似,但是有一点细微的区别**注意事项:** 1. React 事件使用驼峰命名，而不是全部小写 2. 通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串 12#### dom事件绑定 click me function fn(){ alert(1) } 12#### react事件绑定 Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建元素 var element = ( &lt;button onClick={fn}&gt;click me&lt;/button&gt; ) function fn(){ alert(1) } // 使用render渲染已创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 123#### react的html和js混写 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建元素 var element = ( &lt;button onClick={fn}&gt;click me&lt;/button&gt; ) function fn(){ alert(1) } // 使用render渲染已创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 12#### 事件参数传递 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建元素 绑定事件, 添加事件处理函数 var element = ( &lt;button onClick={ function(e){ console.log(e.target) } }&gt;click me&lt;/button&gt; ) // 使用render渲染已创建的元素 ReactDOM.render( element, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; 12345### 条件渲染 v-if&gt; 在jsx语法中,使用三元表达式可以实现这一项功能 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; ReactDOM.render( { Math.random()*10>5?这是内容1:这是内容2 } , document.getElementById('root') ); 1234### 列表渲染 v-for&gt; 在jsx语法中, 使用map函数完成这一项功能 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--提供react的dom操作的相关功能--&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;!--jsx语法 支持标签和js的混写--&gt; &lt;script type=&quot;text/babel&quot;&gt; var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; ReactDOM.render( &lt;div&gt; { names.map(function(ele,index,arr){ /*Each child in an array or iterator should have a unique &quot;key&quot; prop.*/ return &lt;h1&gt;{ele}&lt;/h1&gt; }) } &lt;/div&gt;, document.getElementById(&apos;example&apos;) ) &lt;/script&gt; &lt;/body&gt; 123456## jsx深入理解### jsx语法的基本实现 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; //内联样式 var myStyle = { color:\"red\" } // 使用jsx语法创建模板 const element1 = ( Hello, world! ); ReactDOM.render( element1, document.getElementById('root') ); 1234### React.createElement()**从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖** Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; // 使用对象表示 法 // 从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖 const element2 = React.createElement( 'div', {className:\"greeting\"}, '哈哈' ) // 类似于这样一种简化的结构 const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, world' } }; ReactDOM.render( element2, document.getElementById('root') ); 12345678## react数据变化检测--元素渲染&gt; 元素(Elements)是 React 应用中最小的构建部件（或者说构建块，building blocks）。&gt; &gt; &gt; &gt; 元素用于描述你在页面上看到的内容### 页面的基本渲染 Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; // 创建元素 var element = Hello, world! //使用render 渲染函数渲染已创建的元素到指定的位置 ReactDOM.render( element, document.getElementById('root') ); 123456### 元素的更新**在React中,元素是不能发生突变的,要进行元素的,一旦创建了元素,就不能修改其子元素或者是相关的属性****元素更新的措施是: 创建一个新的元素并使用render函数重新渲染** Hello World &lt;!--react的与dom相关的一些功能--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script crossorigin src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; function tick() { // 创建元素 const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); //使用render函数进行页面的渲染 ReactDOM.render( element, document.getElementById('root') ); } setInterval(tick, 1000); 12345678910111213### 页面变化检测与更新的实现原理- react维护两个状态——现在的页面DOM、即将要渲染的页面DOM（数据) 两部分进行对比：自动渲染不同部分。- 每次发生事件、动画，都会和之前的状态进行对比。 - 相同：不再次进行渲染。 - 不同：进行渲染界面。 - 适合大量数据操作的框架——react。参考链接 https://zhuanlan.zhihu.com/purerender/2034637 在react中,当元素发生变化的时候,并不会进行所有的元素的更新, 在react内部,执行了一个diff 算法,只对当前变化的节点进行检测更新,而不是更新所有的节点 在react中,使用diff + virtual dom 结合的方式,实现元素的变化检测与更新 `","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"02-jsx语法","slug":"react/02-jsx语法","permalink":"http://yoursite.com/categories/react/02-jsx语法/"}],"tags":[]},{"title":"react入门","slug":"react/01-react入门/01-react入门","date":"2018-05-08T00:22:57.839Z","updated":"2018-05-08T00:42:47.547Z","comments":true,"path":"2018/05/08/react/01-react入门/01-react入门/","link":"","permalink":"http://yoursite.com/2018/05/08/react/01-react入门/01-react入门/","excerpt":"","text":"react入门– 案例驱动—示例 react是什么 React 是一个用于构建用户界面的 JAVASCRIPT 库。 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 起源 React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站 描述12345678由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单这个项目本身也越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案。衍生的 React Native 项目，目标更是宏伟，希望用写 Web App 的方式去写 Native App。如果能够实现，整个互联网行业都会被颠覆，因为同一组人只需要写一次 UI ，就能同时运行在服务器、浏览器和手机 为什么使用reactreact的特点12345671.声明式设计 −React采用声明范式，可以轻松描述应用。2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。3.灵活 −React可以与已知的库或框架很好地配合。4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 以下描述仅仅是个人理解 单向数据流12在React中，数据的流向是单向的——从父节点传递到子节点，因为组件是简单而且易于把握的，他们只需从父节点获取props渲染即可，如果顶层组件的某个prop改变饿了，React会递归的向下便利整棵组件树，重新渲染所有使用这个属性的组件。 声明式设计12345678910111213141516171819202122232425262728// 声明式const element1 = React.createElement( &apos;div&apos;, &#123;className:&quot;greeting&quot;&#125;, &apos;哈哈&apos;)// 过程式element2 = document.createElement &apos;div&apos;element2.className = &apos;greeting&apos;element2.innerHTML = &apos;哈哈&apos;// 类似于这样一种简化的结构const element = &#123; type: &apos;h1&apos;, props: &#123; className: &apos;greeting&apos;, children: &apos;Hello, world&apos; &#125;&#125;;ReactDOM.render( element1, document.getElementById(&apos;root&apos;) ); 组件 两大特性 封装 重用 优势虚拟dom 虚拟dom 用于性能的提升 组件化 组件化 , 实现代码的重用 如何使用react hello world 示例 hello world示例js核心库 react的使用离不开三个核心的库 1234567891011// 新版本 &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt;// 久版本 &lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react-dom.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js&quot;&gt;&lt;/script&gt; hello world示例 最小化的 HTML 模板 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;!--react的核心库--&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!--react的与dom相关的一些功能--&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!--将浏览器不支持的jsx语法转化为js语法--&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;!-- &lt;script&gt; 标签的 type 属性为 text/babel 。 这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。 凡是使用 JSX 的地方，都要加上 type=&quot;text/babel&quot; 。 --&gt; &lt;script type=&quot;text/babel&quot;&gt; // ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;root&apos;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- -&gt; CDNReact 和 ReactDOM 的UMD版本可通过 CDN 获得。 开发环境12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 生产环境 相比开发环境进行了压缩和优化 12&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.production.min.js&quot;&gt;&lt;/script&gt;&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; crossorigin如果你从 CDN 引用 React，我们建议保留 crossorigin 属性设置：","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"01-react入门","slug":"react/01-react入门","permalink":"http://yoursite.com/categories/react/01-react入门/"}],"tags":[]},{"title":"react优质学习资源","slug":"react/00-学习资料参考/00-学习资料参考","date":"2018-05-08T00:22:57.823Z","updated":"2018-05-08T00:38:56.423Z","comments":true,"path":"2018/05/08/react/00-学习资料参考/00-学习资料参考/","link":"","permalink":"http://yoursite.com/2018/05/08/react/00-学习资料参考/00-学习资料参考/","excerpt":"","text":"react优质学习资源官方文档fetchfetch CDN https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetchfetch CDN https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API react基本知识点react中文文档 http://www.css88.com/react/docs/portals.html react英文文档 https://reactjs.org/docs/react-api.html react中文网 http://www.reactchina.cn/ react生命周期 https://facebook.github.io/react/docs/react-component.html reduxredux中文文档 http://www.redux.org.cn/docs/react-redux/api.html react路由react路由的官方文档 https://react-guide.github.io/react-router-cn/docs/API.html react web http://reacttraining.cn react v4 中文文档 http://reacttraining.cn/web/guides/quick-start react-router http://reacttraining.cn/web/example/basic 文档博客书籍类阮一峰 也许dom不是答案 http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html react入门实例教程 http://www.ruanyifeng.com/blog/2015/03/react 开源项目类基于webpack、react、react-router 4.0、antd-m的App项目 https://github.com/liwudi/online-educationApp react-native https://github.com/liwudi/qingqi-auto-owner-app.git react https://github.com/liwudi/online-educationApp.git 视频类大众点评项目实战 https://coding.imooc.com/class/package/99.html#Anchor","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"00-学习资料参考","slug":"react/00-学习资料参考","permalink":"http://yoursite.com/categories/react/00-学习资料参考/"}],"tags":[]},{"title":"介绍","slug":"hello-world","date":"2018-05-07T22:30:03.040Z","updated":"2018-05-08T00:58:03.617Z","comments":true,"path":"2018/05/08/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/08/hello-world/","excerpt":"","text":"独白 我只是一小白","categories":[],"tags":[]}]}